/*
Deployment script for qbq.EPCIS.RepositoryOld

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar DatabaseName "qbq.EPCIS.RepositoryOld"
:setvar DefaultFilePrefix "qbq.EPCIS.RepositoryOld"
:setvar DefaultDataPath "C:\Program Files\Microsoft SQL Server\MSSQL15.SQLEXPRESS\MSSQL\DATA\"
:setvar DefaultLogPath "C:\Program Files\Microsoft SQL Server\MSSQL15.SQLEXPRESS\MSSQL\DATA\"

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [master];


GO

IF (DB_ID(N'$(DatabaseName)') IS NOT NULL) 
BEGIN
    ALTER DATABASE [$(DatabaseName)]
    SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
    DROP DATABASE [$(DatabaseName)];
END

GO
PRINT N'Creating $(DatabaseName)...'
GO
CREATE DATABASE [$(DatabaseName)]
    ON 
    PRIMARY(NAME = [$(DatabaseName)], FILENAME = N'$(DefaultDataPath)$(DefaultFilePrefix)_Primary.mdf')
    LOG ON (NAME = [$(DatabaseName)_log], FILENAME = N'$(DefaultLogPath)$(DefaultFilePrefix)_Primary.ldf') COLLATE SQL_Latin1_General_CP1_CI_AS
GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET AUTO_CLOSE OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
USE [$(DatabaseName)];


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ANSI_NULLS ON,
                ANSI_PADDING ON,
                ANSI_WARNINGS ON,
                ARITHABORT ON,
                CONCAT_NULL_YIELDS_NULL ON,
                NUMERIC_ROUNDABORT OFF,
                QUOTED_IDENTIFIER ON,
                ANSI_NULL_DEFAULT ON,
                CURSOR_DEFAULT LOCAL,
                RECOVERY FULL,
                CURSOR_CLOSE_ON_COMMIT OFF,
                AUTO_CREATE_STATISTICS ON,
                AUTO_SHRINK OFF,
                AUTO_UPDATE_STATISTICS ON,
                RECURSIVE_TRIGGERS OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ALLOW_SNAPSHOT_ISOLATION OFF;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET READ_COMMITTED_SNAPSHOT OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET AUTO_UPDATE_STATISTICS_ASYNC OFF,
                PAGE_VERIFY NONE,
                DATE_CORRELATION_OPTIMIZATION OFF,
                DISABLE_BROKER,
                PARAMETERIZATION SIMPLE,
                SUPPLEMENTAL_LOGGING OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF IS_SRVROLEMEMBER(N'sysadmin') = 1
    BEGIN
        IF EXISTS (SELECT 1
                   FROM   [master].[dbo].[sysdatabases]
                   WHERE  [name] = N'$(DatabaseName)')
            BEGIN
                EXECUTE sp_executesql N'ALTER DATABASE [$(DatabaseName)]
    SET TRUSTWORTHY OFF,
        DB_CHAINING OFF 
    WITH ROLLBACK IMMEDIATE';
            END
    END
ELSE
    BEGIN
        PRINT N'The database settings cannot be modified. You must be a SysAdmin to apply these settings.';
    END


GO
IF IS_SRVROLEMEMBER(N'sysadmin') = 1
    BEGIN
        IF EXISTS (SELECT 1
                   FROM   [master].[dbo].[sysdatabases]
                   WHERE  [name] = N'$(DatabaseName)')
            BEGIN
                EXECUTE sp_executesql N'ALTER DATABASE [$(DatabaseName)]
    SET HONOR_BROKER_PRIORITY OFF 
    WITH ROLLBACK IMMEDIATE';
            END
    END
ELSE
    BEGIN
        PRINT N'The database settings cannot be modified. You must be a SysAdmin to apply these settings.';
    END


GO
ALTER DATABASE [$(DatabaseName)]
    SET TARGET_RECOVERY_TIME = 0 SECONDS 
    WITH ROLLBACK IMMEDIATE;


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET FILESTREAM(NON_TRANSACTED_ACCESS = OFF),
                CONTAINMENT = NONE 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET AUTO_CREATE_STATISTICS ON(INCREMENTAL = OFF),
                MEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT = OFF,
                DELAYED_DURABILITY = DISABLED 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE SCOPED CONFIGURATION SET MAXDOP = 0;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET MAXDOP = PRIMARY;
        ALTER DATABASE SCOPED CONFIGURATION SET LEGACY_CARDINALITY_ESTIMATION = OFF;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET LEGACY_CARDINALITY_ESTIMATION = PRIMARY;
        ALTER DATABASE SCOPED CONFIGURATION SET PARAMETER_SNIFFING = ON;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET PARAMETER_SNIFFING = PRIMARY;
        ALTER DATABASE SCOPED CONFIGURATION SET QUERY_OPTIMIZER_HOTFIXES = OFF;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET QUERY_OPTIMIZER_HOTFIXES = PRIMARY;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET TEMPORAL_HISTORY_RETENTION ON 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF fulltextserviceproperty(N'IsFulltextInstalled') = 1
    EXECUTE sp_fulltext_database 'enable';


GO
PRINT N'Creating [Import]...';


GO
CREATE ROLE [Import]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [Analysis]...';


GO
CREATE SCHEMA [Analysis]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [Callback]...';


GO
CREATE SCHEMA [Callback]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [DocumentHeader]...';


GO
CREATE SCHEMA [DocumentHeader]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [Event]...';


GO
CREATE SCHEMA [Event]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [Helper]...';


GO
CREATE SCHEMA [Helper]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [Import]...';


GO
CREATE SCHEMA [Import]
    AUTHORIZATION [Import];


GO
PRINT N'Creating [Vocabulary]...';


GO
CREATE SCHEMA [Vocabulary]
    AUTHORIZATION [Import];


GO
PRINT N'Creating [Analysis].[Time]...';


GO
CREATE TABLE [Analysis].[Time] (
    [PK_Date]               DATE          NOT NULL,
    [Date_Name]             NVARCHAR (50) NULL,
    [Year]                  DATETIME      NULL,
    [Year_Name]             NVARCHAR (50) NULL,
    [Half_Year]             DATETIME      NULL,
    [Half_Year_Name]        NVARCHAR (50) NULL,
    [Quarter]               DATETIME      NULL,
    [Quarter_Name]          NVARCHAR (50) NULL,
    [Month]                 DATETIME      NULL,
    [Month_Name]            NVARCHAR (50) NULL,
    [Week]                  DATETIME      NULL,
    [Week_Name]             NVARCHAR (50) NULL,
    [Day_Of_Year]           INT           NULL,
    [Day_Of_Year_Name]      NVARCHAR (50) NULL,
    [Day_Of_Half_Year]      INT           NULL,
    [Day_Of_Half_Year_Name] NVARCHAR (50) NULL,
    [Day_Of_Quarter]        INT           NULL,
    [Day_Of_Quarter_Name]   NVARCHAR (50) NULL,
    [Day_Of_Month]          INT           NULL,
    [Day_Of_Month_Name]     NVARCHAR (50) NULL,
    [Day_Of_Week]           INT           NULL,
    [Day_Of_Week_Name]      NVARCHAR (50) NULL,
    [Week_Of_Year]          INT           NULL,
    [Month_Of_Year]         INT           NULL,
    [Month_Of_Half_Year]    INT           NULL,
    [Month_Of_Quarter]      INT           NULL,
    [Quarter_Of_Year]       INT           NULL,
    [Quarter_Of_Half_Year]  INT           NULL,
    [Half_Year_Of_Year]     INT           NULL,
    CONSTRAINT [PK_Analysis_Time] PRIMARY KEY CLUSTERED ([PK_Date] ASC)
);


GO
PRINT N'Creating [Analysis].[Settings]...';


GO
CREATE TABLE [Analysis].[Settings] (
    [ID]       NVARCHAR (50)  NOT NULL,
    [Value]    NVARCHAR (500) NOT NULL,
    [ClientID] BIGINT         NOT NULL,
    CONSTRAINT [PK_Analysis_Settings] PRIMARY KEY CLUSTERED ([ID] ASC, [ClientID] ASC)
);


GO
PRINT N'Creating [Callback].[Trigger]...';


GO
CREATE TABLE [Callback].[Trigger] (
    [ID]  BIGINT         IDENTITY (1, 1) NOT NULL,
    [URN] NVARCHAR (512) NOT NULL,
    PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [Callback].[Trigger].[IX_Trigger_URN]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [IX_Trigger_URN]
    ON [Callback].[Trigger]([URN] ASC);


GO
PRINT N'Creating [Callback].[Subscription_Trigger]...';


GO
CREATE TABLE [Callback].[Subscription_Trigger] (
    [SubscriptionID] BIGINT NOT NULL,
    [TriggerID]      BIGINT NOT NULL,
    CONSTRAINT [PK_Subscription_Trigger] PRIMARY KEY CLUSTERED ([SubscriptionID] ASC, [TriggerID] ASC)
);


GO
PRINT N'Creating [Callback].[Subscription]...';


GO
CREATE TABLE [Callback].[Subscription] (
    [ID]                  BIGINT         IDENTITY (1, 1) NOT NULL,
    [ClientID]            BIGINT         NOT NULL,
    [Username]            NVARCHAR (512) NOT NULL,
    [Subscription]        NVARCHAR (512) NOT NULL,
    [Query]               XML            NOT NULL,
    [DestinationEndpoint] NVARCHAR (512) NOT NULL,
    [InitialRecordTime]   DATETIME2 (0)  NOT NULL,
    [LastRecordTime]      DATETIME2 (0)  NOT NULL,
    [ReportIfEmpty]       BIT            NOT NULL,
    [Active]              BIT            NOT NULL,
    CONSTRAINT [PK_Subscription] PRIMARY KEY CLUSTERED ([ID] ASC),
    CONSTRAINT [AK_Subscription_Subscription] UNIQUE NONCLUSTERED ([Subscription] ASC)
);


GO
PRINT N'Creating [Callback].[Schedule_Part]...';


GO
CREATE TABLE [Callback].[Schedule_Part] (
    [ScheduleID] BIGINT   NOT NULL,
    [DatePart]   CHAR (2) NOT NULL,
    [Value]      TINYINT  NOT NULL,
    CONSTRAINT [PK_Schedule_Part] PRIMARY KEY CLUSTERED ([ScheduleID] ASC, [DatePart] ASC, [Value] ASC)
);


GO
PRINT N'Creating [Callback].[Schedule]...';


GO
CREATE TABLE [Callback].[Schedule] (
    [ID]             BIGINT        IDENTITY (1, 1) NOT NULL,
    [SubscriptionID] BIGINT        NOT NULL,
    [NextRun]        DATETIME2 (0) NOT NULL,
    PRIMARY KEY CLUSTERED ([ID] ASC),
    CONSTRAINT [AK_Schedule_Subscription_ID] UNIQUE NONCLUSTERED ([SubscriptionID] ASC)
);


GO
PRINT N'Creating [Callback].[Schedule].[IX_Schedule_NextRun]...';


GO
CREATE NONCLUSTERED INDEX [IX_Schedule_NextRun]
    ON [Callback].[Schedule]([SubscriptionID] ASC, [NextRun] ASC);


GO
PRINT N'Creating [DocumentHeader].[EPCISDocumentHeader]...';


GO
CREATE TABLE [DocumentHeader].[EPCISDocumentHeader] (
    [ID]                  BIGINT    IDENTITY (1, 1) NOT NULL,
    [HeaderVersion]       CHAR (10) NOT NULL,
    [EPCISDocumentHeader] XML       NOT NULL,
    CONSTRAINT [PK_EPCISDocumentHeader] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [Event].[EPCISEvent_QuantityElement]...';


GO
CREATE TABLE [Event].[EPCISEvent_QuantityElement] (
    [ID]                BIGINT IDENTITY (1, 1) NOT NULL,
    [EPCISEventID]      BIGINT NOT NULL,
    [IsInput]           BIT    NOT NULL,
    [IsOutput]          BIT    NOT NULL,
    [QuantityElementID] BIGINT NOT NULL,
    CONSTRAINT [PK_EPCISEvent_QuantityElement] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [Event].[EPCISEvent_QuantityElement].[IX_EPCISEvent_QuantityElement]...';


GO
CREATE NONCLUSTERED INDEX [IX_EPCISEvent_QuantityElement]
    ON [Event].[EPCISEvent_QuantityElement]([EPCISEventID] ASC, [QuantityElementID] ASC)
    INCLUDE([IsInput]);


GO
PRINT N'Creating [Event].[EPCISEvent_EPC]...';


GO
CREATE TABLE [Event].[EPCISEvent_EPC] (
    [ID]           BIGINT IDENTITY (1, 1) NOT NULL,
    [EPCISEventID] BIGINT NOT NULL,
    [EPCID]        BIGINT NOT NULL,
    [IsParentID]   BIT    NOT NULL,
    [IsInput]      BIT    NOT NULL,
    [IsOutput]     BIT    NOT NULL,
    CONSTRAINT [PK_EPCISEvent_EPC] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [Event].[EPCISEvent_EPC].[IX_EPCISEvent_EPC]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [IX_EPCISEvent_EPC]
    ON [Event].[EPCISEvent_EPC]([EPCISEventID] ASC, [EPCID] ASC, [IsParentID] ASC, [IsInput] ASC)
    INCLUDE([IsOutput]);


GO
PRINT N'Creating [Event].[EPCISEvent_BusinessTransactionID]...';


GO
CREATE TABLE [Event].[EPCISEvent_BusinessTransactionID] (
    [ID]                      BIGINT IDENTITY (1, 1) NOT NULL,
    [EPCISEventID]            BIGINT NOT NULL,
    [BusinessTransactionIDID] BIGINT NOT NULL,
    CONSTRAINT [PK_EPCISEvent_BusinessTransactionID] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [Event].[EPCISEvent_BusinessTransactionID].[IX_EPCISEvent_BusinessTransactionID_EPCISEventID]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [IX_EPCISEvent_BusinessTransactionID_EPCISEventID]
    ON [Event].[EPCISEvent_BusinessTransactionID]([EPCISEventID] ASC, [BusinessTransactionIDID] ASC);


GO
PRINT N'Creating [Event].[EPCISEvent]...';


GO
CREATE TABLE [Event].[EPCISEvent] (
    [ID]                  BIGINT             IDENTITY (1, 1) NOT NULL,
    [ClientID]            BIGINT             NOT NULL,
    [EventTime]           DATETIME2 (0)      NOT NULL,
    [RecordTime]          DATETIME2 (0)      NOT NULL,
    [EventTimeZoneOffset] DATETIMEOFFSET (7) NOT NULL,
    [XmlRepresentation]   XML                NOT NULL,
    [Error]               BIT                NOT NULL,
    CONSTRAINT [PK_EPCISEvent] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [Event].[EPCISEvent].[IX_EPCISEvent_ClientID]...';


GO
CREATE NONCLUSTERED INDEX [IX_EPCISEvent_ClientID]
    ON [Event].[EPCISEvent]([ClientID] ASC)
    INCLUDE([ID]);


GO
PRINT N'Creating [Event].[EPCISEvent].[IX_EPCISEvent_EventTime]...';


GO
CREATE NONCLUSTERED INDEX [IX_EPCISEvent_EventTime]
    ON [Event].[EPCISEvent]([EventTime] ASC)
    INCLUDE([ID], [ClientID], [RecordTime]);


GO
PRINT N'Creating [Event].[EPCISEvent].[IX_EPCISEvent_RecordTime]...';


GO
CREATE NONCLUSTERED INDEX [IX_EPCISEvent_RecordTime]
    ON [Event].[EPCISEvent]([RecordTime] ASC)
    INCLUDE([ID], [ClientID], [EventTime]);


GO
PRINT N'Creating [Event].[EPCISEvent].[IX_EPCISEvent_EventTimeZoneOffset]...';


GO
CREATE NONCLUSTERED INDEX [IX_EPCISEvent_EventTimeZoneOffset]
    ON [Event].[EPCISEvent]([EventTimeZoneOffset] ASC)
    INCLUDE([ID], [ClientID], [RecordTime]);


GO
PRINT N'Creating [Event].[EPC]...';


GO
CREATE TABLE [Event].[EPC] (
    [ID]  BIGINT         IDENTITY (1, 1) NOT NULL,
    [URN] NVARCHAR (512) NOT NULL,
    CONSTRAINT [PK_EPC] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [Event].[EPC].[IX_EPC]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [IX_EPC]
    ON [Event].[EPC]([URN] ASC);


GO
PRINT N'Creating [Event].[BusinessTransactionID]...';


GO
CREATE TABLE [Event].[BusinessTransactionID] (
    [ID]                        BIGINT         IDENTITY (1, 1) NOT NULL,
    [URN]                       NVARCHAR (512) NOT NULL,
    [BusinessTransactionTypeID] BIGINT         NOT NULL,
    CONSTRAINT [PK_BusinessTransactionID] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [Event].[BusinessTransactionID].[IX_BusinessTransactionID]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [IX_BusinessTransactionID]
    ON [Event].[BusinessTransactionID]([URN] ASC, [BusinessTransactionTypeID] ASC);


GO
PRINT N'Creating [Event].[Value_String]...';


GO
CREATE TABLE [Event].[Value_String] (
    [ID]    BIGINT          IDENTITY (1, 1) NOT NULL,
    [Value] NVARCHAR (1024) NOT NULL,
    PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [Event].[Value_String].[IX_Value_String_Value]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [IX_Value_String_Value]
    ON [Event].[Value_String]([Value] ASC);


GO
PRINT N'Creating [Event].[TransformationID]...';


GO
CREATE TABLE [Event].[TransformationID] (
    [ID]  BIGINT         IDENTITY (1, 1) NOT NULL,
    [URN] NVARCHAR (512) NOT NULL,
    CONSTRAINT [PK_TransformationID] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [Event].[TransformationID].[IX_TransformationID]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [IX_TransformationID]
    ON [Event].[TransformationID]([URN] ASC);


GO
PRINT N'Creating [Event].[QuantityElement]...';


GO
CREATE TABLE [Event].[QuantityElement] (
    [ID]         BIGINT     IDENTITY (1, 1) NOT NULL,
    [EPCClassID] BIGINT     NOT NULL,
    [Quantity]   FLOAT (53) NOT NULL,
    [UOM]        NCHAR (3)  NOT NULL,
    CONSTRAINT [PK_QuantityElement] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [Event].[QuantityElement].[IX_QuantityElement]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [IX_QuantityElement]
    ON [Event].[QuantityElement]([EPCClassID] ASC, [Quantity] ASC, [UOM] ASC);


GO
PRINT N'Creating [Event].[EPCISEvent_Vocabulary]...';


GO
CREATE TABLE [Event].[EPCISEvent_Vocabulary] (
    [ID]           BIGINT IDENTITY (1, 1) NOT NULL,
    [EPCISEventID] BIGINT NOT NULL,
    [VocabularyID] BIGINT NOT NULL,
    CONSTRAINT [PK_EPCISEvent_Vocabulary] PRIMARY KEY CLUSTERED ([ID] ASC),
    CONSTRAINT [AK_EPCISEvent_Vocabulary_EPCISEventID_VocabularyID] UNIQUE NONCLUSTERED ([EPCISEventID] ASC, [VocabularyID] ASC)
);


GO
PRINT N'Creating [Event].[EPCISEvent_Vocabulary].[IX_EPCISEvent_EPCISEventID]...';


GO
CREATE NONCLUSTERED INDEX [IX_EPCISEvent_EPCISEventID]
    ON [Event].[EPCISEvent_Vocabulary]([EPCISEventID] ASC)
    INCLUDE([VocabularyID]);


GO
PRINT N'Creating [Event].[EPCISEvent_Vocabulary].[IX_EPCISEvent_VocabularyID]...';


GO
CREATE NONCLUSTERED INDEX [IX_EPCISEvent_VocabularyID]
    ON [Event].[EPCISEvent_Vocabulary]([VocabularyID] ASC)
    INCLUDE([EPCISEventID]);


GO
PRINT N'Creating [Event].[EPCISEvent_Value_Numeric]...';


GO
CREATE TABLE [Event].[EPCISEvent_Value_Numeric] (
    [EPCISEvent_ValueID] BIGINT     NOT NULL,
    [Value]              FLOAT (53) NOT NULL,
    PRIMARY KEY CLUSTERED ([EPCISEvent_ValueID] ASC)
);


GO
PRINT N'Creating [Event].[EPCISEvent_Value_Numeric].[IX_EPCISEvent_Value_Numeric_Value]...';


GO
CREATE NONCLUSTERED INDEX [IX_EPCISEvent_Value_Numeric_Value]
    ON [Event].[EPCISEvent_Value_Numeric]([Value] ASC);


GO
PRINT N'Creating [Event].[EPCISEvent_Value_Datetime]...';


GO
CREATE TABLE [Event].[EPCISEvent_Value_Datetime] (
    [EPCISEvent_ValueID] BIGINT             NOT NULL,
    [Value]              DATETIMEOFFSET (7) NOT NULL,
    PRIMARY KEY CLUSTERED ([EPCISEvent_ValueID] ASC)
);


GO
PRINT N'Creating [Event].[EPCISEvent_Value_Datetime].[IX_EPCISEvent_Value_Datetime_Value]...';


GO
CREATE NONCLUSTERED INDEX [IX_EPCISEvent_Value_Datetime_Value]
    ON [Event].[EPCISEvent_Value_Datetime]([Value] ASC);


GO
PRINT N'Creating [Event].[EPCISEvent_Value]...';


GO
CREATE TABLE [Event].[EPCISEvent_Value] (
    [ID]           BIGINT IDENTITY (1, 1) NOT NULL,
    [EPCISEventID] BIGINT NOT NULL,
    [ValueTypeID]  BIGINT NOT NULL,
    [DataTypeID]   BIGINT NOT NULL,
    CONSTRAINT [PK_EPCISEvent_Value] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [Event].[EPCISEvent_Value].[IX_EPCISEvent_DataTypeID]...';


GO
CREATE NONCLUSTERED INDEX [IX_EPCISEvent_DataTypeID]
    ON [Event].[EPCISEvent_Value]([DataTypeID] ASC);


GO
PRINT N'Creating [Event].[EPCISEvent_Value].[IX_EPCISEvent_EPCISEventID]...';


GO
CREATE NONCLUSTERED INDEX [IX_EPCISEvent_EPCISEventID]
    ON [Event].[EPCISEvent_Value]([EPCISEventID] ASC);


GO
PRINT N'Creating [Event].[EPCISEvent_Value].[IX_EPCISEvent_ValueTypeID]...';


GO
CREATE NONCLUSTERED INDEX [IX_EPCISEvent_ValueTypeID]
    ON [Event].[EPCISEvent_Value]([ValueTypeID] ASC)
    INCLUDE([DataTypeID]);


GO
PRINT N'Creating [Event].[EPCISEvent_TransformationID]...';


GO
CREATE TABLE [Event].[EPCISEvent_TransformationID] (
    [ID]                 BIGINT IDENTITY (1, 1) NOT NULL,
    [EPCISEventID]       BIGINT NOT NULL,
    [TransformationIDID] BIGINT NOT NULL,
    CONSTRAINT [PK_EPCISEvent_TransformationID] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [Event].[EPCISEvent_TransformationID].[IX_EPCISEvent_TransformationID]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [IX_EPCISEvent_TransformationID]
    ON [Event].[EPCISEvent_TransformationID]([EPCISEventID] ASC, [TransformationIDID] ASC);


GO
PRINT N'Creating [Event].[EPCISEvent_SourceDestination]...';


GO
CREATE TABLE [Event].[EPCISEvent_SourceDestination] (
    [ID]                      BIGINT IDENTITY (1, 1) NOT NULL,
    [IsSource]                BIT    NOT NULL,
    [EPCISEventID]            BIGINT NOT NULL,
    [SourceDestinationID]     BIGINT NOT NULL,
    [SourceDestinationTypeID] BIGINT NOT NULL,
    CONSTRAINT [PK_EPCISEvent_SourceDestination] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [Event].[EPCISEvent_SourceDestination].[IX_EPCISEvent_SourceDestination]...';


GO
CREATE NONCLUSTERED INDEX [IX_EPCISEvent_SourceDestination]
    ON [Event].[EPCISEvent_SourceDestination]([EPCISEventID] ASC, [SourceDestinationID] ASC, [SourceDestinationTypeID] ASC)
    INCLUDE([IsSource]);


GO
PRINT N'Creating [Event].[EPCISEvent_DocumentHeader]...';


GO
CREATE TABLE [Event].[EPCISEvent_DocumentHeader] (
    [ID]               BIGINT IDENTITY (1, 1) NOT NULL,
    [EPCISEventID]     BIGINT NOT NULL,
    [DocumentHeaderID] BIGINT NOT NULL,
    CONSTRAINT [PK_EPCISEvent_DocumentHeader] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [Event].[EPCISEvent_Value_Hierarchy]...';


GO
CREATE TABLE [Event].[EPCISEvent_Value_Hierarchy] (
    [ID]                        BIGINT IDENTITY (1, 1) NOT NULL,
    [EPCISEvent_ValueID]        BIGINT NOT NULL,
    [Parent_EPCISEvent_ValueID] BIGINT NOT NULL,
    PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [Event].[EPCISEvent_Value_String]...';


GO
CREATE TABLE [Event].[EPCISEvent_Value_String] (
    [ID]                 BIGINT IDENTITY (1, 1) NOT NULL,
    [EPCISEvent_ValueID] BIGINT NOT NULL,
    [Value_StringID]     BIGINT NOT NULL,
    CONSTRAINT [PK_EPCISEvent_Value_String] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [Event].[EPCISEvent_Value_String].[IX_EPCISEvent_Value_String]...';


GO
CREATE NONCLUSTERED INDEX [IX_EPCISEvent_Value_String]
    ON [Event].[EPCISEvent_Value_String]([Value_StringID] ASC)
    INCLUDE([EPCISEvent_ValueID]);


GO
PRINT N'Creating [Import].[HELP]...';


GO
CREATE TABLE [Import].[HELP] (
    [ObjectID] BIGINT NOT NULL
);


GO
PRINT N'Creating [Import].[Error]...';


GO
CREATE TABLE [Import].[Error] (
    [ErrorID]               BIGINT          IDENTITY (1, 1) NOT NULL,
    [TimeStampGeneration]   DATETIME        NOT NULL,
    [AdditionalInformation] NVARCHAR (2048) NOT NULL,
    [ErrorNumber]           INT             NOT NULL,
    [ErrorSeverity]         INT             NOT NULL,
    [ErrorProcedure]        NVARCHAR (126)  NOT NULL,
    [ErrorMessage]          NVARCHAR (2048) NOT NULL,
    [ErrorLine]             INT             NOT NULL,
    [ErrorState]            INT             NOT NULL,
    [ObjectID]              BIGINT          NOT NULL,
    CONSTRAINT [PK_Error] PRIMARY KEY CLUSTERED ([ErrorID] ASC) WITH (FILLFACTOR = 80)
);


GO
PRINT N'Creating [Import].[EPCISMasterData_Queue]...';


GO
CREATE TABLE [Import].[EPCISMasterData_Queue] (
    [ID]                      BIGINT         IDENTITY (1, 1) NOT NULL,
    [Client]                  NVARCHAR (512) NOT NULL,
    [EPCISMasterData]         XML            NOT NULL,
    [Processed]               BIT            NOT NULL,
    [Error]                   BIT            NOT NULL,
    [EPCISMasterDataOriginal] XML            NULL,
    CONSTRAINT [PK_EPCISMasterData_Queue] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [Import].[EPCISEvent_Queue]...';


GO
CREATE TABLE [Import].[EPCISEvent_Queue] (
    [ID]                 BIGINT         IDENTITY (1, 1) NOT NULL,
    [Client]             NVARCHAR (512) NOT NULL,
    [EPCISEvent]         XML            NOT NULL,
    [Processed]          BIT            NOT NULL,
    [Error]              BIT            NOT NULL,
    [EPCISEventOriginal] XML            NULL,
    CONSTRAINT [PK_EPCISEvent_Queue] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [Vocabulary].[VocabularyType_Client]...';


GO
CREATE TABLE [Vocabulary].[VocabularyType_Client] (
    [ClientID]         BIGINT NOT NULL,
    [VocabularyTypeID] BIGINT NOT NULL,
    [Deleted]          BIT    NOT NULL,
    CONSTRAINT [PK_VocabularyType_Client] PRIMARY KEY CLUSTERED ([ClientID] ASC, [VocabularyTypeID] ASC)
);


GO
PRINT N'Creating [Vocabulary].[VocabularyType_Client].[IX_VocabularyType_Client]...';


GO
CREATE NONCLUSTERED INDEX [IX_VocabularyType_Client]
    ON [Vocabulary].[VocabularyType_Client]([VocabularyTypeID] ASC)
    INCLUDE([ClientID]);


GO
PRINT N'Creating [Vocabulary].[VocabularyType]...';


GO
CREATE TABLE [Vocabulary].[VocabularyType] (
    [ID]          BIGINT         IDENTITY (1, 1) NOT NULL,
    [URN]         NVARCHAR (512) NOT NULL,
    [Description] NVARCHAR (50)  NOT NULL,
    [MaxOccurs]   INT            NOT NULL,
    CONSTRAINT [PK_VocabularyType] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [Vocabulary].[VocabularyType].[IX_VocabularyType]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [IX_VocabularyType]
    ON [Vocabulary].[VocabularyType]([URN] ASC);


GO
PRINT N'Creating [Vocabulary].[VocabularyChildren]...';


GO
CREATE TABLE [Vocabulary].[VocabularyChildren] (
    [ID]                BIGINT IDENTITY (1, 1) NOT NULL,
    [VocabularyID]      BIGINT NOT NULL,
    [ChildVocabularyID] BIGINT NOT NULL,
    [Deleted]           BIT    NOT NULL,
    CONSTRAINT [PK_VocabularyChildren] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [Vocabulary].[VocabularyChildren].[IX_VocabularyChildren]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [IX_VocabularyChildren]
    ON [Vocabulary].[VocabularyChildren]([VocabularyID] ASC, [ChildVocabularyID] ASC);


GO
PRINT N'Creating [Vocabulary].[VocabularyAttribute]...';


GO
CREATE TABLE [Vocabulary].[VocabularyAttribute] (
    [ID]              BIGINT IDENTITY (1, 1) NOT NULL,
    [VocabularyID]    BIGINT NOT NULL,
    [AttributeTypeID] BIGINT NOT NULL,
    [Value]           XML    NOT NULL,
    [Deleted]         BIT    NOT NULL,
    CONSTRAINT [PK_VocabularyAttribute] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [Vocabulary].[VocabularyAttribute].[IX_VocabularyAttribute]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [IX_VocabularyAttribute]
    ON [Vocabulary].[VocabularyAttribute]([VocabularyID] ASC, [AttributeTypeID] ASC);


GO
PRINT N'Creating [Vocabulary].[Vocabulary]...';


GO
CREATE TABLE [Vocabulary].[Vocabulary] (
    [ID]               BIGINT         IDENTITY (1, 1) NOT NULL,
    [ClientID]         BIGINT         NOT NULL,
    [VocabularyTypeID] BIGINT         NOT NULL,
    [URN]              NVARCHAR (512) NOT NULL,
    [Deleted]          BIT            NOT NULL,
    CONSTRAINT [PK_Vocabulary] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [Vocabulary].[Vocabulary].[IX_Vocabulary]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [IX_Vocabulary]
    ON [Vocabulary].[Vocabulary]([URN] ASC, [VocabularyTypeID] ASC, [ClientID] ASC);


GO
PRINT N'Creating [Vocabulary].[AttributeType]...';


GO
CREATE TABLE [Vocabulary].[AttributeType] (
    [ID]            BIGINT         IDENTITY (1, 1) NOT NULL,
    [URN]           NVARCHAR (512) NOT NULL,
    [Description]   NVARCHAR (50)  NOT NULL,
    [ContentTypeID] BIGINT         NOT NULL,
    CONSTRAINT [PK_AttributeType] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [Vocabulary].[AttributeType].[IX_AttributeType_URN]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [IX_AttributeType_URN]
    ON [Vocabulary].[AttributeType]([URN] ASC);


GO
PRINT N'Creating [Callback].[DF_Subscription_Active]...';


GO
ALTER TABLE [Callback].[Subscription]
    ADD CONSTRAINT [DF_Subscription_Active] DEFAULT ((1)) FOR [Active];


GO
PRINT N'Creating unnamed constraint on [Callback].[Schedule]...';


GO
ALTER TABLE [Callback].[Schedule]
    ADD DEFAULT (getdate()) FOR [NextRun];


GO
PRINT N'Creating [Event].[DF_EPCISEvent_EPC_IsInput]...';


GO
ALTER TABLE [Event].[EPCISEvent_EPC]
    ADD CONSTRAINT [DF_EPCISEvent_EPC_IsInput] DEFAULT ((0)) FOR [IsInput];


GO
PRINT N'Creating [Event].[DF_EPCISEvent_EPC_IsOutput]...';


GO
ALTER TABLE [Event].[EPCISEvent_EPC]
    ADD CONSTRAINT [DF_EPCISEvent_EPC_IsOutput] DEFAULT ((0)) FOR [IsOutput];


GO
PRINT N'Creating [Event].[DF_EPCISEvent_Error]...';


GO
ALTER TABLE [Event].[EPCISEvent]
    ADD CONSTRAINT [DF_EPCISEvent_Error] DEFAULT ((0)) FOR [Error];


GO
PRINT N'Creating [Import].[DF_Error_TimeStampGeneration]...';


GO
ALTER TABLE [Import].[Error]
    ADD CONSTRAINT [DF_Error_TimeStampGeneration] DEFAULT (getdate()) FOR [TimeStampGeneration];


GO
PRINT N'Creating [Import].[DF_Error_AdditionalInformation]...';


GO
ALTER TABLE [Import].[Error]
    ADD CONSTRAINT [DF_Error_AdditionalInformation] DEFAULT ('no Information') FOR [AdditionalInformation];


GO
PRINT N'Creating [Import].[DF_Error_ErrorNumber]...';


GO
ALTER TABLE [Import].[Error]
    ADD CONSTRAINT [DF_Error_ErrorNumber] DEFAULT ((0)) FOR [ErrorNumber];


GO
PRINT N'Creating [Import].[DF_Error_ErrorSeverity]...';


GO
ALTER TABLE [Import].[Error]
    ADD CONSTRAINT [DF_Error_ErrorSeverity] DEFAULT ((0)) FOR [ErrorSeverity];


GO
PRINT N'Creating [Import].[DF_Error_ErrorProcedure]...';


GO
ALTER TABLE [Import].[Error]
    ADD CONSTRAINT [DF_Error_ErrorProcedure] DEFAULT ('') FOR [ErrorProcedure];


GO
PRINT N'Creating [Import].[DF_Error_ErrorMessage]...';


GO
ALTER TABLE [Import].[Error]
    ADD CONSTRAINT [DF_Error_ErrorMessage] DEFAULT ('') FOR [ErrorMessage];


GO
PRINT N'Creating [Import].[DF_Error_ErrorLine]...';


GO
ALTER TABLE [Import].[Error]
    ADD CONSTRAINT [DF_Error_ErrorLine] DEFAULT ((0)) FOR [ErrorLine];


GO
PRINT N'Creating [Import].[DF_Error_ErrorState]...';


GO
ALTER TABLE [Import].[Error]
    ADD CONSTRAINT [DF_Error_ErrorState] DEFAULT ((0)) FOR [ErrorState];


GO
PRINT N'Creating unnamed constraint on [Import].[Error]...';


GO
ALTER TABLE [Import].[Error]
    ADD DEFAULT ((0)) FOR [ObjectID];


GO
PRINT N'Creating [Import].[DF_EPCISMasterData_Queue_Processed]...';


GO
ALTER TABLE [Import].[EPCISMasterData_Queue]
    ADD CONSTRAINT [DF_EPCISMasterData_Queue_Processed] DEFAULT ((0)) FOR [Processed];


GO
PRINT N'Creating [Import].[DF_EPCISMasterData_Queue_Error]...';


GO
ALTER TABLE [Import].[EPCISMasterData_Queue]
    ADD CONSTRAINT [DF_EPCISMasterData_Queue_Error] DEFAULT ((0)) FOR [Error];


GO
PRINT N'Creating [Import].[DF_EPCISEvent_Queue_Processed]...';


GO
ALTER TABLE [Import].[EPCISEvent_Queue]
    ADD CONSTRAINT [DF_EPCISEvent_Queue_Processed] DEFAULT ((0)) FOR [Processed];


GO
PRINT N'Creating [Import].[DF_EPCISEvent_Queue_Error]...';


GO
ALTER TABLE [Import].[EPCISEvent_Queue]
    ADD CONSTRAINT [DF_EPCISEvent_Queue_Error] DEFAULT ((0)) FOR [Error];


GO
PRINT N'Creating [Vocabulary].[DF_VocabularyType_Client_DELETED]...';


GO
ALTER TABLE [Vocabulary].[VocabularyType_Client]
    ADD CONSTRAINT [DF_VocabularyType_Client_DELETED] DEFAULT ((0)) FOR [Deleted];


GO
PRINT N'Creating [Vocabulary].[DF_VocabularyChildren_DELETED]...';


GO
ALTER TABLE [Vocabulary].[VocabularyChildren]
    ADD CONSTRAINT [DF_VocabularyChildren_DELETED] DEFAULT ((0)) FOR [Deleted];


GO
PRINT N'Creating [Vocabulary].[DF_VocabularyAttribute_DELETED]...';


GO
ALTER TABLE [Vocabulary].[VocabularyAttribute]
    ADD CONSTRAINT [DF_VocabularyAttribute_DELETED] DEFAULT ((0)) FOR [Deleted];


GO
PRINT N'Creating [Vocabulary].[DF_Vocabulary_DELETED]...';


GO
ALTER TABLE [Vocabulary].[Vocabulary]
    ADD CONSTRAINT [DF_Vocabulary_DELETED] DEFAULT ((0)) FOR [Deleted];


GO
PRINT N'Creating [Analysis].[FK_Vocabulary_Analysis_Settings_ClientID]...';


GO
ALTER TABLE [Analysis].[Settings]
    ADD CONSTRAINT [FK_Vocabulary_Analysis_Settings_ClientID] FOREIGN KEY ([ClientID]) REFERENCES [Vocabulary].[Vocabulary] ([ID]);


GO
PRINT N'Creating [Callback].[FK_Subscription_Trigger_ToSubscription]...';


GO
ALTER TABLE [Callback].[Subscription_Trigger]
    ADD CONSTRAINT [FK_Subscription_Trigger_ToSubscription] FOREIGN KEY ([SubscriptionID]) REFERENCES [Callback].[Subscription] ([ID]) ON DELETE CASCADE;


GO
PRINT N'Creating [Callback].[FK_Subscription_Trigger_ToTrigger]...';


GO
ALTER TABLE [Callback].[Subscription_Trigger]
    ADD CONSTRAINT [FK_Subscription_Trigger_ToTrigger] FOREIGN KEY ([TriggerID]) REFERENCES [Callback].[Trigger] ([ID]);


GO
PRINT N'Creating [Callback].[FK_Subscription_Vocabulary]...';


GO
ALTER TABLE [Callback].[Subscription]
    ADD CONSTRAINT [FK_Subscription_Vocabulary] FOREIGN KEY ([ClientID]) REFERENCES [Vocabulary].[Vocabulary] ([ID]);


GO
PRINT N'Creating [Callback].[FK_Schedule_Part_ToSchedule]...';


GO
ALTER TABLE [Callback].[Schedule_Part]
    ADD CONSTRAINT [FK_Schedule_Part_ToSchedule] FOREIGN KEY ([ScheduleID]) REFERENCES [Callback].[Schedule] ([ID]) ON DELETE CASCADE;


GO
PRINT N'Creating [Callback].[FK_Schedule_ToSubscription]...';


GO
ALTER TABLE [Callback].[Schedule]
    ADD CONSTRAINT [FK_Schedule_ToSubscription] FOREIGN KEY ([SubscriptionID]) REFERENCES [Callback].[Subscription] ([ID]) ON DELETE CASCADE;


GO
PRINT N'Creating [Event].[FK_EPCISEvent_EPCISEvent_QuantityElement]...';


GO
ALTER TABLE [Event].[EPCISEvent_QuantityElement]
    ADD CONSTRAINT [FK_EPCISEvent_EPCISEvent_QuantityElement] FOREIGN KEY ([EPCISEventID]) REFERENCES [Event].[EPCISEvent] ([ID]) ON DELETE CASCADE;


GO
PRINT N'Creating [Event].[FK_QuantityElement_EPCISEvent_QuantityElement]...';


GO
ALTER TABLE [Event].[EPCISEvent_QuantityElement]
    ADD CONSTRAINT [FK_QuantityElement_EPCISEvent_QuantityElement] FOREIGN KEY ([QuantityElementID]) REFERENCES [Event].[QuantityElement] ([ID]);


GO
PRINT N'Creating [Event].[FK_EPCISEvent_EPC_EPC]...';


GO
ALTER TABLE [Event].[EPCISEvent_EPC]
    ADD CONSTRAINT [FK_EPCISEvent_EPC_EPC] FOREIGN KEY ([EPCID]) REFERENCES [Event].[EPC] ([ID]);


GO
ALTER TABLE [Event].[EPCISEvent_EPC] NOCHECK CONSTRAINT [FK_EPCISEvent_EPC_EPC];


GO
PRINT N'Creating [Event].[FK_EPCISEvent_EPCISEvent_EPC]...';


GO
ALTER TABLE [Event].[EPCISEvent_EPC]
    ADD CONSTRAINT [FK_EPCISEvent_EPCISEvent_EPC] FOREIGN KEY ([EPCISEventID]) REFERENCES [Event].[EPCISEvent] ([ID]) ON DELETE CASCADE;


GO
PRINT N'Creating [Event].[FK_BusinessTransactionID_EPCISEvent_BusinessTransactionID]...';


GO
ALTER TABLE [Event].[EPCISEvent_BusinessTransactionID]
    ADD CONSTRAINT [FK_BusinessTransactionID_EPCISEvent_BusinessTransactionID] FOREIGN KEY ([BusinessTransactionIDID]) REFERENCES [Event].[BusinessTransactionID] ([ID]);


GO
PRINT N'Creating [Event].[FK_EPCISEvent_EPCISEvent_BusinessTransactionID]...';


GO
ALTER TABLE [Event].[EPCISEvent_BusinessTransactionID]
    ADD CONSTRAINT [FK_EPCISEvent_EPCISEvent_BusinessTransactionID] FOREIGN KEY ([EPCISEventID]) REFERENCES [Event].[EPCISEvent] ([ID]) ON DELETE CASCADE;


GO
PRINT N'Creating [Event].[FK_Vocabulary_EPCISEvent]...';


GO
ALTER TABLE [Event].[EPCISEvent]
    ADD CONSTRAINT [FK_Vocabulary_EPCISEvent] FOREIGN KEY ([ClientID]) REFERENCES [Vocabulary].[Vocabulary] ([ID]);


GO
PRINT N'Creating [Event].[FK_Vocabulary_BusinessTransactionID]...';


GO
ALTER TABLE [Event].[BusinessTransactionID]
    ADD CONSTRAINT [FK_Vocabulary_BusinessTransactionID] FOREIGN KEY ([BusinessTransactionTypeID]) REFERENCES [Vocabulary].[Vocabulary] ([ID]);


GO
PRINT N'Creating [Event].[FK_VocabularyElement_QuantityElement]...';


GO
ALTER TABLE [Event].[QuantityElement]
    ADD CONSTRAINT [FK_VocabularyElement_QuantityElement] FOREIGN KEY ([EPCClassID]) REFERENCES [Vocabulary].[Vocabulary] ([ID]) ON DELETE CASCADE;


GO
PRINT N'Creating [Event].[FK_EPCISEvent_EPCISEvent_Vocabulary]...';


GO
ALTER TABLE [Event].[EPCISEvent_Vocabulary]
    ADD CONSTRAINT [FK_EPCISEvent_EPCISEvent_Vocabulary] FOREIGN KEY ([EPCISEventID]) REFERENCES [Event].[EPCISEvent] ([ID]) ON DELETE CASCADE;


GO
PRINT N'Creating [Event].[FK_Vocabulary_EPCISEvent_Vocabulary]...';


GO
ALTER TABLE [Event].[EPCISEvent_Vocabulary]
    ADD CONSTRAINT [FK_Vocabulary_EPCISEvent_Vocabulary] FOREIGN KEY ([VocabularyID]) REFERENCES [Vocabulary].[Vocabulary] ([ID]);


GO
PRINT N'Creating [Event].[FK_EPCISEvent_Value_Numeric_EPCISEvent_Value]...';


GO
ALTER TABLE [Event].[EPCISEvent_Value_Numeric]
    ADD CONSTRAINT [FK_EPCISEvent_Value_Numeric_EPCISEvent_Value] FOREIGN KEY ([EPCISEvent_ValueID]) REFERENCES [Event].[EPCISEvent_Value] ([ID]) ON DELETE CASCADE;


GO
PRINT N'Creating [Event].[FK_EPCISEvent_Value_Datetime_EPCISEvent_Value]...';


GO
ALTER TABLE [Event].[EPCISEvent_Value_Datetime]
    ADD CONSTRAINT [FK_EPCISEvent_Value_Datetime_EPCISEvent_Value] FOREIGN KEY ([EPCISEvent_ValueID]) REFERENCES [Event].[EPCISEvent_Value] ([ID]) ON DELETE CASCADE;


GO
PRINT N'Creating [Event].[FK_EPCISEvent_EPCISEvent_Value_EPCISEvent_ID]...';


GO
ALTER TABLE [Event].[EPCISEvent_Value]
    ADD CONSTRAINT [FK_EPCISEvent_EPCISEvent_Value_EPCISEvent_ID] FOREIGN KEY ([EPCISEventID]) REFERENCES [Event].[EPCISEvent] ([ID]) ON DELETE CASCADE;


GO
PRINT N'Creating [Event].[FK_Vocabulary_EPCISEvent_Value_DataType]...';


GO
ALTER TABLE [Event].[EPCISEvent_Value]
    ADD CONSTRAINT [FK_Vocabulary_EPCISEvent_Value_DataType] FOREIGN KEY ([DataTypeID]) REFERENCES [Vocabulary].[Vocabulary] ([ID]);


GO
PRINT N'Creating [Event].[FK_Vocabulary_EPCISEvent_Value_ValueType]...';


GO
ALTER TABLE [Event].[EPCISEvent_Value]
    ADD CONSTRAINT [FK_Vocabulary_EPCISEvent_Value_ValueType] FOREIGN KEY ([ValueTypeID]) REFERENCES [Vocabulary].[Vocabulary] ([ID]);


GO
PRINT N'Creating [Event].[FK_Event_EPCISEvent_TransformationID]...';


GO
ALTER TABLE [Event].[EPCISEvent_TransformationID]
    ADD CONSTRAINT [FK_Event_EPCISEvent_TransformationID] FOREIGN KEY ([EPCISEventID]) REFERENCES [Event].[EPCISEvent] ([ID]) ON DELETE CASCADE;


GO
PRINT N'Creating [Event].[FK_TransformationID_EPCISEvent_TransformationID]...';


GO
ALTER TABLE [Event].[EPCISEvent_TransformationID]
    ADD CONSTRAINT [FK_TransformationID_EPCISEvent_TransformationID] FOREIGN KEY ([TransformationIDID]) REFERENCES [Event].[TransformationID] ([ID]);


GO
PRINT N'Creating [Event].[FK_EPCISEvent_EPCISEvent_SourceDestination]...';


GO
ALTER TABLE [Event].[EPCISEvent_SourceDestination]
    ADD CONSTRAINT [FK_EPCISEvent_EPCISEvent_SourceDestination] FOREIGN KEY ([EPCISEventID]) REFERENCES [Event].[EPCISEvent] ([ID]) ON DELETE CASCADE;


GO
PRINT N'Creating [Event].[FK_SourceDestinationID_EPCISEvent_SourceDestination]...';


GO
ALTER TABLE [Event].[EPCISEvent_SourceDestination]
    ADD CONSTRAINT [FK_SourceDestinationID_EPCISEvent_SourceDestination] FOREIGN KEY ([SourceDestinationID]) REFERENCES [Vocabulary].[Vocabulary] ([ID]);


GO
PRINT N'Creating [Event].[FK_SourceDestinationTypeID_EPCISEvent_SourceDestination]...';


GO
ALTER TABLE [Event].[EPCISEvent_SourceDestination]
    ADD CONSTRAINT [FK_SourceDestinationTypeID_EPCISEvent_SourceDestination] FOREIGN KEY ([SourceDestinationTypeID]) REFERENCES [Vocabulary].[Vocabulary] ([ID]);


GO
PRINT N'Creating [Event].[FK_EPCISDocumentHeader_EPCISEvent_DocumentHeader]...';


GO
ALTER TABLE [Event].[EPCISEvent_DocumentHeader]
    ADD CONSTRAINT [FK_EPCISDocumentHeader_EPCISEvent_DocumentHeader] FOREIGN KEY ([DocumentHeaderID]) REFERENCES [DocumentHeader].[EPCISDocumentHeader] ([ID]) ON DELETE CASCADE;


GO
PRINT N'Creating [Event].[FK_EPCISEvent_EPCISEvent_DocumentHeader]...';


GO
ALTER TABLE [Event].[EPCISEvent_DocumentHeader]
    ADD CONSTRAINT [FK_EPCISEvent_EPCISEvent_DocumentHeader] FOREIGN KEY ([EPCISEventID]) REFERENCES [Event].[EPCISEvent] ([ID]) ON DELETE CASCADE;


GO
PRINT N'Creating [Event].[FK_EPCISEvent_Value_Hierarchy_EPCISEvent_Value]...';


GO
ALTER TABLE [Event].[EPCISEvent_Value_Hierarchy]
    ADD CONSTRAINT [FK_EPCISEvent_Value_Hierarchy_EPCISEvent_Value] FOREIGN KEY ([EPCISEvent_ValueID]) REFERENCES [Event].[EPCISEvent_Value] ([ID]) ON DELETE CASCADE;


GO
PRINT N'Creating [Event].[FK_EPCISEvent_Value_Hierarchy_Parent_EPCISEvent_Value]...';


GO
ALTER TABLE [Event].[EPCISEvent_Value_Hierarchy]
    ADD CONSTRAINT [FK_EPCISEvent_Value_Hierarchy_Parent_EPCISEvent_Value] FOREIGN KEY ([Parent_EPCISEvent_ValueID]) REFERENCES [Event].[EPCISEvent_Value] ([ID]);


GO
PRINT N'Creating [Event].[FK_EPCISEvent_Value_String_EPCISEvent_Value]...';


GO
ALTER TABLE [Event].[EPCISEvent_Value_String]
    ADD CONSTRAINT [FK_EPCISEvent_Value_String_EPCISEvent_Value] FOREIGN KEY ([EPCISEvent_ValueID]) REFERENCES [Event].[EPCISEvent_Value] ([ID]) ON DELETE CASCADE;


GO
PRINT N'Creating [Event].[FK_EPCISEvent_Value_String_String_Value]...';


GO
ALTER TABLE [Event].[EPCISEvent_Value_String]
    ADD CONSTRAINT [FK_EPCISEvent_Value_String_String_Value] FOREIGN KEY ([Value_StringID]) REFERENCES [Event].[Value_String] ([ID]);


GO
PRINT N'Creating [Vocabulary].[FK_VocabularyType_Client_Vocabulary]...';


GO
ALTER TABLE [Vocabulary].[VocabularyType_Client]
    ADD CONSTRAINT [FK_VocabularyType_Client_Vocabulary] FOREIGN KEY ([ClientID]) REFERENCES [Vocabulary].[Vocabulary] ([ID]);


GO
PRINT N'Creating [Vocabulary].[FK_VocabularyType_Client_VocabularyClient]...';


GO
ALTER TABLE [Vocabulary].[VocabularyType_Client]
    ADD CONSTRAINT [FK_VocabularyType_Client_VocabularyClient] FOREIGN KEY ([VocabularyTypeID]) REFERENCES [Vocabulary].[VocabularyType] ([ID]);


GO
PRINT N'Creating [Vocabulary].[FK_Vocabulary_VocabularyChildren]...';


GO
ALTER TABLE [Vocabulary].[VocabularyChildren]
    ADD CONSTRAINT [FK_Vocabulary_VocabularyChildren] FOREIGN KEY ([VocabularyID]) REFERENCES [Vocabulary].[Vocabulary] ([ID]);


GO
PRINT N'Creating [Vocabulary].[FK_Vocabulary_VocabularyChildren_Child]...';


GO
ALTER TABLE [Vocabulary].[VocabularyChildren]
    ADD CONSTRAINT [FK_Vocabulary_VocabularyChildren_Child] FOREIGN KEY ([ChildVocabularyID]) REFERENCES [Vocabulary].[Vocabulary] ([ID]);


GO
PRINT N'Creating [Vocabulary].[FK_AttributeType_VocabularyAttribute]...';


GO
ALTER TABLE [Vocabulary].[VocabularyAttribute]
    ADD CONSTRAINT [FK_AttributeType_VocabularyAttribute] FOREIGN KEY ([AttributeTypeID]) REFERENCES [Vocabulary].[AttributeType] ([ID]);


GO
PRINT N'Creating [Vocabulary].[FK_Vocabulary_VocabularyAttribute]...';


GO
ALTER TABLE [Vocabulary].[VocabularyAttribute]
    ADD CONSTRAINT [FK_Vocabulary_VocabularyAttribute] FOREIGN KEY ([VocabularyID]) REFERENCES [Vocabulary].[Vocabulary] ([ID]);


GO
PRINT N'Creating [Vocabulary].[FK_Vocabulary_Vocabulary]...';


GO
ALTER TABLE [Vocabulary].[Vocabulary]
    ADD CONSTRAINT [FK_Vocabulary_Vocabulary] FOREIGN KEY ([ClientID]) REFERENCES [Vocabulary].[Vocabulary] ([ID]);


GO
PRINT N'Creating [Vocabulary].[FK_VocabularyType_Vocabulary]...';


GO
ALTER TABLE [Vocabulary].[Vocabulary]
    ADD CONSTRAINT [FK_VocabularyType_Vocabulary] FOREIGN KEY ([VocabularyTypeID]) REFERENCES [Vocabulary].[VocabularyType] ([ID]);


GO
PRINT N'Creating [Vocabulary].[FK_ContentType_Vocabulary]...';


GO
ALTER TABLE [Vocabulary].[AttributeType]
    ADD CONSTRAINT [FK_ContentType_Vocabulary] FOREIGN KEY ([ContentTypeID]) REFERENCES [Vocabulary].[Vocabulary] ([ID]);


GO
PRINT N'Creating [Event].[Delete_EPC_For_EPCISEvent_EPC]...';


GO
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE TRIGGER [Event].[Delete_EPC_For_EPCISEvent_EPC] 
   ON  [Event].[EPCISEvent_EPC] 
   AFTER DELETE
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for trigger here
	declare @rc int
	DELETE Event.EPC
	FROM Event.EPC epc
	INNER JOIN deleted d
		ON epc.ID = d.EPCID

	set @rc = @@ROWCOUNT

	IF OBJECT_ID('tempdb..#DebugInfo', 'U') IS NOT NULL
	BEGIN
		INSERT INTO #DebugInfo
		VALUES (
			'Delete EPC'
			,cast(@rc AS VARCHAR)
			)
	END
END
GO
PRINT N'Creating [Import].[Tr_EPCISMasterData_Queue]...';


GO

CREATE TRIGGER [Import].[Tr_EPCISMasterData_Queue]
ON [Import].[EPCISMasterData_Queue]
FOR INSERT
AS
BEGIN
    SET NoCount ON;

	UPDATE u
		SET u.[EPCISMasterDataOriginal] = u.[EPCISMasterData]
	FROM [Import].[EPCISMasterData_Queue] u
	JOIN inserted i on i.ID = u.ID;

END
GO
PRINT N'Creating [Import].[Tr_EPCISEvent_Queue]...';


GO

CREATE TRIGGER [Import].[Tr_EPCISEvent_Queue]
ON [Import].[EPCISEvent_Queue]
FOR INSERT
AS
BEGIN
	SET NoCount ON;

	UPDATE u
	SET u.[EPCISEventOriginal] = u.[EPCISEvent]
	FROM [Import].[EPCISEvent_Queue] u
	JOIN inserted i on i.ID = u.ID;

END
GO
PRINT N'Creating [Analysis].[EPCISVocabulary]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2014  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 30.07.2014 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE VIEW [Analysis].[EPCISVocabulary]
WITH SCHEMABINDING
AS 
SELECT 
	v.[ID], 
	v.[URN] as Vocabulary,
	--Mandantenkennung
	c.[URN] as [Client]
FROM [Vocabulary].[VocabularyType] v
-- Mandantenkennung
JOIN [Vocabulary].[VocabularyType_Client] vtc on vtc.VocabularyTypeID = v.ID
JOIN [Vocabulary].[Vocabulary] c on c.ID = vtc.ClientID
WHERE vtc.Deleted = 0
GO
PRINT N'Creating [Analysis].[EPCISValueType]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2014  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 06.08.2014 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE VIEW [Analysis].[EPCISValueType]
WITH SCHEMABINDING
AS
SELECT
	v.[ID],
	v.[URN]  as ValueType,
	vt.[URN] as ValueClass,
	--Mandantenkennung
	c.[URN]  as [Client]
FROM [Event].[EPCISEvent_Value] ev
JOIN [Event].[EPCISEvent]				 e on e.ID = ev.EPCISEventID
JOIN [Vocabulary].[Vocabulary] v on v.ID = ev.ValueTypeID
JOIN [Vocabulary].[VocabularyType] vt on vt.ID = v.VocabularyTypeID
-- Mandantenkennung
JOIN [Vocabulary].[Vocabulary] c on c.ID = e.ClientID
WHERE vt.URN in (N'urn:quibiq:epcis:vtype:extensiontype', N'urn:quibiq:epcis:vtype:ilmd', N'urn:quibiq:epcis:vtype:valuetype')
and v.Deleted = 0 
GROUP BY v.[ID], v.[URN], vt.[URN], c.[URN]
UNION ALL
SELECT 
	-2147483648 as [ID], 
	'Leer' as ValueType,
	'Leer' as ValueClass,
	--Mandantenkennung
	N'urn:quibiq:epcis:cbv:client:epcisrepository' as [Client]
GO
PRINT N'Creating [Analysis].[EPCISTransformation]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2015  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 30.01.2015 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE VIEW [Analysis].[EPCISTransformation]
WITH SCHEMABINDING
AS
SELECT 
	eeti.TransformationIDID as [ID],
	tid.[URN] as [TransformationID],
	--Mandantenkennung
	c.[URN] as [Client]
FROM [Event].[EPCISEvent_TransformationID] eeti
JOIN [Event].[TransformationID]		        tid on tid.[ID] = eeti.TransformationIDID
JOIN [Event].[EPCISEvent]				      e on e.ID = eeti.EPCISEventID
-- Mandantenkennung
JOIN [Vocabulary].[Vocabulary] c on c.ID = e.ClientID
GROUP BY eeti.TransformationIDID, tid.URN, c.URN
UNION ALL
SELECT 
	-2147483648 as [ID], 
	'Leer' as [TransformationID],
	--Mandantenkennung
	N'urn:quibiq:epcis:cbv:client:epcisrepository' as [Client]
GO
PRINT N'Creating [Analysis].[EPCISQuantityElement]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2015  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 30.01.2015 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE VIEW [Analysis].[EPCISQuantityElement]
WITH SCHEMABINDING
AS
SELECT 
	eeqe.QuantityElementID as [ID],
	ec.URN as [EPCClass],
	qe.Quantity,
	qe.UOM,
	--Mandantenkennung
	c.[URN] as [Client]
FROM [Event].[EPCISEvent_QuantityElement] eeqe
JOIN [Event].[QuantityElement]		        qe on qe.[ID] = eeqe.QuantityElementID
JOIN [Event].[EPCISEvent]				     e on e.ID = eeqe.EPCISEventID
-- EPCClass
JOIN [Vocabulary].[Vocabulary] ec on ec.ID = qe.EPCClassID
-- Mandantenkennung
JOIN [Vocabulary].[Vocabulary] c on c.ID = e.ClientID
GROUP BY eeqe.QuantityElementID, qe.Quantity, qe.UOM, c.URN, ec.URN
UNION ALL
SELECT 
	-2147483648 as [ID], 
	'Leer' as [EPCClass],
	0 as Quantity,
	'Leer' as UOM,
	--Mandantenkennung
	N'urn:quibiq:epcis:cbv:client:epcisrepository' as [Client]
GO
PRINT N'Creating [Analysis].[EPCISEvent_Vocabulary]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2014  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 30.07.2014 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE VIEW [Analysis].[EPCISEvent_Vocabulary]
WITH SCHEMABINDING
AS 
SELECT 
	[EPCISEventID], 
	[VocabularyID],
	v.[URN]  as [VocabularyElement],
	vt.[URN] as [Vocabulary],
	--Mandantenkennung
	c.[URN] as [Client]
FROM [Event].[EPCISEvent_Vocabulary] ev
JOIN [Event].[EPCISEvent] e on e.ID = ev.EPCISEventID
JOIN [Vocabulary].[Vocabulary] v on v.ID = ev.VocabularyID
JOIN [Vocabulary].[VocabularyType] vt on vt.ID = v.VocabularyTypeID
-- Mandantenkennung
JOIN [Vocabulary].[Vocabulary] c on c.ID = e.ClientID
GO
PRINT N'Creating [Analysis].[EPCISEvent_Value]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2014  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 04.08.2014 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE VIEW [Analysis].[EPCISEvent_Value]
WITH SCHEMABINDING
AS
SELECT
	ev.[EPCISEventID],
	ev.ValueTypeID,
	ISNULL(s.Value, 'Leer') as [Value],
	--Mandantenkennung
	c.URN as [Client]
FROM [Event].[EPCISEvent_Value] ev
LEFT JOIN [Event].[EPCISEvent_Value_String] evs on evs.EPCISEvent_ValueID = ev.ID
LEFT JOIN [Event].[Value_String]		      s on s.ID = evs.Value_StringID
JOIN [Event].[EPCISEvent]				      e on e.ID = ev.EPCISEventID
-- Mandantenkennung
JOIN [Vocabulary].[Vocabulary] c on c.ID = e.ClientID
UNION ALL
SELECT 
	e.[ID] as [EPCISEventID],
	-2147483648 as [ValueTypeID], 
	'Leer' as [Value],
	--Mandantenkennung
	c.[URN] as [Client]
FROM [Event].[EPCISEvent] e
-- Mandantenkennung
JOIN [Vocabulary].[Vocabulary] c on c.ID = e.ClientID
WHERE not exists (select top 1 1 from 
							[Event].[EPCISEvent_Value] ev
							JOIN [Vocabulary].[Vocabulary] v on v.ID = ev.ValueTypeID
							JOIN [Vocabulary].[VocabularyType] vt on vt.ID = v.VocabularyTypeID
							where vt.URN in (N'urn:quibiq:epcis:vtype:extensiontype', N'urn:quibiq:epcis:vtype:ilmd', N'urn:quibiq:epcis:vtype:valuetype') 
							  and ev.EPCISEventID = e.ID)
GO
PRINT N'Creating [Analysis].[EPCISEvent_Transformation]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2015  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 30.01.2015 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE VIEW [Analysis].[EPCISEvent_Transformation]
WITH SCHEMABINDING
AS 
SELECT 
	eeti.[EPCISEventID],
	eeti.TransformationIDID,
	--Mandantenkennung
	c.URN as [Client]
FROM [Event].[EPCISEvent_TransformationID] eeti
JOIN [Event].[EPCISEvent]				   e on e.ID = eeti.EPCISEventID
-- Mandantenkennung
JOIN [Vocabulary].[Vocabulary] c on c.ID = e.ClientID
UNION ALL
SELECT 
	e.ID as [EPCISEventID],
	-2147483648 as TransformationIDID, 
	--Mandantenkennung
	c.[URN] as [Client]
FROM [Event].[EPCISEvent] e
-- Mandantenkennung
JOIN [Vocabulary].[Vocabulary] c on c.ID = e.ClientID
WHERE not exists (select top 1 1 from [Event].[EPCISEvent_TransformationID] where EPCISEventID = e.ID)
GO
PRINT N'Creating [Analysis].[EPCISEvent_SourceDestination]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2015  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 30.01.2015 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE VIEW [Analysis].[EPCISEvent_SourceDestination]
WITH SCHEMABINDING
AS
SELECT 
--	eesd.[ID],
	eesd.[EPCISEventID],
	eesd.[IsSource],
	sd.URN as [SourceDestination],
	sdt.URN as [SourceDestinationType],
	--Mandantenkennung
	c.[URN] as [Client]
FROM [Event].[EPCISEvent_SourceDestination] eesd
JOIN [Event].[EPCISEvent] e on e.ID = eesd.EPCISEventID
-- SourceDestination
JOIN [Vocabulary].[Vocabulary] sd  on sd.ID = eesd.SourceDestinationID
JOIN [Vocabulary].[Vocabulary] sdt on sdt.ID = eesd.SourceDestinationTypeID
-- Mandantenkennung
JOIN [Vocabulary].[Vocabulary] c on c.ID = e.ClientID
UNION ALL
SELECT 
	e.[ID] as [EPCISEventID], 
	0 as [IsSource], 
	N'Leer' as [SourceDestination],
	N'Leer' as [SourceDestinationType],
	--Mandantenkennung
	c.[URN] as [Client]
FROM [Event].[EPCISEvent] e
-- Mandantenkennung
JOIN [Vocabulary].[Vocabulary] c on c.ID = e.ClientID
WHERE not exists (select top 1 1 from [Event].[EPCISEvent_SourceDestination] where EPCISEventID = e.ID)
GO
PRINT N'Creating [Analysis].[EPCISEvent_ReadPoint]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2014  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 30.07.2014 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE VIEW [Analysis].[EPCISEvent_ReadPoint]
WITH SCHEMABINDING
AS
SELECT 
	v.[EPCISEventID], 
	v.[VocabularyID],
	v.[VocabularyElement] as ReadPoint,
	--Geographie
	longitude.Value.value(N'/Value[1]', N'float') as longitude, 
	latitude.Value.value(N'/Value[1]', N'float') as latitude, 
	--Mandantenkennung
	v.[Client]
FROM [Analysis].[EPCISEvent_Vocabulary] v
--Geographie
outer apply (
select va.Value from
 Vocabulary.VocabularyAttribute va 
join Vocabulary.AttributeType at on at.ID = va.AttributeTypeID
where va.VocabularyID = v.[VocabularyID] and at.URN = N'urn:epcglobal:fmcg:mda:longitude'
) as longitude
outer apply (
select va.Value from
 Vocabulary.VocabularyAttribute va 
join Vocabulary.AttributeType at on at.ID = va.AttributeTypeID
where va.VocabularyID = v.[VocabularyID] and at.URN = N'urn:epcglobal:fmcg:mda:latitude'
) as latitude
-- Filter
WHERE [Vocabulary] = N'urn:epcglobal:epcis:vtype:ReadPoint'
GO
PRINT N'Creating [Analysis].[EPCISEvent_QuantityElement]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2015  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 30.01.2015 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE VIEW [Analysis].[EPCISEvent_QuantityElement]
WITH SCHEMABINDING
AS 
SELECT 
	eeqe.[EPCISEventID],
	eeqe.QuantityElementID,
	eeqe.IsInput,
	eeqe.IsOutput,
	--Mandantenkennung
	c.URN as [Client]
FROM [Event].[EPCISEvent_QuantityElement] eeqe
JOIN [Event].[EPCISEvent]				   e on e.ID = eeqe.EPCISEventID
-- Mandantenkennung
JOIN [Vocabulary].[Vocabulary] c on c.ID = e.ClientID
UNION ALL
SELECT 
	e.ID as [EPCISEventID],
	-2147483648 as QuantityElementID, 
	0 as [IsInput],
	0 as [IsOutput],
	--Mandantenkennung
	c.[URN] as [Client]
FROM [Event].[EPCISEvent] e
-- Mandantenkennung
JOIN [Vocabulary].[Vocabulary] c on c.ID = e.ClientID
WHERE not exists (select top 1 1 from [Event].[EPCISEvent_QuantityElement] where EPCISEventID = e.ID)
GO
PRINT N'Creating [Analysis].[EPCISEvent_EventType]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2014  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 30.07.2014 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE VIEW [Analysis].[EPCISEvent_EventType]
WITH SCHEMABINDING
AS
SELECT 
	[EPCISEventID], 
	[VocabularyID],
	[VocabularyElement] as EventType,
	--Mandantenkennung
	[Client]
FROM [Analysis].[EPCISEvent_Vocabulary]
-- Filter
WHERE [Vocabulary] = N'urn:quibiq:epcis:vtype:event'
GO
PRINT N'Creating [Analysis].[EPCISEvent_EPC]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2014  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 30.07.2014 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
-- 30.01.2015 | 1.0.1.0 | Florian Wagner      | FLW001 - Anpassungen EPCIS 1_1
-----------------------------------------------------------------------------------------
CREATE VIEW [Analysis].[EPCISEvent_EPC]
WITH SCHEMABINDING
AS
SELECT 
--	eepc.[ID],
	eepc.[EPCISEventID],
	eepc.[EPCID],
	eepc.[IsParentID],
	eepc.[IsInput],
	eepc.[IsOutput],
	--Mandantenkennung
	c.[URN] as [Client]
FROM [Event].[EPCISEvent_EPC] eepc
JOIN [Event].[EPCISEvent] e on e.ID = eepc.EPCISEventID
-- Mandantenkennung
JOIN [Vocabulary].[Vocabulary] c on c.ID = e.ClientID
UNION ALL
SELECT 
	e.[ID] as [EPCISEventID], 
	-2147483648 as [EPCID], 
	0 as [IsParentID],
	0 as [IsInput],
	0 as [IsOutput],
	--Mandantenkennung
	c.[URN] as [Client]
FROM [Event].[EPCISEvent] e
-- Mandantenkennung
JOIN [Vocabulary].[Vocabulary] c on c.ID = e.ClientID
WHERE not exists (select top 1 1 from [Event].[EPCISEvent_EPC] where EPCISEventID = e.ID)
GO
PRINT N'Creating [Analysis].[EPCISEvent_Disposition]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2014  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 30.07.2014 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE VIEW [Analysis].[EPCISEvent_Disposition]
WITH SCHEMABINDING
AS
SELECT 
	[EPCISEventID], 
	[VocabularyID],
	[VocabularyElement] as Disposition,
	--Mandantenkennung
	[Client]
FROM [Analysis].[EPCISEvent_Vocabulary]
-- Filter
WHERE [Vocabulary] = N'urn:epcglobal:epcis:vtype:Disposition'
GO
PRINT N'Creating [Analysis].[EPCISEvent_BusinessTransaction]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2014  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 04.08.2014 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE VIEW [Analysis].[EPCISEvent_BusinessTransaction]
WITH SCHEMABINDING
AS 
SELECT 
	eb.[EPCISEventID],
	eb.BusinessTransactionIDID,
	--Mandantenkennung
	c.URN as [Client]
FROM [Event].[EPCISEvent_BusinessTransactionID] eb
JOIN [Event].[EPCISEvent]						 e on e.ID = eb.EPCISEventID
-- Mandantenkennung
JOIN [Vocabulary].[Vocabulary] c on c.ID = e.ClientID
UNION ALL
SELECT 
	e.ID as [EPCISEventID],
	-2147483648 as BusinessTransactionIDID, 
	--Mandantenkennung
	c.[URN] as [Client]
FROM [Event].[EPCISEvent] e
-- Mandantenkennung
JOIN [Vocabulary].[Vocabulary] c on c.ID = e.ClientID
WHERE not exists (select top 1 1 from [Event].[EPCISEvent_BusinessTransactionID] where EPCISEventID = e.ID)
GO
PRINT N'Creating [Analysis].[EPCISEvent_BusinessStep]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2014  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 30.07.2014 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE VIEW [Analysis].[EPCISEvent_BusinessStep]
WITH SCHEMABINDING
AS
SELECT 
	[EPCISEventID], 
	[VocabularyID],
	[VocabularyElement] as BusinessStep,
	--Mandantenkennung
	[Client]
FROM [Analysis].[EPCISEvent_Vocabulary]
-- Filter
WHERE [Vocabulary] = N'urn:epcglobal:epcis:vtype:BusinessStep'
GO
PRINT N'Creating [Analysis].[EPCISEvent_BusinessLocation]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2014  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 30.07.2014 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE VIEW [Analysis].[EPCISEvent_BusinessLocation]
WITH SCHEMABINDING
AS 
SELECT 
	v.[EPCISEventID], 
	v.[VocabularyID],
	v.[VocabularyElement] as BusinessLocation,
	--Geographie
	longitude.Value.value(N'/Value[1]', N'float') as longitude, 
	latitude.Value.value(N'/Value[1]', N'float') as latitude, 
	--Mandantenkennung
	v.[Client]
FROM [Analysis].[EPCISEvent_Vocabulary] v
--Geographie
outer apply (
select va.Value from
 Vocabulary.VocabularyAttribute va 
join Vocabulary.AttributeType at on at.ID = va.AttributeTypeID
where va.VocabularyID = v.[VocabularyID] and at.URN = N'urn:epcglobal:fmcg:mda:longitude'
) as longitude
outer apply (
select va.Value from
 Vocabulary.VocabularyAttribute va 
join Vocabulary.AttributeType at on at.ID = va.AttributeTypeID
where va.VocabularyID = v.[VocabularyID] and at.URN = N'urn:epcglobal:fmcg:mda:latitude'
) as latitude
-- Filter
WHERE [Vocabulary] = N'urn:epcglobal:epcis:vtype:BusinessLocation'
GO
PRINT N'Creating [Analysis].[EPCISEvent_Action]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2014  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 30.07.2014 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE VIEW [Analysis].[EPCISEvent_Action]
WITH SCHEMABINDING
AS
SELECT 
	[EPCISEventID], 
	[VocabularyID],
	[VocabularyElement] as [Action],
	--Mandantenkennung
	[Client]
FROM [Analysis].[EPCISEvent_Vocabulary]
-- Filter
WHERE [Vocabulary] = N'urn:quibiq:epcis:vtype:action'
GO
PRINT N'Creating [Analysis].[EPCISEvent]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2014  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 30.07.2014 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE VIEW [Analysis].[EPCISEvent]
WITH SCHEMABINDING
AS 
SELECT 
	e.[ID], 
	[EventTime], 
	[RecordTime], 
	[XmlRepresentation],
	-- Zeitintervalle
	DATEPART(ms, SWITCHOFFSET([EventTimeZoneOffset], '+01:00'))	as [Millisecond],
	DATEPART(s,  SWITCHOFFSET([EventTimeZoneOffset], '+01:00'))	as [Second],
	DATEPART(mi, SWITCHOFFSET([EventTimeZoneOffset], '+01:00'))	as [Minute],
	DATEPART(hh, SWITCHOFFSET([EventTimeZoneOffset], '+01:00'))	as [Hour],
	-- EventDatum
	CAST(SWITCHOFFSET([EventTimeZoneOffset], '+01:00') as date) as [DateKeyEvent],
	-- RecordDatum
	CAST([RecordTime] as date)									as [DateKeyRecord],
	-- EventURL
	s.Value + CAST(e.[ID] as nvarchar(20))						as [EventURL],
	--Mandantenkennung
	c.[URN] as [Client]
FROM [Event].[EPCISEvent] e 
-- Mandantenkennung
JOIN [Vocabulary].[Vocabulary] c on c.ID = e.ClientID
CROSS APPLY [Analysis].[Settings] s
WHERE
	s.ClientID = e.ClientID and s.ID = N'GetEventURL'
GO
PRINT N'Creating [Analysis].[EPCISEPC]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2014  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 30.07.2014 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE VIEW [Analysis].[EPCISEPC]
WITH SCHEMABINDING
AS 
SELECT 
	epc.[ID], 
	epc.[URN] as EPC,
	--Mandantenkennung
	c.[URN] as [Client]
FROM [Event].[EPCISEvent_EPC] eepc
JOIN [Event].[EPC] epc on epc.ID = eepc.EPCID
JOIN [Event].[EPCISEvent] e on e.ID = eepc.EPCISEventID
-- Mandantenkennung
JOIN [Vocabulary].[Vocabulary] c on c.ID = e.ClientID
GROUP BY epc.[ID], epc.[URN], c.[URN]
UNION ALL
SELECT 
	-2147483648 as [ID], 
	'Leer' as EPC,
	--Mandantenkennung
	N'urn:quibiq:epcis:cbv:client:epcisrepository' as [Client]
GO
PRINT N'Creating [Analysis].[EPCISBusinessTransaction]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2014  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 06.08.2014 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE VIEW [Analysis].[EPCISBusinessTransaction]
WITH SCHEMABINDING
AS 
SELECT 
	bt.ID,
	bt.URN as [BusinessTransaction],
	v.URN as [BusinessTransactionType],
	--Mandantenkennung
	c.URN as [Client]
FROM [Event].[EPCISEvent_BusinessTransactionID] eb
JOIN [Event].[BusinessTransactionID]		    bt on bt.ID = eb.BusinessTransactionIDID
JOIN [Vocabulary].[Vocabulary]					 v on v.ID = bt.BusinessTransactionTypeID
JOIN [Event].[EPCISEvent]						 e on e.ID = eb.EPCISEventID
-- Mandantenkennung
JOIN [Vocabulary].[Vocabulary] c on c.ID = e.ClientID
GROUP BY bt.ID, bt.URN, v.URN, c.URN
UNION ALL
SELECT 
	-2147483648 as [ID], 
	'Leer' as [BusinessTransaction],
	'Leer' as [BusinessTransactionType],
	--Mandantenkennung
	N'urn:quibiq:epcis:cbv:client:epcisrepository' as [Client]
GO
PRINT N'Creating [Analysis].[EPCISVocabularyElement]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2014  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 30.07.2014 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE VIEW [Analysis].[EPCISVocabularyElement]
WITH SCHEMABINDING
AS 
SELECT 
	v.[ID], 
	v.[VocabularyTypeID], 
	v.[URN] as VocabularyElement,
	vt.[URN] as Vocabulary,
	--Mandantenkennung
	c.[URN] as [Client]
FROM [Vocabulary].[Vocabulary] v
JOIN [Vocabulary].[VocabularyType] vt on vt.ID = v.VocabularyTypeID
-- Mandantenkennung
JOIN [Vocabulary].[Vocabulary] c on c.ID = v.ClientID
WHERE v.Deleted = 0
GO
PRINT N'Creating [Event].[EPCType]...';


GO
CREATE view Event.EPCType
as
select
	ee.EPCISEventID as ID,
	e.URN,
	ee.IsParentID
from
	Event.EPCISEvent_EPC ee
inner join
	Event.EPC e on e.ID = ee.EPCID
GO
PRINT N'Creating [Event].[EPCISEvents_OrderByString]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS 1_1
-- Firma:    QUIBIQ
-- (c) 2015  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 10.03.2015 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE VIEW [Event].[EPCISEvents_OrderByString]
AS
select 
	ev.EPCISEventID, 
	ValueTypeID, 
	max(vs.Value) as [SortValue]
from Event.EPCISEvent_Value ev
join Event.EPCISEvent_Value_String evn on evn.EPCISEvent_ValueID = ev.ID
join Event.Value_String vs on vs.ID = evn.Value_StringID
group by EPCISEventID, ValueTypeID
GO
PRINT N'Creating [Event].[EPCISEvents_OrderByNumeric]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS 1_1
-- Firma:    QUIBIQ
-- (c) 2015  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 10.03.2015 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE VIEW [Event].[EPCISEvents_OrderByNumeric]
AS
select 
	ev.EPCISEventID, 
	ValueTypeID, 
	max(evn.Value) as [SortValue]
from Event.EPCISEvent_Value ev
join Event.EPCISEvent_Value_Numeric evn on evn.EPCISEvent_ValueID = ev.ID
group by EPCISEventID, ValueTypeID
GO
PRINT N'Creating [Event].[EPCISEvents_OrderByDatetime]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS 1_1
-- Firma:    QUIBIQ
-- (c) 2015  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 10.03.2015 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE VIEW [Event].[EPCISEvents_OrderByDatetime]
AS
select 
	ev.EPCISEventID, 
	ValueTypeID, 
	max(evn.Value) as [SortValue]
from Event.EPCISEvent_Value ev
join Event.EPCISEvent_Value_Datetime evn on evn.EPCISEvent_ValueID = ev.ID
group by EPCISEventID, ValueTypeID
GO
PRINT N'Creating [Event].[EPCClassType]...';


GO

CREATE view [Event].[EPCClassType]
as
select
	e.ID,	
	v.URN as VocabularyURN
from 
	Event.EPCISEvent e
inner join
	Event.EPCISEvent_Vocabulary ev on ev.EPCISEventID = e.ID
inner join
	Vocabulary.Vocabulary v on v.ID = ev.VocabularyID
inner join
	Vocabulary.VocabularyType vt on vt.ID = v.VocabularyTypeID
where
	vt.URN = 'urn:epcglobal:epcis:vtype:EPCClass'
GO
PRINT N'Creating [Event].[DispositionType]...';


GO
create view Event.DispositionType
as
select
	e.ID,
	v.URN as VocabularyURN
from 
	Event.EPCISEvent e
inner join
	Event.EPCISEvent_Vocabulary ev on ev.EPCISEventID = e.ID
inner join
	Vocabulary.Vocabulary v on v.ID = ev.VocabularyID
inner join
	Vocabulary.VocabularyType vt on vt.ID = v.VocabularyTypeID
where
	vt.URN = 'urn:epcglobal:epcis:vtype:Disposition'
GO
PRINT N'Creating [Event].[ChildrenType]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS1_1
-- Firma:    QUIBIQ
-- (c) 2015  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 08.04.2015 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE VIEW [Event].[ChildrenType]
AS
with ParentToChildren as (
	select 
		 EPCISEventID as ID
		,VocabularyID
	from Event.EPCISEvent_Vocabulary ev
	join Vocabulary.Vocabulary v on v.ID = ev.VocabularyID
	where v.Deleted = 0
	union all
	select
		c.ID
	   ,p.VocabularyID as VocabularyID
	from ParentToChildren c
	join Vocabulary.VocabularyChildren p on p.ChildVocabularyID = c.VocabularyID
	where p.Deleted = 0
)
select 

	ptc.ID,
	v.URN as VocabularyURN,
	null as ChildVocabularyURN,
	vt.URN as VocabularyTypeURN,
	null as ChildVocabularyTypeURN 

from ParentToChildren ptc
join Vocabulary.Vocabulary v on v.ID = ptc.VocabularyID
join Vocabulary.VocabularyType vt on vt.ID = v.VocabularyTypeID
where v.Deleted = 0
GO
PRINT N'Creating [Event].[BusinessTransactionType]...';


GO

CREATE view [Event].[BusinessTransactionType]
as
select
	e.ID,	
	v.URN as VocabularyURN,
	bt.URN
from 
	Event.EPCISEvent e
inner join
	Event.EPCISEvent_BusinessTransactionID eb on eb.EPCISEventID = e.ID
inner join
	Event.BusinessTransactionID bt on bt.ID = eb.BusinessTransactionIDID
inner join
	Vocabulary.Vocabulary v on v.ID = bt.BusinessTransactionTypeID
inner join
	Vocabulary.VocabularyType vt on vt.ID = v.VocabularyTypeID
where
	vt.URN = 'urn:epcglobal:epcis:vtype:BusinessTransactionType'
GO
PRINT N'Creating [Event].[BusinessStepType]...';


GO
create view Event.BusinessStepType
as
select
	e.ID,
	v.URN as VocabularyURN
from 
	Event.EPCISEvent e
inner join
	Event.EPCISEvent_Vocabulary ev on ev.EPCISEventID = e.ID
inner join
	Vocabulary.Vocabulary v on v.ID = ev.VocabularyID
inner join
	Vocabulary.VocabularyType vt on vt.ID = v.VocabularyTypeID
where
	vt.URN = 'urn:epcglobal:epcis:vtype:BusinessStep'
GO
PRINT N'Creating [Event].[BusinessLocationType]...';


GO
create view Event.BusinessLocationType
as
select
	e.ID,
	v.URN as VocabularyURN
from 
	Event.EPCISEvent e
inner join
	Event.EPCISEvent_Vocabulary ev on ev.EPCISEventID = e.ID
inner join
	Vocabulary.Vocabulary v on v.ID = ev.VocabularyID
inner join
	Vocabulary.VocabularyType vt on vt.ID = v.VocabularyTypeID
where
	vt.URN = 'urn:epcglobal:epcis:vtype:BusinessLocation'
GO
PRINT N'Creating [Event].[ActionType]...';


GO
create view Event.ActionType
as
select
	e.ID,
	v.URN as VocabularyURN
from 
	Event.EPCISEvent e
inner join
	Event.EPCISEvent_Vocabulary ev on ev.EPCISEventID = e.ID
inner join
	Vocabulary.Vocabulary v on v.ID = ev.VocabularyID
inner join
	Vocabulary.VocabularyType vt on vt.ID = v.VocabularyTypeID
where
	vt.URN = 'urn:quibiq:epcis:vtype:action'
GO
PRINT N'Creating [Event].[ReadPointType]...';


GO
create view Event.ReadPointType
as
select
	e.ID,
	v.URN as VocabularyURN
from 
	Event.EPCISEvent e
inner join
	Event.EPCISEvent_Vocabulary ev on ev.EPCISEventID = e.ID
inner join
	Vocabulary.Vocabulary v on v.ID = ev.VocabularyID
inner join
	Vocabulary.VocabularyType vt on vt.ID = v.VocabularyTypeID
where
	vt.URN = 'urn:epcglobal:epcis:vtype:ReadPoint'
GO
PRINT N'Creating [Event].[QuantityType]...';


GO
CREATE view [Event].[QuantityType]
as
select
	e.ID,
	evi.Value as Quantity
from 
	Event.EPCISEvent e
inner join
	Event.EPCISEvent_Value ev on ev.EPCISEventID = e.ID
inner join
	Event.EPCISEvent_Value_Numeric evi on evi.EPCISEvent_ValueID = ev.ID
inner join
	Vocabulary.Vocabulary v on v.ID = ev.ValueTypeID
where
	v.URN = 'urn:quibiq:epcis:cbv:valuetype:quantity'
GO
PRINT N'Creating [Event].[EventValueType]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2013  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 10.07.2013 | 1.0.0.0 | Paul Hummel	      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE view [Event].[EventValueType]
as
select
	eev.ID as EPCISEvent_ValueID, 
	eevd.Value AS DatetimeValue, 
	eevf.Value AS NumericValue, 
	vs.Value   AS StringValue
from 
	Event.EPCISEvent_Value eev
left join Event.EPCISEvent_Value_Datetime eevd
	on eev.ID = eevd.EPCISEvent_ValueID
left join Event.EPCISEvent_Value_Numeric eevf
	on eev.ID = eevf.EPCISEvent_ValueID
--join Event.EPCISEvent_Value_Int eevi
--	on eev.ID = eevi.EPCISEvent_ValueID
join Event.EPCISEvent_Value_String eevs
	on eev.ID = eevs.EPCISEvent_ValueID
join Event.Value_String vs
	on vs.ID = eevs.Value_StringID
GO
PRINT N'Creating [Event].[EventType]...';


GO
CREATE view Event.EventType
as
select
	e.ID,
	e.EventTime,
	e.RecordTime,
	v.URN as VocabularyURN
from 
	Event.EPCISEvent e
inner join
	Event.EPCISEvent_Vocabulary ev on ev.EPCISEventID = e.ID
inner join
	Vocabulary.Vocabulary v on v.ID = ev.VocabularyID
inner join
	Vocabulary.VocabularyType vt on vt.ID = v.VocabularyTypeID
where
	vt.URN = 'urn:quibiq:epcis:vtype:event'
GO
PRINT N'Creating [Event].[EventExtension]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2013  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 10.07.2013 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE VIEW [Event].[EventExtension]
WITH SCHEMABINDING
AS
with 
  recur as (
		select 
			 vv.URN as Name
			,CAST(N'' as nvarchar(512))    as Parent
			,0      as Depth
			,v.ID   as ID
			,v.DataTypeID as DataTypeID
			,v.EPCISEventID 
		from [Event].[EPCISEvent_Value] v
		join [Vocabulary].[Vocabulary]  vv on v.ValueTypeID = vv.ID
		join [Vocabulary].[VocabularyType] vt on vv.VocabularyTypeID = vt.ID
		where not exists (
			select 1 from [Event].[EPCISEvent_Value_Hierarchy] 
				where EPCISEvent_ValueID = v.ID
			)
		and vt.URN = N'urn:quibiq:epcis:vtype:extensiontype'
		UNION ALL		
		select 
			 vv.URN  as Name
			,r.Name  as Parent
			,Depth+1 as Depth
			,v.ID    as ID
			,v.DataTypeID as DataTypeID
			,v.EPCISEventID
		from recur r
		join [Event].[EPCISEvent_Value_Hierarchy] h on h.Parent_EPCISEvent_ValueID = r.ID 
		join [Event].[EPCISEvent_Value] v on v.ID = h.EPCISEvent_ValueID
		join [Vocabulary].[Vocabulary]  vv on v.ValueTypeID = vv.ID
), value as (
		select 
			 r.EPCISEventID
			,r.Name
			,r.Parent
			,r.Depth
			,r.ID
			,vs.Value
			,CASE v.URN 
			  WHEN N'urn:quibiq:epcis:cbv:datatype:xml' THEN 1
			  ELSE 0
			 END AS IsXMLNode
		from recur r
		left join [Event].[EPCISEvent_Value_String]  evs on evs.EPCISEvent_ValueID = r.ID
		left join [Event].[Value_String]  vs on vs.ID = evs.Value_StringID
		join [Vocabulary].Vocabulary v on r.DataTypeID = v.ID
)
select
	EPCISEventID,
	Name,
	Parent,
	Depth,
	IsXMLNode,
	Value
from value v
GO
PRINT N'Creating [Import].[EPCISMasterData_Error]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2014  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 03.09.2014 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE VIEW [Import].[EPCISMasterData_Error]
WITH SCHEMABINDING
AS
	  SELECT eq.ID as [QueueID]
      ,[Client]
      ,CAST([EPCISMasterData] as nvarchar(max)) as [EPCISMasterData]
	  ,CAST([EPCISMasterDataOriginal] as nvarchar(max)) as [EPCISMasterDataOriginal]
      ,[Processed]
      ,[Error]
	  ,[ErrorID]
      ,CAST([TimeStampGeneration] as datetime) as [TimeStampGeneration]
      ,[AdditionalInformation]
      ,[ErrorNumber]
      ,[ErrorSeverity]
      ,[ErrorProcedure]
      ,[ErrorMessage]
      ,[ErrorLine]
      ,[ErrorState]
      ,[ObjectID]
  FROM [Import].[EPCISMasterData_Queue] eq
  JOIN [Import].[Error]			     er on er.ObjectID = eq.ID
  WHERE eq.Error = 1 and er.AdditionalInformation = N'ObjectID: EPCISMasterData_QUEUE'
GO
PRINT N'Creating [Import].[EPCISEvent_Error]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2014  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 03.09.2014 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE VIEW [Import].[EPCISEvent_Error]
WITH SCHEMABINDING
AS
SELECT eq.ID as [QueueID]
      ,[Client]
      ,CAST([EPCISEvent] as nvarchar(max)) as [EPCISEvent]
	  ,CAST([EPCISEventOriginal] as nvarchar(max)) as [EPCISEventOriginal]
      ,[Processed]
      ,[Error]
	  ,[ErrorID]
      ,CAST([TimeStampGeneration] as datetime) as [TimeStampGeneration]
      ,[AdditionalInformation]
      ,[ErrorNumber]
      ,[ErrorSeverity]
      ,[ErrorProcedure]
      ,[ErrorMessage]
      ,[ErrorLine]
      ,[ErrorState]
      ,[ObjectID]
  FROM [Import].[EPCISEvent_Queue] eq
  JOIN [Import].[Error]			er on er.ObjectID = eq.ID
  WHERE eq.Error = 1 and er.AdditionalInformation = N'ObjectID: EPCISEvent_QUEUE';
GO
PRINT N'Creating [Import].[EPCIS_Error]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2014  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 03.09.2014 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE VIEW [Import].[EPCIS_Error]
WITH SCHEMABINDING
AS
SELECT
	 [QueueID]
    ,[Client]
    ,[EPCISMasterData] as [Xml]
	,[EPCISMasterDataOriginal] as [XmlOriginal]
    ,[Processed]
    ,[Error]
	,[ErrorID]
    ,[TimeStampGeneration]
    ,[AdditionalInformation]
    ,[ErrorNumber]
    ,[ErrorSeverity]
    ,[ErrorProcedure]
    ,[ErrorMessage]
    ,[ErrorLine]
    ,[ErrorState]
    ,[ObjectID]
FROM [Import].[EPCISMasterData_Error]
UNION ALL
SELECT
	 [QueueID]
    ,[Client]
    ,[EPCISEvent] as [Xml]
	,[EPCISEventOriginal] as [XmlOriginal]
    ,[Processed]
    ,[Error]
	,[ErrorID]
    ,[TimeStampGeneration]
    ,[AdditionalInformation]
    ,[ErrorNumber]
    ,[ErrorSeverity]
    ,[ErrorProcedure]
    ,[ErrorMessage]
    ,[ErrorLine]
    ,[ErrorState]
    ,[ObjectID]
FROM [Import].[EPCISEvent_Error];
GO
PRINT N'Creating [Vocabulary].[VocabularyChildrenType]...';


GO
create view Vocabulary.VocabularyChildrenType
as
select
	c.VocabularyID,
	v.URN as ChildURN
from
	Vocabulary.VocabularyChildren c
inner join
	Vocabulary.Vocabulary v on v.ID = c.ChildVocabularyID
GO
PRINT N'Creating [dbo].[View_Events_per_Hour]...';


GO

CREATE VIEW [dbo].[View_Events_per_Hour]
AS
SELECT     TOP (100) PERCENT CAST(RecordTime AS date) AS 'Day', DATEPART(hour, RecordTime) AS 'Hour', COUNT(ID) AS 'Events'
FROM         Event.EPCISEvent WITH (READUNCOMMITTED)
GROUP BY CAST(RecordTime AS date), DATEPART(hour, RecordTime)
ORDER BY 'Day' DESC, 'Hour' DESC
GO
PRINT N'Creating [Callback].[svf_Get_Next_DatePart_Value]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2013  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 15.07.2013 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE FUNCTION [Callback].[svf_Get_Next_DatePart_Value]
(
	@DatePart    char(2),
	@Value		 tinyint
)
RETURNS tinyint
AS
BEGIN
	DECLARE @Result tinyint = @Value + 1;

	IF @DatePart = 'ss'
	BEGIN
		IF @Result > 59
			RETURN 0;
	END;

	IF @DatePart = 'mi'
	BEGIN
		IF @Result > 59
			RETURN 0;
	END;

	IF @DatePart = 'hh'
	BEGIN
		IF @Result > 23
			RETURN 0;
	END;

	IF @DatePart = 'dd'
	BEGIN
		IF @Result > 31
			RETURN 1;
	END;

	IF @DatePart = 'mm'
	BEGIN
		IF @Result > 12
			RETURN 1;
	END;

	IF @DatePart = 'dw'
	BEGIN
		IF @Result > 7
			RETURN 1;
	END;

	RETURN @Result;
END
GO
PRINT N'Creating [Callback].[svf_Check_Schedule_Part]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2013  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 15.07.2013 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE FUNCTION [Callback].[svf_Check_Schedule_Part]
(
	@DatePart char(2),
	@Value    tinyint
)
RETURNS BIT
AS
BEGIN

	-- 2 stellige Nomenklatur Analog DATEPART http://msdn.microsoft.com/de-de/library/ms174420.aspx

	IF @DatePart = 'ss'
	BEGIN
		IF @Value between 0 and 59
			RETURN 1;
	END;

	IF @DatePart = 'mi'
	BEGIN
		IF @Value between 0 and 59
			RETURN 1;
	END;

	IF @DatePart = 'hh'
	BEGIN
		IF @Value between 0 and 23
			RETURN 1;
	END;

	IF @DatePart = 'dd'
	BEGIN
		IF @Value between 1 and 31
			RETURN 1;
	END;

	IF @DatePart = 'mm'
	BEGIN
		IF @Value between 1 and 12
			RETURN 1;
	END;

	IF @DatePart = 'dw'
	BEGIN
		IF @Value between 1 and 7
			RETURN 1;
	END;

	RETURN 0;
END
GO
PRINT N'Creating [Callback].[svf_Check_Month_Day]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2013  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 15.07.2013 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE FUNCTION [Callback].[svf_Check_Month_Day]
(
	@Day		tinyint,
	@Month		tinyint,
	@Year       int
)
RETURNS tinyint
AS
BEGIN
	DECLARE @DateString char(10);

	IF @Month in (4,6,9,11) and @Day = 31
		SET @Day = 1;
	IF @Month = 2 and @Day > 29
		SET @Day = 1;
	IF @Month = 2 and @Day = 29
	BEGIN
		-- nächstes valides Datum berechnen
		SET @DateString = CAST(@Year as char(4)) + '-' + CAST(@Month as char(2))+ '-' + CAST(@Day as char(2));
		IF ISDATE(@DateString) = 0
			SET @Day = 1;
	END;

	RETURN @Day;

END
GO
PRINT N'Creating [Helper].[svf_check_EPC_Code]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2013  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- Prüft einen String auf URI Conform und falls URI = urn:epc:id: dann auf die Regeln aus
-- http://www.gs1.org/gsmp/kc/epcglobal/tds/tds_1_3-standard-20060308.pdf Kapitel 4.1
-- 
-- urn:epc:id:gid:GeneralManagerNumber.ObjectClass.SerialNumber
--
-- urn:epc:id:sgtin:CompanyPrefix.ItemReference.SerialNumber (CompanyPrefix+ItemReference = 13)
-- urn:epc:id:sscc:CompanyPrefix.SerialReference (CompanyPrefix+SerialReference = 17)
-- urn:epc:id:sgln:CompanyPrefix.LocationReference.ExtensionComponent (CompanyPrefix+LocationReference = 12)
-- urn:epc:id:grai:CompanyPrefix.AssetType.SerialNumber (CompanyPrefix+AssetType = 12)
--
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 05.09.2013 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
-- 19.12.2013 | 1.0.1.0 | Florian Wagner      | Anpassung SUBSTRING Length Fehler
--            |         | FLW001			  |
-----------------------------------------------------------------------------------------
CREATE FUNCTION [Helper].[svf_check_EPC_Code]
(
	@EPCURN	nvarchar(512)
)
RETURNS BIT
AS
BEGIN
	DECLARE @Valid bit = 0;
	
	IF (SUBSTRING (@EPCURN, 1, 11) = 'urn:epc:id:')
	BEGIN
		-- EPC 
		DECLARE @len            int           = LEN(@EPCURN);
		DECLARE @gidend         int			  = CHARINDEX(N':', @EPCURN, 12);
		DECLARE @gid			nvarchar(5)   = SUBSTRING (@EPCURN, 12, @gidend-12);
		DECLARE @companyend     int			  = CHARINDEX(N'.', @EPCURN, @gidend+1);
		DECLARE @CompanyPrefix	nvarchar(17)  = SUBSTRING (@EPCURN, @gidend+1, IIF(@companyend-(@gidend+1) > 0, @companyend-(@gidend+1), 0));				--FLW001~

		IF @gid = N'sgtin'
		BEGIN
			DECLARE @itemend		int			 = CHARINDEX(N'.', @EPCURN, @companyend+1);
			DECLARE @ItemReference	nvarchar(13) = SUBSTRING (@EPCURN, @companyend+1, IIF(@itemend-(@companyend+1) > 0, @itemend-(@companyend+1), 0));		--FLW001~
			--DECLARE @SerialNumber	nvarchar(100) = SUBSTRING (@EPCURN, @itemend+1, @len-(@itemend));

			IF (LEN(@CompanyPrefix)+LEN(@ItemReference)) = 13	
				SET @Valid = 1
		END;

		IF @gid = N'sscc'
		BEGIN
			DECLARE @SerialReference	nvarchar(17) = SUBSTRING (@EPCURN, @companyend+1, IIF(@len-(@companyend) > 0, @len-(@companyend), 0));				--FLW001~

			IF (LEN(@CompanyPrefix)+LEN(@SerialReference)) = 17
				SET @Valid = 1
		END;

		IF @gid = N'sgln'
		BEGIN
			DECLARE @locend				int			 = CHARINDEX(N'.', @EPCURN, @companyend+1);
			DECLARE @LocationReference	nvarchar(12) = SUBSTRING (@EPCURN, @companyend+1, IIF(@locend-(@companyend+1) > 0, @locend-(@companyend+1), 0));	--FLW001~
			--DECLARE @ExtensionComponent nvarchar(100) = SUBSTRING (@EPCURN, @locend+1, @len-(@locend));

			IF (LEN(@CompanyPrefix)+LEN(@LocationReference)) = 12
				SET @Valid = 1
		END;

		IF @gid = N'grai'
		BEGIN
			DECLARE @assetend	int			 = CHARINDEX(N'.', @EPCURN, @companyend+1);
			DECLARE @AssetType	nvarchar(12) = SUBSTRING (@EPCURN, @companyend+1, IIF(@assetend-(@companyend+1) > 0, @assetend-(@companyend+1), 0));		--FLW001~
			--DECLARE @SerialNumber	nvarchar(100) = SUBSTRING (@EPCURN, @assetend+1, @len-(@assetend));

			IF (LEN(@CompanyPrefix)+LEN(@AssetType)) = 12
				SET @Valid = 1
		END;

		IF @gid = N'giai'
		BEGIN
			DECLARE @IndividualAssetReference nvarchar(100) = SUBSTRING (@EPCURN, @companyend+1, IIF(@len-(@companyend) > 0, @len-(@companyend), 0));		--FLW001~

			IF LEN(@IndividualAssetReference) > 1
				SET @Valid = 1
		END;
		
	END
	ELSE
	BEGIN
		-- URI min 3 Zeichen s:p und min. ein Doppelpunkt auf Position 2 oder höher (nicht C++ Zählweise)
		IF (CHARINDEX(N':', @EPCURN) > 1) AND (LEN(@EPCURN) >= 3)
		BEGIN
			SET @Valid = 1;
		END;
	END;

	RETURN @Valid;
END;
GO
PRINT N'Creating [Import].[svf_get_DataTypeURN]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2013  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- Ermittelt die korrekte Systemparameter des Datentyps anhand Inputspalten
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 05.07.2013 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE FUNCTION [Import].[svf_get_DataTypeURN]
(
	@IntValue bigint,
	@FloatValue float,
	@TimeValue datetime2(7),
	@StringValue nvarchar(max)
)
RETURNS nvarchar(255)
AS
BEGIN
	DECLARE @return nvarchar(255);

	if @IntValue is null
	begin
		if @FloatValue is null
		begin
			if @TimeValue is null
			begin
				if @StringValue is null
				begin
					set @return = N'urn:quibiq:epcis:cbv:datatype:xml'
				end
				else
					set @return =  N'urn:quibiq:epcis:cbv:datatype:string'
				end;
			else
			begin
				set @return =  N'urn:quibiq:epcis:cbv:datatype:time'
			end;
		end
		else
		begin
			set @return =  N'urn:quibiq:epcis:cbv:datatype:float'
		end;
	end
	else
	begin
		set @return =  N'urn:quibiq:epcis:cbv:datatype:int'
	end;

	return @return;
END;
GO
PRINT N'Creating [dbo].[dba_GetSQLForSpid]...';


GO
CREATE Function [dbo].[dba_GetSQLForSpid]

(

   @spid SMALLINT

)

RETURNS NVARCHAR(4000)

 

/*————————————————-

 

Purpose:   Returns the SQL text for a given spid.

 

—————————————————

 

Parameters:   @spid   - SQL Server process ID.

Returns:   @SqlText – SQL text for a given spid.

Revision History:

      01/12/2006   Ian_Stirk@yahoo.com Initial version

Example Usage:

   SELECT dbo.dba_GetSQLForSpid(51)

   SELECT dbo.dba_GetSQLForSpid(spid) AS [SQL text]

      , * FROM dbo.sysprocesses WITH (NOLOCK)

 

————————————————–*/

 

BEGIN

   DECLARE @SqlHandle BINARY(20)

   DECLARE @SqlText NVARCHAR(4000)

   -- Get sql_handle for the given spid.

   SELECT @SqlHandle = sql_handle

      FROM dbo.sysprocesses WITH (nolock) WHERE

      spid = @spid

   -- Get the SQL text for the given sql_handle.

   SELECT @SqlText = [text] FROM

      sys.dm_exec_sql_text(@SqlHandle)

   RETURN @SqlText

 

END
GO
PRINT N'Creating [Callback].[CK_Schedule_Part]...';


GO
ALTER TABLE [Callback].[Schedule_Part]
    ADD CONSTRAINT [CK_Schedule_Part] CHECK ([Callback].[svf_Check_Schedule_Part]([DatePart],[Value])=(1));


GO
PRINT N'Creating [Helper].[tvf_get_MandantenReceivePorts]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2013  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 17.08.2013 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE FUNCTION [Helper].[tvf_get_MandantenReceivePorts]()
RETURNS TABLE as
RETURN
(
		select
			Loc.value('.', N'nvarchar(512)') as ReceivePort,
			v.URN as Client
		from Vocabulary.VocabularyAttribute va
		CROSS APPLY Value.nodes('declare namespace rl="urn:quibiq:epcis:atype:receiveport"; /Value/rl:receiveport/text()') as T2(Loc) 
		join Vocabulary.AttributeType       at on at.ID = va.AttributeTypeID
		join Vocabulary.Vocabulary           v on  v.ID = va.VocabularyID 
		join Vocabulary.VocabularyType      vt on vt.ID = v.VocabularyTypeID
		where
			vt.URN = N'urn:quibiq:epcis:vtype:client'
		and at.URN = N'urn:quibiq:epcis:atype:receiveport'
)
GO
PRINT N'Creating [Import].[tvf_get_ClientID]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2013  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- Ermittelt die Mandanten VocabularyID sowie den aktuellen Systemmandanten via URN
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 05.07.2013 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE FUNCTION [Import].[tvf_get_ClientID]
(
	@Client nvarchar(512)
)
RETURNS TABLE RETURN
(
	select
		v.ID   as ClientID,
		syc.ID as SystemClientID
	from 
		 Vocabulary.Vocabulary v
	join Vocabulary.VocabularyType vt  on v.VocabularyTypeID   = vt.ID
	join Vocabulary.Vocabulary     syc on v.ClientID           = syc.ID
	join Vocabulary.VocabularyType svt on syc.VocabularyTypeID = svt.ID
	where
		-- gesuchter Mandant
		      v.URN   = @Client
		and  vt.URN   = N'urn:quibiq:epcis:vtype:client'
		-- Systemmandant
		and syc.URN   = N'urn:quibiq:epcis:cbv:client:epcisrepository'
		and svt.URN   = N'urn:quibiq:epcis:vtype:client'
)
GO
PRINT N'Creating [Callback].[tvf_get_Next_Time]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2013  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 15.07.2013 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE FUNCTION [Callback].[tvf_get_Next_Time]
(
	@ScheduleID  bigint,
	@DatePart    char(2),
	@Carry       bit,
	@RefValue    tinyint
)
RETURNS @retTable TABLE
(
	Value      tinyint,
	Carry      bit,
	MinValue   tinyint,
	OutOfRange bit
)
AS
BEGIN
	DECLARE 
		@Value		   tinyint,
		@TotalMinValue tinyint,
		@NewCarry	   bit,
		@ValidValue    bit = 0;

	SET @NewCarry = 0;

	-- check if a value exists in Shedule_Part for DatePart
	-- if yes then calculate by existing Schedule_Part values
	-- if no then +1 if Carry=1
	SELECT 
		@TotalMinValue = min([Value])
	FROM [Callback].[Schedule_Part]
	WHERE [DatePart] = @DatePart and [ScheduleID] = @ScheduleID;

	-- Proof if Value is Valid
	IF @TotalMinValue is null or exists (
								SELECT 
									TOP 1 1
								FROM [Callback].[Schedule_Part]
								WHERE [DatePart] = @DatePart and [Value] = @RefValue and [ScheduleID] = @ScheduleID)
	BEGIN
		SET @ValidValue = 1;
	END;

	IF @TotalMinValue is null and @Carry = 1
	BEGIN
		-- + 1 (with Overflow)
		SET @Value = [Callback].[svf_Get_Next_DatePart_Value] (@DatePart, @RefValue)		
				
		IF @Value < @RefValue
			SET @NewCarry = 1;
	END
	ELSE IF @Carry = 1
	BEGIN
		-- check if we are at starting position
		IF @TotalMinValue > @RefValue
		BEGIN
			SET @Value = @TotalMinValue;
		END
		ELSE
		BEGIN
			-- get smallest but greater than current value (next value)
			SELECT 
				@Value = min([Value])
			FROM [Callback].[Schedule_Part]
			WHERE [DatePart] = @DatePart and [Value] > @RefValue and [ScheduleID] = @ScheduleID;

			-- if this doesn't exist there is only one value next time interval
			IF @Value IS NULL
			BEGIN
				SET @Value = @TotalMinValue;
				SET @NewCarry = 1;
			END
			ELSE
			BEGIN
				SET @NewCarry = 0;
			END;
		END;
	END
	ELSE IF @Carry = 0
	BEGIN
		-- 
		IF @ValidValue = 0
		BEGIN
			-- get smallest but greater than current value (next value)
			SELECT 
				@Value = min([Value])
			FROM [Callback].[Schedule_Part]
			WHERE [DatePart] = @DatePart and [Value] > @RefValue and [ScheduleID] = @ScheduleID;

			IF @Value IS NULL
			BEGIN
				SET @Value = @TotalMinValue;
			END;

			IF @Value < @RefValue
			BEGIN
				SET @NewCarry = 1;
			END
			ELSE
			BEGIN
				SET @NewCarry = 0;
			END;
		END
		ELSE
		BEGIN
			SET @Value = @RefValue;
		END;
	END;
	
	-- MinValue berechnen
	IF @TotalMinValue is null 
	BEGIN
		IF @DatePart in ('ss', 'mi', 'hh')
			SET @TotalMinValue = 0;
		IF @DatePart in ('dd', 'mm', 'dw')
			SET @TotalMinValue = 1;
	END;

	INSERT @retTable (Value, Carry, MinValue, OutOfRange) VALUES(@Value, @NewCarry, @TotalMinValue, ~@ValidValue);

	RETURN;
END;
GO
PRINT N'Creating [Helper].[tvf_get_Partner_Settings]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2013  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- Ermittelt zu eienem Partner alle Informationen aus den Stammdaten
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 06.09.2013 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE FUNCTION [Helper].[tvf_get_Partner_Settings]
(
	@Client   nvarchar(512),
    @Username nvarchar(512) = null
)
RETURNS @returntable TABLE
(
	GLN      nvarchar(512) NOT NULL,
	Username nvarchar(512) NOT NULL,
	Atype    nvarchar(512) NOT NULL,
	Value    xml           NOT NULL
)
AS
BEGIN

	IF @Username is not null
	BEGIN

		INSERT INTO @returntable (
			GLN,
			Username,
			Atype,
			Value
		)
		select 
			v.URN as GLN, @Username as Username, at2.URN as ATYPE, va2.Value
		from 
			 Vocabulary.Vocabulary v
		join Vocabulary.VocabularyType           vt  on v.VocabularyTypeID    = vt.ID
		join Vocabulary.Vocabulary               syc on v.ClientID            = syc.ID
		join Vocabulary.VocabularyType           svt on syc.VocabularyTypeID  = svt.ID
		-- EPCIS Header Information
		JOIN [Vocabulary].[VocabularyAttribute] va2  on va2.VocabularyID = v.ID 
		JOIN [Vocabulary].[AttributeType]       at2  on at2.ID           = va2.AttributeTypeID
		where
			-- gesuchter Mandant
				syc.URN   = @Client
			and svt.URN   = N'urn:quibiq:epcis:vtype:client'
			and vt.URN    = N'urn:gmos:epcis:vtype:partners'
			-- N'urn:quibiq:epcis:atype:StandardBusinessDocumentHeader'
			and v.ID = 
				-- Einschränkung auf User
				(	select v.ID 
					from 
							Vocabulary.Vocabulary v
					join Vocabulary.VocabularyType           vt  on v.VocabularyTypeID    = vt.ID
					join Vocabulary.Vocabulary               syc on v.ClientID            = syc.ID
					join Vocabulary.VocabularyType           svt on syc.VocabularyTypeID  = svt.ID
					-- EPCIS Header Information
					JOIN [Vocabulary].[VocabularyAttribute] va2  on va2.VocabularyID = v.ID 
					JOIN [Vocabulary].[AttributeType]       at2  on at2.ID           = va2.AttributeTypeID and va2.Deleted = 0 -- gelöschte Partner sollen nicht berücksichtigt werden
					where   syc.URN   = @Client
						and svt.URN   = N'urn:quibiq:epcis:vtype:client'
						and va2.Value.exist(N'/Value[text() = sql:variable("@username")]') = 1
				);
	END
	ELSE
	BEGIN
		DECLARE @usernametable TABLE
		(
			GLN      nvarchar(512) NOT NULL,
			Username nvarchar(512) NOT NULL
		);

		INSERT INTO @returntable (
			GLN,
			Username,
			Atype,
			Value
		)
		select 
			v.URN as GLN, 'UNKNOWN' as Username, at2.URN as ATYPE, va2.Value
		from 
			 Vocabulary.Vocabulary v
		join Vocabulary.VocabularyType           vt  on v.VocabularyTypeID    = vt.ID
		join Vocabulary.Vocabulary               syc on v.ClientID            = syc.ID
		join Vocabulary.VocabularyType           svt on syc.VocabularyTypeID  = svt.ID
		-- EPCIS Header Information
		JOIN [Vocabulary].[VocabularyAttribute] va2  on va2.VocabularyID = v.ID 
		JOIN [Vocabulary].[AttributeType]       at2  on at2.ID           = va2.AttributeTypeID and va2.Deleted = 0 -- gelöschte Partner sollen nicht berücksichtigt werden
		where
			-- gesuchter Mandant
				syc.URN   = @Client
			and svt.URN   = N'urn:quibiq:epcis:vtype:client'
			and vt.URN    = N'urn:gmos:epcis:vtype:partners';

		-- Usernamen extrahieren
		INSERT INTO @usernametable (
			GLN,
			Username
		)
		SELECT 
			GLN,
			Value.value(N'(/Value/text())[1]', N'nvarchar(512)') as Username
		FROM @returntable
		WHERE Atype = N'urn:quibiq:epcis:atype:username';

		-- Usernamen übernehmen
		UPDATE @returntable 
			SET Username = b.Username 
		FROM @returntable a
		JOIN @usernametable b on (b.GLN = a.GLN );
		
	END;

	RETURN;
END;
GO
PRINT N'Creating [Helper].[tvf_get_Client_Settings]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2013  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- Ermittelt zu Client und Attributtyp aus den SystemStammdaten den entsprechenden Wert
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 06.09.2013 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE FUNCTION [Helper].[tvf_get_Client_Settings]
(
	@Client        nvarchar(512),
    @AttributeType nvarchar(512)
)
RETURNS @returntable TABLE
(
	Value xml NOT NULL
)
AS
BEGIN
	INSERT INTO @returntable (
		Value
	)
	select 
		va2.Value
	from 
		 Vocabulary.Vocabulary v
	join Vocabulary.VocabularyType           vt  on v.VocabularyTypeID    = vt.ID
	join Vocabulary.Vocabulary               syc on v.ClientID            = syc.ID
	join Vocabulary.VocabularyType           svt on syc.VocabularyTypeID  = svt.ID
	-- EPCIS Header Information
	JOIN [Vocabulary].[VocabularyAttribute] va2  on va2.VocabularyID = v.ID 
	JOIN [Vocabulary].[AttributeType]       at2  on at2.ID           = va2.AttributeTypeID
	where
		-- gesuchter Mandant
		      v.URN   = @Client
		and  vt.URN   = N'urn:quibiq:epcis:vtype:client'
		-- Systemmandant
		and syc.URN   = N'urn:quibiq:epcis:cbv:client:epcisrepository'
		and svt.URN   = N'urn:quibiq:epcis:vtype:client'
		-- Attribut
		and at2.URN   = @AttributeType;

	RETURN;
END;
GO
PRINT N'Creating [Callback].[svf_Calc_Next_Run]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2013  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 15.07.2013 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE FUNCTION [Callback].[svf_Calc_Next_Run]
(
	@ScheduleID		 bigint,
	@ReferenceDate	 datetime2(0)
)
RETURNS DATETIME2(0)
AS
BEGIN

	-- Dateparts of Reference Date
	DECLARE
		@RefSecond		tinyint = CAST(DATEPART(ss, @ReferenceDate) as tinyint),
		@RefMinute		tinyint = CAST(DATEPART(mi, @ReferenceDate) as tinyint),
		@RefHour		tinyint = CAST(DATEPART(hh, @ReferenceDate) as tinyint),
		@RefDayOfMonth  tinyint = CAST(DATEPART(dd, @ReferenceDate) as tinyint),
		@RefMonth		tinyint = CAST(DATEPART(mm, @ReferenceDate) as tinyint),
		@RefWeekDay		tinyint = CAST(DATEPART(dw, @ReferenceDate) as tinyint),
		@RefYear        int     = CAST(DATEPART(yy, @ReferenceDate) as int),
		@MinSecond		tinyint,
		@MinMinute		tinyint,
		@MinHour		tinyint,
		@MinDayOfMonth  tinyint,
		@MinMonth		tinyint,
		@OutOfRange     bit = 0,
		@Carry          bit,
		@Second         tinyint,
		@Minute         tinyint,
		@Hour           tinyint,
		@DayOfMonth     tinyint,
		@NewDayOfMonth  tinyint,
		@Month          tinyint,
		@Year           int,
		@WeekDay        tinyint,
		@DateString     char(10),
		@Weekdaydate    datetime2(0),
		@ResultDate     datetime2(0);

	--***************************************************************
	-- Schedule-Werte ermitteln
	--***************************************************************

	-- Sekunden
	SET @Carry		= 1;	-- Sonst keine Weiterschaltung der Werte
	SELECT TOP 1 
		@Second = Value, @Carry = Carry, @MinSecond = MinValue, @OutOfRange = OutOfRange
	FROM [Callback].[tvf_get_Next_Time] (@ScheduleID, 'ss', @Carry, @RefSecond);

	-- Minuten
	SELECT TOP 1 
		@Minute = Value, @Carry = Carry, @MinMinute = MinValue, @OutOfRange = OutOfRange
	FROM [Callback].[tvf_get_Next_Time] (@ScheduleID, 'mi', @Carry, @RefMinute);

	IF @OutOfRange = 1
	BEGIN
		SET @Second = @MinSecond;
	END;

	-- Stunden
	SELECT TOP 1 
		@Hour = Value, @Carry = Carry, @MinHour = MinValue, @OutOfRange = OutOfRange
	FROM [Callback].[tvf_get_Next_Time] (@ScheduleID, 'hh', @Carry, @RefHour);

	IF @OutOfRange = 1
	BEGIN
		SET @Second = @MinSecond;SET @Minute = @MinMinute;
	END;

	-- Tag
	SELECT TOP 1 
		@DayOfMonth = Value, @Carry = Carry, @MinDayOfMonth = MinValue, @OutOfRange = OutOfRange
	FROM [Callback].[tvf_get_Next_Time] (@ScheduleID, 'dd', @Carry, @RefDayOfMonth);
	
	SET @DayOfMonth = [Callback].[svf_Check_Month_Day] (@DayOfMonth, @RefMonth, @RefYear);
	
	IF @DayOfMonth < @RefDayOfMonth 
	BEGIN
		SET @DayOfMonth = @MinDayOfMonth;
		SET @Carry = 1;
	END;

	IF @OutOfRange = 1
	BEGIN
		SET @Second = @MinSecond;SET @Minute = @MinMinute;SET @Hour = @MinHour;
	END;

	-- Monat
	SELECT TOP 1 
		@Month = Value, @Carry = Carry, @MinMonth = MinValue, @OutOfRange = OutOfRange
	FROM [Callback].[tvf_get_Next_Time]  (@ScheduleID, 'mm', @Carry, @RefMonth);

	IF @OutOfRange = 1
	BEGIN
		SET @Second = @MinSecond;SET @Minute = @MinMinute;SET @Hour = @MinHour;SET @DayOfMonth = @MinDayOfMonth;
	END;

	-- Jahr 
	IF @Carry = 1
	BEGIN
		SET @Year = @RefYear + 1;
	END
	ELSE
	BEGIN
		SET @Year = @RefYear;
	END;

	-- Nochmalige Prüfung des Tages
	SET @NewDayOfMonth = [Callback].[svf_Check_Month_Day] (@DayOfMonth, @Month, @Year);

	IF @NewDayOfMonth <> @DayOfMonth
	BEGIN
		-- Auf letzten gültigen Tag zurückrechnen und svf_Calc_Next_Run aufrufen.
		SET @DateString = CAST(@Year as char(4)) + '-' + CAST(@Month as char(2))+ '-' + CAST(@DayOfMonth as char(2));
		WHILE ISDATE(@DateString) = 0
		BEGIN
			SET @DayOfMonth = @DayOfMonth - 1;
			SET @DateString = CAST(@Year as char(4)) + '-' + CAST(@Month as char(2))+ '-' + CAST(@DayOfMonth as char(2));
		END;

		-- Recursion
		SET @ResultDate = DATETIME2FROMPARTS ( @Year, @Month, @DayOfMonth, @Hour, @Minute, @Second, 0, 0 );
		SET @ResultDate = [Callback].[svf_Calc_Next_Run] ( @ScheduleID, @ResultDate );
	END
	ELSE
	BEGIN

		-- Ergebnis berechnen
		SET @ResultDate = DATETIME2FROMPARTS ( @Year, @Month, @DayOfMonth, @Hour, @Minute, @Second, 0, 0 );

	END;


	-- Wenn Wochentag Einschränkung vorhanden
	IF exists (
			SELECT 
				1
			FROM [Callback].[Schedule_Part]
			WHERE [DatePart] = 'dw' and [ScheduleID] = @ScheduleID
		)
	BEGIN
		-- Wochentag prüfen
		SET @WeekDay = CAST(DATEPART(dw, @ResultDate) as tinyint);
		SET @Weekdaydate = @ResultDate;

		-- Auf nächsten gültigen Wochentag iterieren
		WHILE not exists (
			SELECT 
				1
			FROM [Callback].[Schedule_Part]
			WHERE [DatePart] = 'dw' and [Value] = @WeekDay and [ScheduleID] = @ScheduleID
		) 
		BEGIN
			SET @Weekdaydate = DATEADD(dd, 1, @Weekdaydate);
			SET @WeekDay    = CAST(DATEPART(dw, @Weekdaydate) as tinyint);
		END;

		-- Wenn Weekaydate und ResultDate sich unterscheiden dann auf Vortag 23:59:59 gehen und nächstes Zeitinterval berechnen
		IF @Weekdaydate <> @ResultDate
		BEGIN
			SET @Month      = CAST(DATEPART(mm, @Weekdaydate) as tinyint);
			SET @DayOfMonth = CAST(DATEPART(dd, @Weekdaydate) as tinyint);
			SET @ResultDate = DATETIME2FROMPARTS ( @Year, @Month, @DayOfMonth, 0, 0, 0, 0, 0 );
			SET @ResultDate = DATEADD(ss, -1, @ResultDate);
			SET @ResultDate = [Callback].[svf_Calc_Next_Run] ( @ScheduleID, @ResultDate );
		END;
	END;

	RETURN @ResultDate;
END;
GO
PRINT N'Creating [Helper].[svf_get_StandardBusinessDocumentHeader]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2013  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- Ermittelt zu eiem Mandanten den StandardBusinessDocumentHeader
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 05.07.2013 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE FUNCTION  [Helper].[svf_get_StandardBusinessDocumentHeader]
(
	 @Client   nvarchar(512)
	,@Username nvarchar(512)
	,@EventTyp nvarchar(128)  -- EPCISDocument, EPCISQueryDocument
)
RETURNS XML
AS
BEGIN
	DECLARE @Result				xml;
	DECLARE @currentDate		datetime2(0) = CONVERT(datetime2(0), getdate());
	DECLARE @GLN				nvarchar(512);
	DECLARE @InstanceIdentifier int;
	DECLARE @Partner			TABLE
	(
		GLN   nvarchar(512) NOT NULL,
		Atype nvarchar(512) NOT NULL,
		Value xml           NOT NULL
	);

	-- Load StandardBusinessDocumentHeader for Client
	select TOP 1
		@Result = Value.query('/Value/*')
	FROM [Helper].[tvf_get_Client_Settings] ( @Client, N'urn:quibiq:epcis:atype:StandardBusinessDocumentHeader' );

	-- Aktuelle Uhrzeit
	SET @Result.modify(N'declare namespace sbdh="http://www.unece.org/cefact/namespaces/StandardBusinessDocumentHeader";
					replace value of (//sbdh:DocumentIdentification/sbdh:CreationDateAndTime/text())[1]
					with sql:variable("@currentDate")');

	-- Document Typ
	SET @Result.modify(N'declare namespace sbdh="http://www.unece.org/cefact/namespaces/StandardBusinessDocumentHeader";
					replace value of (//sbdh:DocumentIdentification/sbdh:Type/text())[1]
					with sql:variable("@EventTyp")');
	
	IF @Username is not null
	BEGIN
		-- Partnerinformationen ermitteln
		INSERT INTO @Partner (
			GLN,
			Atype,
			Value
		)
		SELECT
			GLN,
			Atype,
			Value
		FROM [Helper].[tvf_get_Partner_Settings] (@Client, @Username);
	END;

	-- GLN ermitteln 
	SELECT TOP 1 @GLN = GLN FROM @Partner;
	
	IF @GLN is null
	BEGIN
		-- Prüfen ob Masteruser
		IF exists (	SELECT TOP 1 1
					FROM (
					SELECT
						Loc.value('.', N'nvarchar(512)') as Username
					FROM [Helper].[tvf_get_Client_Settings] ( @Client, N'urn:quibiq:epcis:atype:masteruser' ) t
					CROSS APPLY t.Value.nodes(N'declare namespace rl="urn:quibiq:epcis:atype:username"; /Value/rl:username/text()') as T2(Loc)
					) a
					where Username = @Username
		)
		BEGIN

			-- GLN ermitteln 
			SET @GLN = @Result.value(N'declare namespace sbdh="http://www.unece.org/cefact/namespaces/StandardBusinessDocumentHeader";
										(//sbdh:Sender/sbdh:Identifier/text())[1]', N'nvarchar(512)');
			-- Laufnummer ermitteln
			SELECT TOP 1 @InstanceIdentifier =	Value.value(N'.', N'int')
			 FROM [Helper].[tvf_get_Client_Settings](N'urn:quibiq:epcis:cbv:client:gmos', N'urn:quibiq:epcis:atype:instanceidentifier');

		END
		ELSE
		BEGIN
			-- Ansonsten unbekannter Empfänger
			SET @GLN = 'UNKNOWN';
		END;
	END
	ELSE
	BEGIN
		-- Laufnummer ermitteln bei Partner
		SELECT TOP 1 @InstanceIdentifier = Value.value(N'(/Value/text())[1]', N'int') 
		FROM @Partner
		WHERE Atype = N'urn:quibiq:epcis:atype:instanceidentifier';
	END;



	IF @InstanceIdentifier is null
	BEGIN
		SET @InstanceIdentifier = 1;
	END
	ELSE
	BEGIN
		SET @InstanceIdentifier = @InstanceIdentifier + 1;
	END;

	-- Werte setzen
	SET @Result.modify(N'declare namespace sbdh="http://www.unece.org/cefact/namespaces/StandardBusinessDocumentHeader";
					replace value of (//sbdh:DocumentIdentification/sbdh:InstanceIdentifier/text())[1]
					with sql:variable("@InstanceIdentifier")');
	SET @Result.modify(N'declare namespace sbdh="http://www.unece.org/cefact/namespaces/StandardBusinessDocumentHeader";
					replace value of (//sbdh:Receiver/sbdh:Identifier/text())[1]
					with sql:variable("@GLN")');

	RETURN @Result;
END;
GO
PRINT N'Creating [Helper].[tvf_get_User_Queryfilter]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2013  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- Ermittelt zu einem Usernamen alle Queryfilter
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 06.09.2013 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE FUNCTION [Helper].[tvf_get_User_Queryfilter]
(
	@Client   nvarchar(512),
    @Username nvarchar(512) = null
)
RETURNS @returntable TABLE
(
	Username      nvarchar(512) NOT NULL,
	receiverGLN   nvarchar(512) NOT NULL
)
AS
BEGIN

	-- Normale User / ClientStammdaten
	INSERT INTO @returntable (
		Username,
		receiverGLN
	)
	select 
		Username,
		GLN as receiverGLN
	from [Helper].[tvf_get_Partner_Settings]( @Client, @Username )
	where Atype = N'urn:quibiq:epcis:atype:username';

	-- Master User / Systemstammdaten
	merge into @returntable as target
			using (
				SELECT
					Username,
					receiverGLN
				FROM (
					SELECT
						Loc.value('.', N'nvarchar(512)') as Username,
						N'all' as receiverGLN
					FROM [Helper].[tvf_get_Client_Settings] ( @Client, N'urn:quibiq:epcis:atype:masteruser' ) t
					CROSS APPLY t.Value.nodes(N'declare namespace rl="urn:quibiq:epcis:atype:username"; /Value/rl:username/text()') as T2(Loc)
				) as Masterusers
				WHERE Username = @Username or @Username is null
			) as source
		on target.Username = source.Username
		when not matched by target then
			insert (Username, receiverGLN)
				values (source.Username, source.receiverGLN)
		when matched then
			update set receiverGLN = source.receiverGLN;


	RETURN;
END;
GO
PRINT N'Creating [Helper].[usp_Update_MasterData_From_Queue]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2014  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 10.09.2014 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE PROCEDURE [Helper].[usp_Update_MasterData_From_Queue]
	@QueueID   bigint,
	@ClientURN nvarchar(512) = null,
	@Xml	   nvarchar(max)
AS
BEGIN
	SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
	SET NOCOUNT ON;
	SET XACT_ABORT ON;

	begin transaction;

		UPDATE Import.EPCISMasterData_Queue 
			SET EPCISMasterData = CAST(@Xml as XML)
		WHERE ID = @QueueID and (Client = @ClientURN or @ClientURN is null);

	commit transaction;

END
GO
PRINT N'Creating [Helper].[usp_Update_InstanceIdentifier]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2013  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- Erhöht den InstanceIdentifier Wert um eins oder fügt ihn Hinzu falls noch nicht vorhanden
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 06.09.2013 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE PROCEDURE [Helper].[usp_Update_InstanceIdentifier]
	@Client				nvarchar(512),
	@Username			nvarchar(512),
	@InstanceIdentifier int OUTPUT
AS
BEGIN
	SET NOCOUNT ON;
	DECLARE @GLN                nvarchar(512) = null;
	--DECLARE @InstanceIdentifier int;
	DECLARE @XMLValue           xml = CAST(N'<Value>1</Value>' as XML);

	IF @Username is not null
	BEGIN
		select top 1
			@GLN = GLN, 
			@InstanceIdentifier = Value.value(N'(Value/text())[1]', N'int') 
		from [Helper].[tvf_get_Partner_Settings]( @Client, @Username )
		where Atype = N'urn:quibiq:epcis:atype:instanceidentifier';
	END;


	IF @GLN is null
	BEGIN
		-- InstanceIdentifier noch nicht angelegt zu User
		SET @InstanceIdentifier = 1;

		IF @Username is not null
		BEGIN
			select top 1
				@GLN = GLN
			from [Helper].[tvf_get_Partner_Settings]( @Client, @Username );
		END;
		
		IF @GLN is null 
		BEGIN
			-- Prüfen ob Masteruser
			IF exists ( SELECT TOP 1 1
					FROM (
					SELECT
						Loc.value('.', N'nvarchar(512)') as Username
					FROM [Helper].[tvf_get_Client_Settings] ( @Client, N'urn:quibiq:epcis:atype:masteruser' ) t
					CROSS APPLY t.Value.nodes(N'declare namespace rl="urn:quibiq:epcis:atype:username"; /Value/rl:username/text()') as T2(Loc)
					) a
					where Username = @Username )
			BEGIN
				-- Laufnummer ermitteln
				SELECT TOP 1 @InstanceIdentifier =	Value.value(N'.', N'int')
				 FROM [Helper].[tvf_get_Client_Settings]( @Client, N'urn:quibiq:epcis:atype:instanceidentifier' );

				IF @InstanceIdentifier is null
				BEGIN
					-- Einfügen Instance Identifier
					INSERT INTO [Vocabulary].[VocabularyAttribute] (
						VocabularyID,
						AttributeTypeID,
						Value
					)
					SELECT
							v.ID,
							at2.ID,
							@XMLValue
					FROM  
							Vocabulary.Vocabulary v
					join Vocabulary.VocabularyType           vt  on v.VocabularyTypeID    = vt.ID
					join Vocabulary.Vocabulary               syc on v.ClientID            = syc.ID
					join Vocabulary.VocabularyType           svt on syc.VocabularyTypeID  = svt.ID
					JOIN [Vocabulary].[AttributeType]       at2  on at2.URN = N'urn:quibiq:epcis:atype:instanceidentifier'
					where
						-- gesuchter Mandant
							syc.URN   = N'urn:quibiq:epcis:cbv:client:epcisrepository'
						and svt.URN   = N'urn:quibiq:epcis:vtype:client'
						and vt.URN    = N'urn:quibiq:epcis:vtype:client'
						and v.URN     = @Client;

				END
				ELSE
				BEGIN
					-- Aktualisieren Instance Identifier
					SET @InstanceIdentifier = @InstanceIdentifier + 1;

					UPDATE [Vocabulary].[VocabularyAttribute] 
						SET Value.modify(N'replace value of (//Value/text())[1]
													with sql:variable("@InstanceIdentifier")')
					from 
						 Vocabulary.Vocabulary v
					join Vocabulary.VocabularyType           vt  on v.VocabularyTypeID    = vt.ID
					join Vocabulary.Vocabulary               syc on v.ClientID            = syc.ID
					join Vocabulary.VocabularyType           svt on syc.VocabularyTypeID  = svt.ID
					-- EPCIS Header Information
					JOIN [Vocabulary].[VocabularyAttribute] va2  on va2.VocabularyID = v.ID 
					JOIN [Vocabulary].[AttributeType]       at2  on at2.ID           = va2.AttributeTypeID
					where
						-- gesuchter Mandant
							syc.URN   = N'urn:quibiq:epcis:cbv:client:epcisrepository'
						and svt.URN   = N'urn:quibiq:epcis:vtype:client'
						and vt.URN    = N'urn:quibiq:epcis:vtype:client'
						and at2.URN   = N'urn:quibiq:epcis:atype:instanceidentifier'
						and v.URN     = @Client;

				END;

				RETURN;

			END
			ELSE
			BEGIN
				-- Falls auch kein Masteruser ausspringen -> keine weitere Aktion
				RETURN;
			END;
		END;
		

		-- Hinzufügen des Attributs zum Partner
		INSERT INTO [Vocabulary].[VocabularyAttribute] (
			VocabularyID,
			AttributeTypeID,
			Value
		)
		SELECT
			 v.ID,
			 at2.ID,
			 @XMLValue
		FROM  
			 Vocabulary.Vocabulary v
		join Vocabulary.VocabularyType           vt  on v.VocabularyTypeID    = vt.ID
		join Vocabulary.Vocabulary               syc on v.ClientID            = syc.ID
		join Vocabulary.VocabularyType           svt on syc.VocabularyTypeID  = svt.ID
		JOIN [Vocabulary].[AttributeType]       at2  on at2.URN = N'urn:quibiq:epcis:atype:instanceidentifier'
		where
			-- gesuchter Mandant
				syc.URN   = @Client
			and svt.URN   = N'urn:quibiq:epcis:vtype:client'
			and vt.URN    = N'urn:gmos:epcis:vtype:partners'
			and v.URN     = @GLN;
			
	END
	ELSE
	BEGIN
		-- InstanceIdentifier des Partner anpassen
		SET @InstanceIdentifier = @InstanceIdentifier + 1;

		UPDATE [Vocabulary].[VocabularyAttribute] 
			SET Value.modify(N'replace value of (//Value/text())[1]
										with sql:variable("@InstanceIdentifier")')
		from 
			 Vocabulary.Vocabulary v
		join Vocabulary.VocabularyType           vt  on v.VocabularyTypeID    = vt.ID
		join Vocabulary.Vocabulary               syc on v.ClientID            = syc.ID
		join Vocabulary.VocabularyType           svt on syc.VocabularyTypeID  = svt.ID
		-- EPCIS Header Information
		JOIN [Vocabulary].[VocabularyAttribute] va2  on va2.VocabularyID = v.ID 
		JOIN [Vocabulary].[AttributeType]       at2  on at2.ID           = va2.AttributeTypeID
		where
			-- gesuchter Mandant
				syc.URN   = @Client
			and svt.URN   = N'urn:quibiq:epcis:vtype:client'
			and vt.URN    = N'urn:gmos:epcis:vtype:partners'
			and at2.URN   = N'urn:quibiq:epcis:atype:instanceidentifier'
			and v.URN     = @GLN;
			
	END;

END;
GO
PRINT N'Creating [Helper].[usp_Update_Event_From_Queue]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2014  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 10.09.2014 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE PROCEDURE [Helper].[usp_Update_Event_From_Queue]
	@QueueID   bigint,
	@ClientURN nvarchar(512) = null,
	@Xml	   nvarchar(max)
AS
BEGIN
	SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
	SET NOCOUNT ON;
	SET XACT_ABORT ON;

	begin transaction;

		UPDATE Import.EPCISEvent_Queue 
			SET EPCISEvent = CAST(@Xml as XML)
		WHERE ID = @QueueID and (Client = @ClientURN or @ClientURN is null);

	commit transaction;

END
GO
PRINT N'Creating [Helper].[usp_Proof_Duplicates]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2013  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 05.09.2013 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE PROCEDURE [Helper].[usp_Proof_Duplicates]
	@ShowDuplicates   bit = 1,
	@DeleteDuplicates bit = 0,
	@RecordTimeFrom   datetime2(0) = NULL,
	@RecordTimeUntil  datetime2(0) = NULL
AS
BEGIN
	SET NOCOUNT ON;

	BEGIN TRANSACTION;

	IF @RecordTimeFrom  is null SET @RecordTimeFrom  = CAST(N'0001-01-01 00:00:00' as datetime2(0));
	IF @RecordTimeUntil is null SET @RecordTimeUntil = CAST(N'9999-12-31 23:59:59' as datetime2(0));

	-- Ermittle alle Doppler
	select
		ev.ID,
		ev.EventTime,
		ev.RecordTime,
		CASE @ShowDuplicates
			WHEN 0 THEN N'<e/>'
			WHEN 1 THEN ev.XmlRepresentation
		END as XmlRepresentation,
		Checksu
	into #tempEPCIS
	from Event.EPCISEvent ev
	join
	(
		select
			EventTime,
			Checksu
		from
		(	select 
				EventTime, 
				CHECKSUM (CAST (XmlRepresentation as VARBINARY(MAX))) as Checksu
			from Event.EPCISEvent
			where RecordTime between @RecordTimeFrom and @RecordTimeUntil
		) as re		
		group by EventTime, Checksu
		having count(*) > 1
	) as re 
	on		re.EventTime = ev.EventTime 
		and re.Checksu   = CHECKSUM (CAST (ev.XmlRepresentation as VARBINARY(MAX)))
	where ev.RecordTime between @RecordTimeFrom and @RecordTimeUntil;

	-- Zeige alle Doppler an
	IF @ShowDuplicates = 1
	BEGIN
		select 
			 ID
			,EventTime
			,RecordTime
			,XmlRepresentation
		from #tempEPCIS;
	END;

	-- Loesche jüngsten Eintrag
	delete #tempEPCIS
	from #tempEPCIS ts
	join (
		select 
			min(RecordTime) as RecordTime,
			EventTime,
			Checksu
		from #tempEPCIS
			group by EventTime, Checksu
		) as valid on valid.EventTime = ts.EventTime and valid.Checksu = ts.Checksu and valid.RecordTime = ts.RecordTime;


	-- Restliche Events sind doppler und können gelöscht werden
	IF @DeleteDuplicates = 1 
	BEGIN
		delete Event.EPCISEvent
		from Event.EPCISEvent e
		join #tempEPCIS te on te.ID = e.ID;
	END;

	-- CLEANUP
	drop table #tempEPCIS;

	COMMIT TRANSACTION;

END;
GO
PRINT N'Creating [Helper].[usp_get_StandardBusinessDocumentHeader]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2013  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- Erhöht den InstanceIdentifier Wert um eins oder fügt ihn Hinzu falls noch nicht vorhanden
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 06.09.2013 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE PROCEDURE [Helper].[usp_get_StandardBusinessDocumentHeader]
	@Client							nvarchar(512),
	@Username						nvarchar(512),
	@EventTyp						nvarchar(128),
	@StandardBusinessDocumentHeader xml OUTPUT,
	@InstanceIdentifier				int OUTPUT
AS
BEGIN

	SET NOCOUNT ON;

	SET @StandardBusinessDocumentHeader = [Helper].[svf_get_StandardBusinessDocumentHeader] (@Client, @Username, @EventTyp);
	
	EXECUTE [Helper].[usp_Update_InstanceIdentifier] 
		@Client             = @Client, 
		@Username           = @Username,
		@InstanceIdentifier = @InstanceIdentifier OUT;

END;
GO
PRINT N'Creating [Helper].[usp_Delete_MasterData_From_Queue]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2013  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 06.08.2013 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
-- 03.09.2014 | 1.0.1.0 | Florian Wagner      | Mandanten von aussen berücksichtigen
--            |         | FLW001              |
-----------------------------------------------------------------------------------------
CREATE PROCEDURE [Helper].[usp_Delete_MasterData_From_Queue]
	@QueueID   bigint = null,
	@ClientURN nvarchar(512) = null,	--FLW001+
	@All       bit    = 0
AS
BEGIN
	SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
	SET NOCOUNT ON;
	SET XACT_ABORT ON;

	IF @All = 0 and @QueueID is null
		THROW 51000, N'QueueID has to be set', 1;

	IF @All = 1 and @QueueID is not null
		THROW 51000, N'QueueID must not be set or @All has to be 0', 1;

	begin transaction;

		delete Import.Error
		from Import.Error er 
		join Import.EPCISMasterData_Queue eq on er.ObjectID = eq.ID
		where er.ErrorProcedure = N'usp_Import_MasterData' and eq.Error = 1 and (eq.ID = @QueueID or @QueueID is null) and (Client = @ClientURN or @ClientURN is null);	--FLW001~

		delete from Import.EPCISMasterData_Queue where Error = 1 and (ID = @QueueID or @QueueID is null) and (Client = @ClientURN or @ClientURN is null);	--FLW001~

	commit transaction;

END
GO
PRINT N'Creating [Helper].[usp_Delete_Event_From_Queue]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2013  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 06.08.2013 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
-- 03.09.2014 | 1.0.1.0 | Florian Wagner      | Mandanten von aussen berücksichtigen
--            |         | FLW001              |
-----------------------------------------------------------------------------------------
CREATE PROCEDURE [Helper].[usp_Delete_Event_From_Queue]
	@QueueID   bigint = null,
	@ClientURN nvarchar(512) = null,	--FLW001+
	@All       bit    = 0
AS
BEGIN
	SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
	SET NOCOUNT ON;
	SET XACT_ABORT ON;

	IF @All = 0 and @QueueID is null
		THROW 51000, N'QueueID has to be set', 1;

	IF @All = 1 and @QueueID is not null
		THROW 51000, N'QueueID must not be set or @All has to be 0', 1;

	begin transaction;

		delete Import.Error
		from Import.Error er 
		join Import.EPCISEvent_Queue eq on er.ObjectID = eq.ID
		where er.ErrorProcedure = N'usp_Import_Event' and eq.Error = 1 and (eq.ID = @QueueID or @QueueID is null) and (Client = @ClientURN or @ClientURN is null);	--FLW001~

		delete from Import.EPCISEvent_Queue where Error = 1 and (ID = @QueueID or @QueueID is null) and (Client = @ClientURN or @ClientURN is null);	--FLW001~

	commit transaction;

END
GO
PRINT N'Creating [Helper].[usp_ManualCleanUp_Repository]...';


GO

-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE [Helper].[usp_ManualCleanUp_Repository]
	-- Add the parameters for the stored procedure here
	@DaysToKeep INT = 30
	,@BatchSize INT = 50
	,@DebugMode bit = 0
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	-----------------------------------------------------------------------------------------
	-- Projekt:  EPCIS (CleanUp Repository Procedure)
	-- Firma:    QUIBIQ
	-- (c) 2016  QUIBIQ Schweiz AG
	-----------------------------------------------------------------------------------------
	--
	-- 
	-- 
	-- Datum      | Version | Autor               | Kommentar
	--------------|---------|---------------------|------------------------------------------
	-- 25.04.2016 | 1.1.0.0 | Andreas Conrad      | Erstellt.
	--------------|---------|---------------------|------------------------------------------
	-- 08.07.2019 | 1.2.0.0 | Stephan Kelso       | Alle Events älter als 30 Tage werden
	--            |         |                     | gelöscht.
	-----------------------------------------------------------------------------------------

	DECLARE @msg VARCHAR(1000)
	DECLARE @delcount INT
	DECLARE @epcCount int
	-- Zeitraum ältesten Eintragag bis heute minus @DaysToKeep Tage
	DECLARE @FromTimeStamp DATETIME2 = (
			SELECT ISNULL(max(RecordTime), N'1900-01-01')
			FROM [Event].[EPCISEvent] WITH (READUNCOMMITTED)
			)
	-- Zeitraum zum aufräumen: alle Events die älter als heute minus @DaysToKeep Tage sind
	DECLARE @ToTimeStamp DATETIME2

	SET @ToTimeStamp = DATEADD(day, - 1 * @DaysToKeep, GETDATE())

	-- Ermitteln der zu löschenden Events und Ausgabe als Information im Windows Eventlog
	SET @delcount = (
			SELECT count(*)
			FROM [Event].[EPCISEvent] WITH (READUNCOMMITTED)
			WHERE RecordTime <= @ToTimeStamp
			)

	SET @msg = 'Events to delete: ' + ltrim(convert(VARCHAR, @delcount))

	--EXEC xp_logevent 51000
	--	,@msg
	--	,informational;

------------------------ Temporäre EPC-Tabelle füllen

			IF OBJECT_ID('tempdb..#TempEEPC','U') is not null
				Drop Table #TempEEPC

			select distinct eepc.EPCID , eepc.EPCISEventID
			into #TempEEPC
			from [Event].EPCISEvent_EPC eepc WITH (READUNCOMMITTED)
			inner join 
				(
					select *
					FROM [Event].[EPCISEvent] WITH (READUNCOMMITTED)
					WHERE RecordTime <= @ToTimeStamp
				) e
			on eepc.EPCISEventID = e.ID
			
		
			set @epcCount= (
				select count(*)
				from Event.EPC epc WITH (READUNCOMMITTED)
				inner join #TempEEPC eepc
				on epc.ID = eepc.EPCID
			)

		SELECT @FromTimeStamp AS 'From'
			,@ToTimeStamp AS 'To'
			,DATEDIFF(day,@FromTimeStamp,@ToTimeStamp) as Days
			,@delcount as Events
			,@epcCount as EPCCount

			select * from #TempEEPC

---------------------
--------------------- Vorbereitung Debug Mode
	IF OBJECT_ID('tempdb..#DebugInfo','U') is not null
		Drop Table #DebugInfo

	create Table #DebugInfo
		(
			Object varchar(50)
			,Rows int
		)
	Insert into #DebugInfo Values('Start CleanUp',0) 
-----------------------------------------------

	-- Batchgröße: Anzahl Zeilen (ab 5000 verhängt die Databaseengine eine exklusive Tabellensperre über alle beteiligten Tabellen,
	--                            was zu einer DeadLock-Situation mit anderen Prozessen führen kann)
	-- wird vor jeder Schleife gesetzt 
	DECLARE @rc INT = @BatchSize

	WHILE @rc > 0
	BEGIN
		-- Bei Fehler -> Abbruch des gesamten Vorgangs
		BEGIN TRY
			BEGIN TRAN

			-- der Tabellenhinweis WITH (ROWLOCK) empfiehlt der Databaseengine nur die von der Löschung betroffenen Zeilen für andere Transaktionen
			-- zu sperren. 
			DELETE TOP (@rc) [Event].[EPCISEvent] WITH (ROWLOCK)
			FROM [Event].[EPCISEvent] e
			inner join #TempEEPC te
			on e.ID = te.EPCISEventID
			--WHERE RecordTime <= @ToTimeStamp
			--	AND ID IN (
			--		SELECT EPCISEventID 
			--		FROM #TempEEPC 
			--		)

			-- zuweisen der von der Löschabfrage betroffenen Zeilen an die Bedingungsvariable
			-- wenn keine Zeilen mehr gelöscht worden sind (@rc = 0), wird die Schleife verlassen
			SET @rc = @@ROWCOUNT
			insert into #DebugInfo Values ('Delete [EPCISEvent]',@rc)
			COMMIT
		END TRY

		BEGIN CATCH
			-- Speichern der Fehlernachricht
			SET @msg = 'Table: EPCISEvent -- CleanUp Repository Error: ' + ERROR_MESSAGE();

			-- Ausgabe der Nachricht im Windows EventLog als ERROR
			--EXEC xp_logevent 51000
			--	,@msg
			--	,error;

			-- Löschungen Rückgängig machen
			ROLLBACK;

			-- gesamten Vorgang abbrechen
			throw;
		END CATCH
	END

	-- Die obigen Erläuterungen gelten für alle folgenden Löschabfragen
	--SET @rc = @BatchSize

	--WHILE @rc > 0
	--BEGIN
	--	BEGIN TRAN

	--	DELETE TOP (@rc) [Event].[EPC] WITH (ROWLOCK)
	--	FROM [Event].[EPC] epc
	--	inner join #TempEEPC te
	--		on epc.ID = te.EPCID 
	--	--WHERE ID IN (
	--	--		SELECT EPCID
	--	--		FROM #TempEEPC WITH (READUNCOMMITTED)
	--	--		)

	--	SET @rc = @@ROWCOUNT
	--	insert into #DebugInfo Values ('Delete EPC',@rc)
		
	--	COMMIT
	--END

	SET @rc = @BatchSize

	WHILE @rc > 0
	BEGIN
		BEGIN TRAN

		DELETE TOP (@rc)
		FROM [Event].[BusinessTransactionID] WITH (ROWLOCK)
		WHERE ID NOT IN (
				SELECT BusinessTransactionIDID
				FROM [Event].[EPCISEvent_BusinessTransactionID] WITH (READUNCOMMITTED)
				)

		SET @rc = @@ROWCOUNT
		insert into #DebugInfo Values ('Delete [BusinessTransactionID]',@rc)

		COMMIT
	END
------------------------Debug
	select *
	from Event.EPC epc
	inner join #TempEEPC
	on  epc.ID = #TempEEPC.EPCID

------------------------

	SET @rc = @BatchSize

	WHILE @rc > 0
	BEGIN
		BEGIN TRAN

		DELETE TOP (@rc)
		FROM [Event].[Value_String] WITH (ROWLOCK)
		WHERE ID NOT IN (
				SELECT Value_StringID
				FROM [Event].[EPCISEvent_Value_String] WITH (READUNCOMMITTED)
				)

		SET @rc = @@ROWCOUNT
		insert into #DebugInfo Values ('Delete [Value_String]',@rc)
		COMMIT
	END

	SET @rc = @BatchSize

	WHILE @rc > 0
	BEGIN
		BEGIN TRAN

		DELETE TOP (@rc)
		FROM Vocabulary.VocabularyChildren WITH (ROWLOCK)
		WHERE Deleted = 1

		SET @rc = @@ROWCOUNT
		insert into #DebugInfo Values ('Delete VocabularyChildren',@rc)

		COMMIT
	END

	SET @rc = @BatchSize

	WHILE @rc > 0
	BEGIN
		BEGIN TRAN

		DELETE TOP (@rc)
		FROM Vocabulary.VocabularyAttribute WITH (ROWLOCK)
		WHERE Deleted = 1

		SET @rc = @@ROWCOUNT
		insert into #DebugInfo Values ('Delete VocabularyAttribute',@rc)

		COMMIT
	END

	SET @rc = @BatchSize

	WHILE @rc > 0
	BEGIN
		BEGIN TRAN

		DELETE TOP (@rc)
		FROM Vocabulary.Vocabulary WITH (ROWLOCK)
		WHERE NOT EXISTS (
				SELECT 1
				FROM Event.EPCISEvent_Vocabulary WITH (READUNCOMMITTED)
				WHERE VocabularyID = Vocabulary.Vocabulary.ID
				)
			AND NOT EXISTS (
				SELECT 1
				FROM Event.BusinessTransactionID WITH (READUNCOMMITTED)
				WHERE BusinessTransactionTypeID = Vocabulary.Vocabulary.ID
				)
			AND NOT EXISTS (
				SELECT 1
				FROM Event.EPCISEvent_Value WITH (READUNCOMMITTED)
				WHERE DataTypeID = Vocabulary.Vocabulary.ID
				)
			AND NOT EXISTS (
				SELECT 1
				FROM Event.EPCISEvent_Value WITH (READUNCOMMITTED)
				WHERE ValueTypeID = Vocabulary.Vocabulary.ID
				)
			AND NOT EXISTS (
				SELECT 1
				FROM Event.EPCISEvent WITH (READUNCOMMITTED)
				WHERE ClientID = Vocabulary.Vocabulary.ID
				)
			AND NOT EXISTS (
				SELECT 1
				FROM Vocabulary.AttributeType WITH (READUNCOMMITTED)
				WHERE ContentTypeID = Vocabulary.Vocabulary.ID
				)
			AND NOT EXISTS (
				SELECT 1
				FROM Vocabulary.VocabularyAttribute WITH (READUNCOMMITTED)
				WHERE VocabularyID = Vocabulary.Vocabulary.ID
				)
			AND NOT EXISTS (
				SELECT 1
				FROM Vocabulary.VocabularyChildren WITH (READUNCOMMITTED)
				WHERE VocabularyID = Vocabulary.Vocabulary.ID
				)
			AND NOT EXISTS (
				SELECT 1
				FROM Vocabulary.VocabularyChildren WITH (READUNCOMMITTED)
				WHERE ChildVocabularyID = Vocabulary.Vocabulary.ID
				)
			AND Deleted = 1

		SET @rc = @@ROWCOUNT
		insert into #DebugInfo Values ('Delete Vocabulary',@rc)

		COMMIT
	END

	SET @rc = @BatchSize

	WHILE @rc > 0
	BEGIN
		BEGIN TRAN

		DELETE TOP (@rc)
		FROM Vocabulary.VocabularyType_Client WITH (ROWLOCK)
		WHERE NOT EXISTS (
				SELECT 1
				FROM Vocabulary.VocabularyType WITH (READUNCOMMITTED)
				WHERE ID = VocabularyTypeID
				)
			AND Deleted = 1

		SET @rc = @@ROWCOUNT
		insert into #DebugInfo Values ('Delete VocabularyType_Client',@rc)

		COMMIT
	END

	SET @rc = @BatchSize

	WHILE @rc > 0
	BEGIN
		BEGIN TRAN

		DELETE TOP (@rc)
		FROM Vocabulary.VocabularyType WITH (ROWLOCK)
		WHERE NOT EXISTS (
				SELECT 1
				FROM Vocabulary.VocabularyType_Client WITH (READUNCOMMITTED)
				WHERE VocabularyTypeID = ID
				)
			AND NOT EXISTS (
				SELECT 1
				FROM Vocabulary.Vocabulary WITH (READUNCOMMITTED)
				WHERE VocabularyTypeID = ID
				)

		SET @rc = @@ROWCOUNT
		insert into #DebugInfo Values ('Delete VocabularyType',@rc)

		COMMIT
	END
------------------------------------Ausgabe DebugInfo	
	select *
	from #DebugInfo
----------------------------------------
END
GO
PRINT N'Creating [Helper].[usp_Add_Users]...';


GO
CREATE PROCEDURE [Helper].[usp_Add_Users]
	@mandantURN VARCHAR(128),
	@newUsers xml
AS
BEGIN

	DECLARE @xmlValue XML
	DECLARE @xmlTemp XML
	DECLARE @strvalue VARCHAR(500)

	-- aktuelle UserListe holen
	SELECT @xmlValue = va.Value
	FROM [Vocabulary].[VocabularyAttribute] va
	INNER JOIN [Vocabulary].[AttributeType] at ON va.AttributeTypeID = at.ID
		AND at.URN = N'urn:quibiq:epcis:atype:masteruser'
	INNER JOIN [Vocabulary].[Vocabulary] v ON v.ID = va.VocabularyID
	INNER JOIN [Vocabulary].[VocabularyType] vt ON v.VocabularyTypeID = vt.ID
		AND vt.URN = N'urn:quibiq:epcis:vtype:client'
		AND v.URN = @mandantURN

	-- Temp Tables wenn vorhanden löschen
	IF OBJECT_ID('tempdb..#oldT') IS NOT NULL
		DROP TABLE #oldT

	IF OBJECT_ID('tempdb..#newT') IS NOT NULL
		DROP TABLE #newT

	-- temporäre Tabelle für aktuelle User erstellen
	CREATE TABLE #oldT (
		x XML
		,username NVARCHAR(100)
		)
	
	-- aktuelle User als Xml und Text in intemporäre Tabelle
	INSERT INTO #oldT
	SELECT x.query('.')
		,x.value('.', 'nvarchar(100)') username
	FROM @xmlValue.nodes('/Value/*') AS XTbl(x)

	-- temporäre Tabelle für aktuelle User erstellen
	CREATE TABLE #newT (
		x XML
		,username NVARCHAR(100)
		)

	-- -- neue User als Xml und Text in intemporäre Tabelle
	INSERT INTO #newT
	SELECT x.query('.')
		,x.value('.', 'nvarchar(100)') username
	FROM @newUsers.nodes('*') AS XTbl(x)

	SET @strvalue = ''

	-- nur neue (nocht nicht verrechtet) selektieren und in einem String speichern
	SELECT @strvalue = @strvalue + COALESCE(cast(n.x AS VARCHAR(100)), '')
	FROM #newT n
	LEFT JOIN #oldT o ON n.username = o.username
	WHERE o.username IS NULL

	-- xmlString in XML convertieren
	SELECT @xmlTemp = cast(@strvalue AS XML)

	-- neue User zu den aktuellen Usern hinzufügen
	SET @xmlValue.modify('insert sql:variable("@xmlTemp") as last into (/Value)[1]')

	--SELECT @xmlValue

	-- aktuelles Attribut mit der neuen User Liste aktualisieren
	UPDATE va
	SET Value = @xmlValue
	FROM [Vocabulary].[VocabularyAttribute] va
	INNER JOIN [Vocabulary].[AttributeType] at ON va.AttributeTypeID = at.ID
		AND at.URN = N'urn:quibiq:epcis:atype:masteruser'
	INNER JOIN [Vocabulary].[Vocabulary] v ON v.ID = va.VocabularyID
	INNER JOIN [Vocabulary].[VocabularyType] vt ON v.VocabularyTypeID = vt.ID
		AND vt.URN = N'urn:quibiq:epcis:vtype:client'
		AND v.URN = @mandantURN

	RETURN 0
End
GO
PRINT N'Creating [Helper].[usp_Get_Record_Per_Day]...';


GO
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE Helper.usp_Get_Record_Per_Day 
	-- Add the parameters for the stored procedure here
	@STARTDATE DATE,
        @ENDDATE DATE,
		@TopCount INT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
	SELECT TOP(@TopCount) COUNT(*) AS Anzahl, FORMAT([RecordTime],'yyyy-MM-dd') AS [Tage]
	  
  FROM [Event].[EPCISEvent]
  WHERE [RecordTime] BETWEEN @STARTDATE AND @ENDDATE
  GROUP BY FORMAT([RecordTime],'yyyy-MM-dd')
  ORDER BY Anzahl DESC
  
END
GO
PRINT N'Creating [Helper].[usp_Get_Record_Per_Hour]...';


GO
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE Helper.usp_Get_Record_Per_Hour 
	-- Add the parameters for the stored procedure here
	@STARTDATE DATE,
        @ENDDATE DATE,
		@TopCount INT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
	SELECT TOP(@TopCount) COUNT(*) AS Anzahl, FORMAT([RecordTime],'yyyy-MM-dd hh') AS [Stunden]

  
  FROM [Event].[EPCISEvent]
  WHERE [RecordTime] BETWEEN @STARTDATE AND @ENDDATE
  GROUP BY FORMAT([RecordTime],'yyyy-MM-dd hh')
  ORDER BY Anzahl DESC
  
END
GO
PRINT N'Creating [Helper].[usp_Get_Record_Per_Minute]...';


GO
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE Helper.usp_Get_Record_Per_Minute 
	-- Add the parameters for the stored procedure here
	@STARTDATE DATE,
        @ENDDATE DATE,
		@TopCount INT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
	SELECT TOP(@TopCount) COUNT(*) AS Anzahl, FORMAT([RecordTime],'yyyy-MM-dd hh:mm') AS [Minuten]

  
  FROM [Event].[EPCISEvent]
  WHERE [RecordTime] BETWEEN @STARTDATE AND @ENDDATE
  GROUP BY FORMAT([RecordTime],'yyyy-MM-dd hh:mm')
  ORDER BY Anzahl DESC
  
END
GO
PRINT N'Creating [Helper].[usp_Get_Record_Per_Second]...';


GO
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE Helper.usp_Get_Record_Per_Second 
	-- Add the parameters for the stored procedure here
	@STARTDATE DATE,
        @ENDDATE DATE,
		@TopCount INT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
	SELECT TOP(@TopCount) COUNT(*) AS Anzahl, FORMAT([RecordTime],'yyyy-MM-dd hh:mm:ss') AS [Sekunden]

  
  FROM [Event].[EPCISEvent]
  WHERE [RecordTime] BETWEEN @STARTDATE AND @ENDDATE
  GROUP BY FORMAT([RecordTime],'yyyy-MM-dd hh:mm:ss')
  ORDER BY Anzahl DESC
  
END
GO
PRINT N'Creating [Import].[usp_write_error_log]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2012  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- Procedure fügt SQL-Error Informationen sowie eigene Fehler-Logs in die Fehlerlog-Tabelle
-- log.Error ein.
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 06.03.2013 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE PROCEDURE [Import].[usp_write_error_log](
	@AddInformation nvarchar(2048) = NULL,  --Optionale Information
	@ObjectID       bigint = 0				--Optionale Information indirekte Referenz auf PK des Fehlerobjekt
	)
AS
BEGIN
	SET NOCOUNT ON
	
	-- Speicher Error Eintrag
	INSERT INTO [Import].[Error] (
		[TimeStampGeneration]
		,[AdditionalInformation]
		,[ErrorNumber]
		,[ErrorSeverity]
		,[ErrorProcedure]
		,[ErrorMessage]
		,[ErrorLine]
		,[ErrorState]
		,[ObjectID] )
    SELECT
		getdate()								   as TimeStampGeneration
		,isnull(@AddInformation, 'none')		   as AdditionalInformation
        ,isnull(ERROR_NUMBER(), 0)				   as ErrorNumber
        ,isnull(ERROR_SEVERITY(), 0)			   as ErrorSeverity
        ,isnull(ERROR_PROCEDURE(), ' ')            as ErrorProcedure
		,isnull(ERROR_MESSAGE(), ' ')              as ErrorMessage
        ,isnull(ERROR_LINE(), 0)                   as ErrorLine
        ,isnull(ERROR_STATE(), 0)                  as ErrorState 
		,@ObjectID								   as ObjectID
	
	RETURN 0
END
GO
PRINT N'Creating [Import].[usp_Validate_Event]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2013  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 12.04.2013 | 1.0.0.0 | Leo Martens         | Erstellt.
-----------------------------------------------------------------------------------------
CREATE PROCEDURE [Import].[usp_Validate_Event]
	@Mandant nvarchar(max),
	@EPCISEvent xml,
	@ValidationResult nvarchar(max) out
AS
	SET @ValidationResult = null;

RETURN 0
GO
PRINT N'Creating [Import].[usp_Import_MergeVocabulary]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS1_1
-- Firma:    QUIBIQ
-- (c) 2015  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 17.02.2015 | 1.0.0.0 | Florian Wagner      | Merged Vocabulary Element
-----------------------------------------------------------------------------------------
CREATE PROCEDURE [Import].[usp_Import_MergeVocabulary]
	@VocabularyURN    nvarchar (512),
	@VocabularyTypeID bigint,
	@ClientID         bigint
AS
BEGIN

		merge into Vocabulary.Vocabulary WITH (HOLDLOCK) as target
		using ( select 
					 @VocabularyURN as VocabularyURN
					,@VocabularyTypeID as VocabularyTypeID
					,@ClientID as ClientID
		) as source
		on target.URN                = source.VocabularyURN and
		   target.VocabularyTypeID   = source.VocabularyTypeID and
		   target.ClientID           = source.ClientID
			when matched then
				update set Deleted = 0
		when not matched by target then
			insert (ClientID, VocabularyTypeID, URN) 
			values (source.ClientID, source.VocabularyTypeID, source.VocabularyURN);

	    select 
			ID,
			URN,
			VocabularyTypeID,
			ClientID
		from 
			Vocabulary.Vocabulary
		where URN = @VocabularyURN and VocabularyTypeID = @VocabularyTypeID and ClientID = @ClientID;

END;
GO
PRINT N'Creating [Import].[usp_Import_MergeTransformation]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS1_1
-- Firma:    QUIBIQ
-- (c) 2015  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 17.02.2015 | 1.0.0.0 | Florian Wagner      | Merged Transformation
-----------------------------------------------------------------------------------------
CREATE PROCEDURE [Import].[usp_Import_MergeTransformation]
	@TransformationURN  nvarchar(512)
AS
BEGIN

		merge into Event.TransformationID WITH (HOLDLOCK) as target					
		using (	select 
					@TransformationURN as TransformationIDURN
			) as source
		on target.URN = source.TransformationIDURN
		when not matched by target then
			insert (URN)
				values (source.TransformationIDURN);


	    select 
			ID,
			URN 
		from 
			Event.TransformationID
		where URN = @TransformationURN;

END;
GO
PRINT N'Creating [Import].[usp_Import_MergeStringValue]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS1_1
-- Firma:    QUIBIQ
-- (c) 2015  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 17.02.2015 | 1.0.0.0 | Florian Wagner      | Merged String Value
-----------------------------------------------------------------------------------------
CREATE PROCEDURE [Import].[usp_Import_MergeStringValue]
	@StringValue    nvarchar(1024)
AS
BEGIN

		merge into Event.Value_String WITH (HOLDLOCK) as target			
		using ( select 
					   @StringValue as Value
				)
		as source
		on 
		  target.Value              = source.Value 
		when not matched by target then
			insert (Value) 
			values (source.Value);

	    select 
			ID,
			Value
		from 
			Event.Value_String
		where Value = @StringValue;

END;
GO
PRINT N'Creating [Import].[usp_Import_MergeQuantityElement]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS1_1
-- Firma:    QUIBIQ
-- (c) 2015  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 17.02.2015 | 1.0.0.0 | Florian Wagner      | Merged Quantity Element
-----------------------------------------------------------------------------------------
CREATE PROCEDURE [Import].[usp_Import_MergeQuantityElement]
	@EPCClassID  bigint,
	@Quantity    float,
	@UOM		 nchar(3)
AS
BEGIN

		merge into Event.QuantityElement WITH (HOLDLOCK) as target					
		using (	select 
					@EPCClassID as EPCClassID, @Quantity as Quantity, @UOM as UOM 
			) as source
		on target.EPCClassID = source.EPCClassID and target.Quantity = source.Quantity and target.UOM = source.UOM
		when not matched by target then
			insert (EPCClassID, Quantity, UOM)
				values (source.EPCClassID, source.Quantity, source.UOM);


	    select 
			ID,
			EPCClassID,
			Quantity,
			UOM
		from 
			Event.QuantityElement
		where EPCClassID = @EPCClassID and Quantity = @Quantity and UOM = @UOM;

END;
GO
PRINT N'Creating [Import].[usp_Import_MergeEPC]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS1_1
-- Firma:    QUIBIQ
-- (c) 2015  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 17.02.2015 | 1.0.0.0 | Florian Wagner      | Merged EPCs
-----------------------------------------------------------------------------------------
CREATE PROCEDURE [Import].[usp_Import_MergeEPC]
	@URN nvarchar(512)
AS
BEGIN

		merge into Event.EPC WITH (HOLDLOCK) as target									
		using (select @URN as EPCURN ) as source
		on target.URN = source.EPCURN
		when not matched by target then
			insert(URN)
				values (source.EPCURN);

	    select 
			ID,
			URN 
		from 
			Event.EPC
		where URN = @URN;

END;
GO
PRINT N'Creating [Import].[usp_Import_MergeBusinessTransaction]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS1_1
-- Firma:    QUIBIQ
-- (c) 2015  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 17.02.2015 | 1.0.0.0 | Florian Wagner      | Merged BusinessTransaction
-----------------------------------------------------------------------------------------
CREATE PROCEDURE [Import].[usp_Import_MergeBusinessTransaction]
	@BusinessTransactionIDURN  nvarchar(512),
	@BusinessTransactionTypeID bigint
AS
BEGIN

		merge into Event.BusinessTransactionID WITH (HOLDLOCK) as target			
		using (	select 
					@BusinessTransactionTypeID as BusinessTransactionTypeID, @BusinessTransactionIDURN as BusinessTransactionIDURN 
			) as source
		on target.BusinessTransactionTypeID = source.BusinessTransactionTypeID and target.URN = source.BusinessTransactionIDURN
		when not matched by target then
			insert (URN, BusinessTransactionTypeID)
				values (source.BusinessTransactionIDURN, source.BusinessTransactionTypeID);

	    select 
			ID,
			URN,
			BusinessTransactionTypeID 
		from 
			Event.BusinessTransactionID
		where URN = @BusinessTransactionIDURN and BusinessTransactionTypeID = @BusinessTransactionTypeID;

END;
GO
PRINT N'Creating [Import].[usp_Import_MasterData]...';


GO

-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2013  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 21.02.2013 | 1.0.0.0 | Sven Scholle	      | Erstellt.
-----------------------------------------------------------------------------------------
-- 21.07.2014 | 1.0.2.0 | Florian Wagner      | FLW001 - Nur als nicht gelöscht markierte Stammdaten verwenden
-----------------------------------------------------------------------------------------
CREATE procedure [Import].[usp_Import_MasterData] 
	@EPCISMasterData		xml, 
	@Client					nvarchar(512)
as
begin

	set nocount on

	--***************************************************************
	-- Variablendeklaration für gesamt SP:
	--***************************************************************

	declare 
		--@EPCISMasterData_QueueID bigint,
		@SystemClientID			bigint,
		@ClientID				bigint,
		@ContentTypeID			bigint,

		@VocabularyList			xml,
		@Vocabulary				xml,	
		@VocabularyType			nvarchar(512),
		@VocabularyTypeID		bigint,
		@MaxOccurs				int,
		@DeletedFlag			bit,																--FLW001+

		@VocabularyElementList	xml,
		@VocabularyElement		xml,
		@VocabularyElementID	bigint,
		@VocabularyElementurn	nvarchar(512);
	
	--***************************************************************
	-- Tabelle zum Zwischenspeichern der hierachischen Vokabeln, da IDs erst bekannt sind,
	-- wenn alles andere vorher eingetragen ist.
	--***************************************************************

	if object_id('tempdb..#VocabularyChildren') is not null drop table #VocabularyChildren
	create table #VocabularyChildren
	(
		VocabularyParentURN	nvarchar(512)	not null,
		VocabularyChildURN	nvarchar(512)	not null,
		ParentVocabularyID	bigint			null,
		ChildVocabularyID	bigint			null,
		Deleted				bit				not null default 0										--FLW001+
	)

	--select TOP 1
	--	@EPCISMasterData = EPCISMasterData,
	--	@Client = Client,
	--	@EPCISMasterData_QueueID = ID
	--from 
	--	Import.EPCISMasterData_Queue
	--where
	--	Processed = 0 and Error = 0

	--***************************************************************
	-- MandantenID bestimmen
	--***************************************************************

	set @ClientID = 0

	select TOP 1
		@ClientID       = ClientID,
		@SystemClientID = SystemClientID
	from [Import].[tvf_get_ClientID] (@Client);

	if @ClientID = 0
	begin
		--***************************************************************
		-- Fehler werfen, falls Mandant nicht gefunden
		--***************************************************************

		declare @msg nvarchar(2048) = 'Mandant ''' + @Client + ''' does not exist.';
		throw 50000, @msg, 1

	end;

	--begin try

	--	begin transaction;

		--***************************************************************
		-- Liste der Vokabeln laden
		--***************************************************************
		with xmlnamespaces (N'urn:epcglobal:epcis-masterdata:xsd:1' as epcismd, N'urn:quibiq:epcis:md' as quibiqmd)		--FLW001~
		select
			@VocabularyList = @EPCISMasterData.query(N'/epcismd:EPCISMasterDataDocument/EPCISBody/VocabularyList/.');

		--***************************************************************
		-- per Schleife durch Liste aller Vokabeln durcharbeiten
		--***************************************************************
		declare curVocabulary cursor for
			select
				content.nodes.query(N'.')
			from
				@VocabularyList.nodes(N'/*/*/.') as content(nodes)

		open curVocabulary

		fetch next from curVocabulary into @Vocabulary

		while @@FETCH_STATUS = 0
		begin

			--select @Vocabulary as 'Vocabulary'
			--***************************************************************
			-- Vokabeltyp auslesen
			--***************************************************************

			select @VocabularyType = @Vocabulary.value(N'(/Vocabulary/@type)[1]', 'nvarchar(512)')
			-->FLW001 INSERT START
			-- Ermitteln des gelöscht Status 
			;with xmlnamespaces (N'urn:epcglobal:epcis-masterdata:xsd:1' as epcismd, N'urn:quibiq:epcis:md' as quibiqmd)
			select @DeletedFlag = @Vocabulary.value(N'(/Vocabulary/@quibiqmd:delete)[1]', 'bit')						
			if (@DeletedFlag is null) SET @DeletedFlag = 0;
			--<FLW001 INSERT END	
			
			select @MaxOccurs = 1

			--***************************************************************
			-- ID von VokabelTyp bestimmen (falls nicht vorhanden --> eintragen)
			--***************************************************************

			set @VocabularyTypeID = 0

			select
				@VocabularyTypeID = ID
			from
				Vocabulary.VocabularyType
			where
				URN = @VocabularyType

			if @VocabularyTypeID = 0
			begin
				--***************************************************************
				-- VokabelTyp nicht vorhanden --> eintragen
				--***************************************************************
	
				Insert into 
					Vocabulary.VocabularyType (URN, Description, MaxOccurs)
				values
					(@VocabularyType, '', @MaxOccurs)

				set @VocabularyTypeID = SCOPE_IDENTITY();

			end

			-->FLW001 INSERT START
			-- Eintragen der Verknüpfung Mandant zu Vokabular
			IF not exists (select top 1 1 from Vocabulary.VocabularyType_Client where VocabularyTypeID = @VocabularyTypeID and ClientID = @ClientID)
			BEGIN			
				INSERT INTO
					Vocabulary.VocabularyType_Client (VocabularyTypeID, ClientID) 
				VALUES (@VocabularyTypeID, @ClientID);
			END;

			-- Aktualisieren des Status des Vokabulars
			UPDATE Vocabulary.VocabularyType_Client 
			   SET Deleted = @DeletedFlag
			 WHERE VocabularyTypeID = @VocabularyTypeID and ClientID = @ClientID;

			-- Aktualisieren des Status der VokabularElemente
			--IF @DeletedFlag = 1
			--BEGIN
			--	UPDATE Vocabulary.Vocabulary
			--	   SET Deleted = @DeletedFlag
			--	WHERE ClientID = @ClientID and VocabularyTypeID = @VocabularyTypeID;
			--END;
			--<FLW001 INSERT END

			--***************************************************************
			-- Liste der Vokabelelemente laden
			--***************************************************************

			select
				@VocabularyElementList = @Vocabulary.query(N'/Vocabulary/VocabularyElementList/.');


			--***************************************************************
			-- per Schleife durch Liste aller VokabelElement durcharbeiten
			--***************************************************************
			declare curVocabularyElement cursor for
				select
					content.nodes.query(N'.')
				from
					@VocabularyElementList.nodes(N'/*/*/.') as content(nodes)

			open curVocabularyElement

			fetch next from curVocabularyElement into @VocabularyElement

			while @@FETCH_STATUS = 0
			begin

				--select @VocabularyElement as 'VocabularyElement'
				--***************************************************************
				-- Vokabelelementurn auslesen
				--***************************************************************

				select @VocabularyElementurn = @VocabularyElement.value(N'(/VocabularyElement/@id)[1]', 'nvarchar(512)')	
				-->FLW001 INSERT START
				-- Ermitteln des gelöscht Status, wenn das Vokabular als nicht gelöscht markiert ist			
				IF @DeletedFlag = 0
				BEGIN
					;with xmlnamespaces (N'urn:epcglobal:epcis-masterdata:xsd:1' as epcismd, N'urn:quibiq:epcis:md' as quibiqmd)
					select @DeletedFlag          = @VocabularyElement.value(N'(/VocabularyElement/@quibiqmd:delete)[1]', 'bit')	
					if (@DeletedFlag is null) SET @DeletedFlag = 0;
				END;
				--<FLW001 INSERT END			
					
				--***************************************************************
				-- ID von VokabelElementurn bestimmen (falls nicht vorhanden --> eintragen)
				--***************************************************************

				set @VocabularyElementID = 0

				select 
					@VocabularyElementID = ID
				from
					Vocabulary.Vocabulary
				where
					URN      = @VocabularyElementurn
				and VocabularyTypeID = @VocabularyTypeID																	--FLW001+
				and ClientID = @ClientID;

				if @VocabularyElementID = 0
				begin
					--***************************************************************
					-- VokabelElementurn nicht vorhanden --> eintragen
					--***************************************************************
			
					Insert into 
						Vocabulary.Vocabulary (ClientID, VocabularyTypeID, URN)
					values
						(@ClientID, @VocabularyTypeID ,@VocabularyElementurn)

					set @VocabularyElementID = SCOPE_IDENTITY();

				end

				-->FLW001 INSERT START
				-- Aktualisieren des gelöscht Status des Vokabularelements
				UPDATE Vocabulary.Vocabulary 
				   SET Deleted = @DeletedFlag
				 WHERE ID = @VocabularyElementID and ClientID = @ClientID;
				--<FLW001 INSERT END

				--***************************************************************
				-- Alle Attribute zum Vokabelelement laden und zwischenspeichern
				--***************************************************************

				if object_id('tempdb..#VocabularyAttribute') is not null drop table #VocabularyAttribute
				
				create table #VocabularyAttribute
				(
					VocabularyID		bigint			not null,
					AttributeTypeID		bigint			null,
					[XML]				xml				not null,
					AttributeTypeURN	nvarchar(512)	null,
					Value				xml				null,
					ContentTypeID		bigint			null
					,Deleted			bit				not null DEFAULT 0								--FLW001+
				)

				select top 1
					@ContentTypeID = v.ID
				from
					 Vocabulary.Vocabulary     v  
				join Vocabulary.VocabularyType vt on v.VocabularyTypeID = vt.ID
				where
					v.URN      = N'urn:quibiq:epcis:cbv:datatype:unknown'
				and vt.URN     = N'urn:quibiq:epcis:vtype:datatype'
				and v.ClientID = @SystemClientID

				--<FLW001 MODIFY START
				;with xmlnamespaces (N'urn:epcglobal:epcis-masterdata:xsd:1' as epcismd, N'urn:quibiq:epcis:md' as quibiqmd)
				insert into #VocabularyAttribute (VocabularyID, [XML], ContentTypeID, Deleted)
				select
					@VocabularyElementID,
					content.nodes.query(N'.') as [xml],
					@ContentTypeID,
					ISNULL(content.nodes.value(N'(./@quibiqmd:delete)[1]', 'bit'), 0)	
				from
					@VocabularyElement.nodes(N'/*/attribute/.') as content(nodes);		
				--<FLW001 MODIFY END

				--***************************************************************
				-- Aufbereiten der Attribute, z.B. Formatieren, Fremdschlüssel bestimmen etc.
				--***************************************************************

				-- Erst die Values die eine XMl-Struktur darstellen

				update
					#VocabularyAttribute
				set
					AttributeTypeURN = [XML].value(N'(/attribute/@id)[1]', 'nvarchar(512)'),
					Value =
					(				
						select
							[XML].query(N'if (fn:empty(/*/*))
											then
											  /*/text()
											else
											  /*/*
											 ')
						for xml path(''), root('Value')
					)
			
				merge into Vocabulary.AttributeType as target
				using #VocabularyAttribute as source
				on target.URN = source.AttributeTypeURN
				when not matched by target then
					insert (URN, Description, ContentTypeID)
						values (source.AttributeTypeURN, '', source.ContentTypeID);

				update
					va
				set
					va.AttributeTypeID = at.ID
				from
					#VocabularyAttribute va
				inner join
					Vocabulary.AttributeType at on at.URN = va.AttributeTypeURN

				--select
				--	*
				--from
				--	#VocabularyAttribute


				merge into Vocabulary.VocabularyAttribute as target
				using #VocabularyAttribute as source
				on target.VocabularyID = source.VocabularyID and target.AttributeTypeID = source.AttributeTypeID
				when matched then
					update set Value = source.Value, Deleted = source.Deleted					--FLW001~
				when not matched by target then
					insert (VocabularyID, AttributeTypeID, Value)
						values (source.VocabularyID, source.AttributeTypeID, source.Value);
			
				drop table #VocabularyAttribute


				--***************************************************************
				-- Alle Children zum Vokabelelement laden und zwischenspeichern
				--***************************************************************

				insert into #VocabularyChildren (VocabularyParentURN, ParentVocabularyID, VocabularyChildURN)
				select
					@VocabularyElementurn,
					@VocabularyElementID,
					content.nodes.query(N'.').value(N'(/id/node())[1]', 'nvarchar(max)')
				from
					@VocabularyElement.nodes(N'/*/children/id/.') as content(nodes);		

				-->FLW001 INSERT START
				-- Aktualisieren des gelöscht Status des Childelements (wegen Schema nicht via Attribut möglich)
				update vc
				set Deleted = 1, VocabularyChildURN = REPLACE ( VocabularyChildURN , N'urn:quibiq:epcis:md:delete#' , N'' )
				from #VocabularyChildren vc
				where vc.VocabularyChildURN like N'urn:quibiq:epcis:md:delete#%' and ISNULL(ParentVocabularyID, -1) = @VocabularyElementID;

				-- Wenn Element gelöscht wird auch alle Childs löschen
				--IF @DeletedFlag = 1 
				--BEGIN
				--	update #VocabularyChildren
				--	set Deleted = 1
				--	where ParentVocabularyID = @VocabularyElementID;
				--END;
				--<FLW001 INSERT END
				
				fetch next from curVocabularyElement into @VocabularyElement

			end

			close curVocabularyElement
			deallocate curVocabularyElement

			fetch next from curVocabulary into @Vocabulary
		end

		close curVocabulary
		deallocate curVocabulary

		--***************************************************************
		-- Zu allen ChildrenURN die zugehörigen IDs bestimmen
		--***************************************************************

		update 
			vc
		set
			vc.ChildVocabularyID = v.ID
		from
			#VocabularyChildren vc
		inner join
			Vocabulary.Vocabulary v on v.URN = vc.VocabularyChildURN and v.ClientID = @ClientID						--FLW001~

		--***************************************************************
		-- Eintragen der Children
		--***************************************************************

		merge into Vocabulary.VocabularyChildren as target
		using #VocabularyChildren as source
		on target.VocabularyID = source.ParentVocabularyID and target.ChildVocabularyID = source.ChildVocabularyID
		-->FLW001 MODIFY START
		when matched 
			then update set Deleted = source.Deleted
		when not matched by target
			then insert (VocabularyID, ChildVocabularyID, Deleted)
				values (source.ParentVocabularyID, source.ChildVocabularyID, source.Deleted);
		-->FLW001 MODIFY END

		--select 
		--	*
		--from
		--	#VocabularyChildren

		drop table #VocabularyChildren

		--update
		--	Import.EPCISMasterData_Queue
		--set
		--	Processed = 1
		--where
		--	ID = @EPCISMasterData_QueueID
		--delete from
		--	Import.EPCISMasterData_Queue
		--where 
		--	ID = @EPCISMasterData_QueueID;

	--	commit Transaction;

	--end try

	--begin catch
		
	--	rollback transaction;

	--	update
	--		Import.EPCISMasterData_Queue
	--	set
	--		Error = 1
	--	where
	--		ID = @EPCISMasterData_QueueID

	--	exec [Import].[usp_write_error_log] 
	--		@AddInformation = N'ObjectID: MasterData_Queue',
	--		@ObjectID = @EPCISMasterData_QueueID;


	--end catch
end
GO
PRINT N'Creating [Import].[usp_Import_Event]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2013  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 27.02.2013 | 1.0.0.0 | Sven Scholle	      | Erstellt.
-----------------------------------------------------------------------------------------
-- 10.04.2014 | 1.0.0.1 | Florian Wagner      | FLW001 - HOLDLOCK an BusinessTransactionID, String_Value, EPC Merge
-----------------------------------------------------------------------------------------
-- 13.05.2014 | 1.0.1.0 | Florian Wagner      | FLW002 - Mandant bei Stammdaten Merge verwenden
-----------------------------------------------------------------------------------------
-- 21.07.2014 | 1.0.2.0 | Florian Wagner      | FLW003 - Nur als nicht gelöscht markierte Stammdaten verwenden
-----------------------------------------------------------------------------------------
-- 30.01.2015 | 2.0.0.0 | Florian Wagner      | FLW004 - EPCIS 1_1 Erweiterungen
-----------------------------------------------------------------------------------------
CREATE PROCEDURE [Import].[usp_Import_Event]
		@EPCISEvent			xml,
		@Client             nvarchar(512),
		@Debug				bit = 0,
		@RecordTime			datetime2 output
AS
BEGIN

	-----------------------------------------------------------------
	-- Variablendeklaration 
	-----------------------------------------------------------------

	declare
		@Error							bit = 0,
		@ErrorMsg						nvarchar(2048), 

		@AddNewVocabulary				bit = 0,
		@AddBizLocAndReadPoints			bit = 1, 
		@AddEPCClass					bit = 1,
		@AddSourceDestination			bit = 1,
		@ProcessOnlyWholeDocument		bit = 1,  

		@EPCISEventList					xml,
		@CurEvent						xml,
		@StandardBusinessDocumentHeader	xml,

		@SystemClientID					bigint,  -- SystemclientID
		@ClientID						bigint;  -- Client ID


		-----------------------------------------------------------------
		-- Tabelle zum Zwischenspeichern der Wurzel-Event Daten
		-----------------------------------------------------------------

		create table #EventData
		(
			EPCISEventID			bigint			   not null PRIMARY KEY IDENTITY(1,1),
			[ClientID]              BIGINT             NOT NULL,
			[EventTime]             DATETIME2 (0)      NOT NULL,
			[RecordTime]            DATETIME2 (0)      NOT NULL,
			[EventTimeZoneOffset]   DATETIMEOFFSET (7) NOT NULL,
			[EPCISRepresentation]   XML                NOT NULL
		);

		-----------------------------------------------------------------
		-- Mapping-Tabelle zwischen SP und Tabellen EPCISEventID
		-----------------------------------------------------------------

		create table #EPCISEventIDs
		(
			EPCISEventID		   bigint		not null PRIMARY KEY,
			TechnicalEPCISEventID  bigint       not null
		);

		-----------------------------------------------------------------
		-- Tabelle zum Zwischenspeichern der hierachischen Vokabeln, da IDs erst bekannt sind,
		-- wenn alles andere vorher eingetragen ist.
		-----------------------------------------------------------------

		create table #EPCISEvent_Vocabulary
		(
			VocabularyTypeURN	nvarchar(512)	not null,
			VocabularyURN		nvarchar(512)	not null,
			VocabularyTypeID	bigint			null,
			ID					bigint			null,
			EPCISEventID		bigint			not null
		);


		-----------------------------------------------------------------
		-- Tabelle zum Zwischenspeichern der EPCs
		-----------------------------------------------------------------
	
		create table #EPCISEvent_EPC
		(
			EPCURN			nvarchar(512)	not null,
			EPCID			bigint			null,
			EPCISEventID	bigint			not null,
			IsParentID		bit				not null,
			IsInput			bit				not null,
			IsOutput		bit				not null,
		);


		-----------------------------------------------------------------
		-- Tabelle zum Zwischenspeichern der BusinessTransactions
		-----------------------------------------------------------------
	
		create table #EPCISEvent_BusinessTransactionID
		(
			BusinessTransactionIDURN	nvarchar(512)	not null,
			BusinessTransactionTypeURN	nvarchar(512)	not null,
			VocabularyTypeURN			nvarchar(512)	not null,
			BusinessTransactionIDID		bigint			null,
			BusinessTransactionTypeID	bigint			null,
			VocabularyTypeID			bigint			null,
			EPCISEventID				bigint			not null
		);

		-----------------------------------------------------------------
		-- Tabelle zum Zwischenspeichern der QuantityElements
		-----------------------------------------------------------------

		create table #EPCISEvent_QuantityElement
		(
			EPCISEventID			bigint			not null,
			EPCClassURN				nvarchar(512)	not null,
			EPCClassID				bigint			null,
			Quantity				float(53)		not null,
			UOM						nchar(3)		not null default (''),
			IsInput					bit				not null,
			IsOutput				bit				not null,
			QuantityElementID		bigint			null,
		);

		-----------------------------------------------------------------
		-- Tabelle zum Zwischenspeichern der SourceDestination
		-----------------------------------------------------------------

		create table #EPCISEvent_SourceDestination
		(
			EPCISEventID				bigint		  not null,
			IsSource					bit			  not null,
			SourceDestinationURN		nvarchar(512) not null,
			SourceDestinationTypeURN	nvarchar(512) not null,
			SourceDestinationID			bigint		  null,
			SourceDestinationTypeID		bigint		  null,
		);

		-----------------------------------------------------------------
		-- Tabelle zum Zwischenspeichern der TransformationID
		-----------------------------------------------------------------

		create table #EPCISEvent_TransformationID
		(
			EPCISEventID				bigint		  not null,
			TransformationIDURN			nvarchar(512) not null,
			TransformationIDID			bigint		  null,
		);

		-----------------------------------------------------------------
		-- Tabelle zum Zwischenspeichern der Extension-Typen wie
		-----------------------------------------------------------------

		create table #EPCISEvent_ExtenstionType
		(
			EPCISEventID		 bigint			not null,
			ExtensionTypeURN	 nvarchar(512)	not null,
			ExtensionTypeTypeURN nvarchar(512)	not null
		);

		-----------------------------------------------------------------
		-- Tabelle zum Zwischenspeichern der Values wie z.B. quantity und extension fields
		-----------------------------------------------------------------

		create table #EPCISEvent_Value
		(
			ValueTypeURN		nvarchar(512)	not null,
			ValueTypeTypeURN	nvarchar(512)	not null,
			DataTypeURN			nvarchar(512)	not null,
			DataTypeTypeURN		nvarchar(512)	not null,
			ValueTypeID			bigint			null,
			ValueTypeTypeID		bigint			null,
			DataTypeID			bigint			null,
			DataTypeTypeID		bigint			null,
			EPCISEventID		bigint			not null,
			IntValue			bigint			null,
			FloatValue			float			null,
			TimeValue			datetimeoffset	null,
			StringValue 		nvarchar(max)	null,
			ParentURN			nvarchar(512)	null,
			Depth				int				not null,
			ExtensionType       bit             not null
		);


		create table #EPCISEvent_Value_Values
		(
			EPCISEvent_ValueID					bigint         not null,
			ValueTypeURN						nvarchar(512)	not null,
			DataTypeURN							nvarchar(512)	not null,
			IntValue							bigint			null,
			FloatValue							float			null,
			TimeValue							datetimeoffset	null,
			StringValue 						nvarchar(max)	null,
			ParentURN							nvarchar(512)	not null,
			Parent_EPCISEvent_ValueID			bigint			null,
			Depth								int				not null
		);

		create table #EPCISEvent_Value_String_Value_String
		(
			EPCISEvent_ValueID  bigint       not null,
			Value_StringID		bigint      not null
		);



		-----------------------------------------------------------------
		-- Tabelle zum Zwischenspeichern von Eventfehlerklassen
		-----------------------------------------------------------------
		create table #EPCISEvent_Error
		(
			EPCISEventID	 bigint			 not null,
			Reason		 	 nvarchar(4000)  not null
		);

		--***************************************************************
		-- MandantenID bestimmen
		--***************************************************************

		set @ClientID = 0

		select TOP 1
			@ClientID       = ClientID,
			@SystemClientID = SystemClientID
		from [Import].[tvf_get_ClientID] (@Client);

		if @ClientID = 0
		begin
			--***************************************************************
			-- Fehler werfen, falls Mandant nicht gefunden
			--***************************************************************

			set @ErrorMsg = 'Mandant ''' + @Client + ''' does not exist.';
			throw 50000, @ErrorMsg, 1

		end;

		--***************************************************************
		-- Header laden
		--***************************************************************

		with xmlnamespaces (N'urn:epcglobal:epcis:xsd:1' as epcg)
		select
			@StandardBusinessDocumentHeader = @EPCISEvent.query(N'/epcg:EPCISDocument/EPCISHeader/*');

		--***************************************************************
		-- Liste der Events laden
		--***************************************************************
		with xmlnamespaces (N'urn:epcglobal:epcis:xsd:1' as epcg)
		select
			@EPCISEventList = @EPCISEvent.query(N'/epcg:EPCISDocument/EPCISBody/EventList/.');

		--***************************************************************
		-- per Schleife durch Liste aller Events durcharbeiten
		--***************************************************************
		declare curEvent INSENSITIVE cursor for
			select
				content.nodes.query(N'.')
			from
				@EPCISEventList.nodes(N'/*/*/.') as content(nodes);

		open curEvent

		fetch next from curEvent into @CurEvent

		while @@FETCH_STATUS = 0
		begin

			--***************************************************************
			-- Scope Declarations
			--***************************************************************
				declare
					@xmlPath				nvarchar(max),
					@EPCISEPCISEventID		bigint,
					@EPCISEventTime			datetime2(7),
					@EPCISEventTimeZoneOffset	datetimeoffset,	
					@EPCISEventTimeString   nvarchar(50),

					@EPCISEventTypePath		nvarchar(128),
					@ValueTypeURN			nvarchar(512),
					@DataTypeURN			nvarchar(512),
					@ValueTypeTypeURN		nvarchar(512),
					@DataTypeTypeURN		nvarchar(512),
					@IntValue				int,
					@CharValue				nvarchar(512),
		
					@IsOutput				bit,
					@EPCList				xml,
					@EPCURN					nvarchar(512),
					@BizTransactionList		xml,
					@XmlList				xml,

					@VocabularyTypeURN		nvarchar(512),
					@VocabularyURN			nvarchar(512);

				declare @OutputEPCISEventID table (
					ID bigint
				);
			
			--***************************************************************
			-- EventTyp auslesen um xmlPath bauen zu können
			--***************************************************************

			select
				@EPCISEventTypePath= cast(@CurEvent.query('local-name((/*)[1])') as nvarchar(128))	

			--***************************************************************
			-- EPCIS 1.1 TransformationEvent - Sonderbehandlung - (Liegt unter extension)
			--***************************************************************

			if (@EPCISEventTypePath = N'extension')
			begin
				SET @CurEvent = @CurEvent.query(N'/extension/*');

				select
					@EPCISEventTypePath= cast(@CurEvent.query('local-name((/*)[1])') as nvarchar(128))	
			end;

			--***************************************************************
			-- EventTime und -ZoneOffset auslesen
			--***************************************************************
			
			--select @EPCISEventTime = @CurEvent.value('(/*[local-name()= sql:variable("@EPCISEventTypePath")]/eventTime/node())[1]', 'datetime2(7)');
			--select @EPCISEventTimeZoneOffset = SWITCHOFFSET(convert(datetimeoffset, @EPCISEventTime), @CurEvent.value('(//eventTimeZoneOffset/node())[1]', 'varchar(6)'));

			select @EPCISEventTimeString = @CurEvent.value('(/*[local-name()= sql:variable("@EPCISEventTypePath")]/eventTime/node())[1]', 'nvarchar(50)');

			if @EPCISEventTimeString not like N'%Z%' and
			   @EPCISEventTimeString not like N'%+%' and
			   @EPCISEventTimeString not like N'%-%'
			BEGIN

				select @EPCISEventTimeZoneOffset = convert(datetimeoffset, @CurEvent.value('(/*[local-name()= sql:variable("@EPCISEventTypePath")]/eventTime/node())[1]', 'nvarchar(50)') + @CurEvent.value('(/*[local-name()= sql:variable("@EPCISEventTypePath")]/eventTimeZoneOffset/node())[1]', 'nvarchar(6)'));
				select @EPCISEventTime = convert(datetime2(7), SWITCHOFFSET(@EPCISEventTimeZoneOffset, '+00:00'));

			END
			ELSE
			BEGIN

				select @EPCISEventTime = @CurEvent.value('(/*[local-name()= sql:variable("@EPCISEventTypePath")]/eventTime/node())[1]', 'datetime2(7)');
				select @EPCISEventTimeZoneOffset = SWITCHOFFSET(convert(datetimeoffset, @EPCISEventTime), @CurEvent.value('(//eventTimeZoneOffset/node())[1]', 'varchar(6)'));

			END;

			--***************************************************************
			-- EinzelEvent speichern
			--***************************************************************
			SET @RecordTime	= cast(getdate() as datetime2(0));

			insert into #EventData 
				(ClientID, 
				 EventTime, 
				 RecordTime, 
				 EventTimeZoneOffset, 
				 [EPCISRepresentation])
			OUTPUT inserted.EPCISEventID INTO @OutputEPCISEventID
			values (
				@ClientID,
				cast(@EPCISEventTime as datetime2(0)),
				@RecordTime,
				@EPCISEventTimeZoneOffset,
				@CurEvent
				);

			select TOP 1 @EPCISEPCISEventID = ID FROM @OutputEPCISEventID;
			delete from @OutputEPCISEventID;

			--***************************************************************
			-- Zwischentabelle befüllen mit Vokabelnamen und -typen für alle 
			-- unverarbeiteten Events um später die IDs auf einmal bestimmen
			-- zu können
			--***************************************************************

			--***************************************************************
			-- EventTyp auslesen, xmlPath bauen zu können
			--***************************************************************

			select
				@EPCISEventTypePath= cast(@CurEvent.query('local-name((/*)[1])') as nvarchar(128))	

			--***************************************************************
			-- EventVokabel zwischenspeichern
			--***************************************************************
			select
				@VocabularyTypeURN = N'urn:quibiq:epcis:vtype:event',
				@VocabularyURN = N'urn:quibiq:epcis:cbv:event:' + lower(replace(@EPCISEventTypePath, 'Event', ''))

			insert into #EPCISEvent_Vocabulary (VocabularyTypeURN, VocabularyURN, EPCISEventID)
				values (@VocabularyTypeURN, @VocabularyURN, @EPCISEPCISEventID)

			--***************************************************************
			-- EPCList
			--***************************************************************
	
			select
				@EPCList = @CurEvent.query(N'/*[local-name()= sql:variable("@EPCISEventTypePath")]/epcList/./.');

			insert into #EPCISEvent_EPC (EPCURN, EPCISEventID, IsParentID, IsInput, IsOutput)
			select
				REPLACE(content.nodes.query(N'.').value('(/epc/.)[1]', 'nvarchar(512)'), N' ', N'') as EPCURN,
				@EPCISEPCISEventID,
				0  as IsParent,
				0  as IsInput,
				0  as IsOutput
			from
				@EPCList.nodes(N'/*/*/.') as content(nodes)		

			--***************************************************************
			-- IsParent
			--***************************************************************
	
			select		
				@EPCURN = REPLACE(@CurEvent.value('(/*[local-name()= sql:variable("@EPCISEventTypePath")]/parentID/node())[1]', 'nvarchar(512)'), N' ', N'');

			if @EPCURN is not null 
			begin
				insert into #EPCISEvent_EPC (EPCURN, EPCISEventID, IsParentID, IsInput, IsOutput)
					values (@EPCURN, @EPCISEPCISEventID, 1, 0, 0)
			end

			--***************************************************************
			-- IsInput
			--***************************************************************
	
			select
				@EPCList = @CurEvent.query(N'/*[local-name()= sql:variable("@EPCISEventTypePath")]/inputEPCList/./.');

			insert into #EPCISEvent_EPC (EPCURN, EPCISEventID, IsParentID, IsInput, IsOutput)
			select
				REPLACE(content.nodes.query(N'.').value('(/epc/.)[1]', 'nvarchar(512)'), N' ', N'') as EPCURN,
				@EPCISEPCISEventID,
				0  as IsParent,
				1  as IsInput,
				0  as IsOutput
			from
				@EPCList.nodes(N'/*/*/.') as content(nodes)		


			--***************************************************************
			-- IsOutput
			--***************************************************************
	
			select
				@EPCList = @CurEvent.query(N'/*[local-name()= sql:variable("@EPCISEventTypePath")]/outputEPCList/./.');

			insert into #EPCISEvent_EPC (EPCURN, EPCISEventID, IsParentID, IsInput, IsOutput)
			select
				REPLACE(content.nodes.query(N'.').value('(/epc/.)[1]', 'nvarchar(512)'), N' ', N'') as EPCURN,
				@EPCISEPCISEventID,
				0  as IsParent,
				0  as IsInput,
				1  as IsOutput
			from
				@EPCList.nodes(N'/*/*/.') as content(nodes)		


			--***************************************************************
			-- childEPCs
			--***************************************************************
	
			select
				@EPCList = @CurEvent.query(N'/*[local-name()= sql:variable("@EPCISEventTypePath")]/childEPCs/./.');

			insert into #EPCISEvent_EPC (EPCURN, EPCISEventID, IsParentID, IsInput, IsOutput)
			select
				REPLACE(content.nodes.query(N'.').value('(/epc/.)[1]', 'nvarchar(512)'), N' ', N'') as EPCURN,
				@EPCISEPCISEventID,
				0  as IsParent,
				0  as IsInput,
				0  as IsOutput
			from
				@EPCList.nodes(N'/*/*/.') as content(nodes)

			--***************************************************************
			-- bizTransactionList
			--***************************************************************

			select
				@BizTransactionList = @CurEvent.query(N'/*[local-name()= sql:variable("@EPCISEventTypePath")]/bizTransactionList/./.');

			insert into #EPCISEvent_BusinessTransactionID (BusinessTransactionIDURN, BusinessTransactionTypeURN, VocabularyTypeURN, EPCISEventID)
			select
				REPLACE(content.nodes.query(N'.').value('(/bizTransaction/.)[1]', 'nvarchar(512)'), N' ', N'') as BusinessTransactionIDURN,
				REPLACE(content.nodes.query(N'.').value('(/bizTransaction/@type)[1]', 'nvarchar(512)'), N' ', N'') as BusinessTransactionTypeURN,
				N'urn:epcglobal:epcis:vtype:BusinessTransactionType' as VocabularyTypeURN,
				@EPCISEPCISEventID
			from
				@BizTransactionList.nodes(N'/*/*/.') as content(nodes)	

			--***************************************************************
			-- Action
			--***************************************************************
	
			select 
				@VocabularyTypeURN = N'urn:quibiq:epcis:vtype:action',
				@VocabularyURN = 'urn:quibiq:epcis:cbv:action:' + REPLACE(lower(@CurEvent.value('(/*[local-name()= sql:variable("@EPCISEventTypePath")]/action/node())[1]', 'nvarchar(512)')), N' ', N'');

			if @VocabularyURN is not null
			begin
				insert into #EPCISEvent_Vocabulary (VocabularyTypeURN, VocabularyURN, EPCISEventID)
					values (@VocabularyTypeURN, @VocabularyURN, @EPCISEPCISEventID)
			end 

			--***************************************************************
			-- TransformationID EPCIS 1.1
			--***************************************************************
	
			select 
				@CharValue = REPLACE(@CurEvent.value('(/*[local-name()= sql:variable("@EPCISEventTypePath")]/transformationID/text())[1]', 'nvarchar(512)'), N' ', N'');

			if @CharValue is not null
			begin
				insert into #EPCISEvent_TransformationID (EPCISEventID, TransformationIDURN)
					values (@EPCISEPCISEventID, @CharValue)
			end 

			--***************************************************************
			-- Quantity EPCIS 1.0
			--***************************************************************
	
			select 
				@ValueTypeTypeURN = N'urn:quibiq:epcis:vtype:valuetype',
				@ValueTypeURN = N'urn:quibiq:epcis:cbv:valuetype:quantity',
				@DataTypeTypeURN = N'urn:quibiq:epcis:vtype:datatype',
				@DataTypeURN = N'urn:quibiq:epcis:cbv:datatype:int',
				@IntValue = @CurEvent.value('(/*[local-name()= sql:variable("@EPCISEventTypePath")]/quantity/node())[1]', 'int')

			if @IntValue is not null
			begin
				insert into #EPCISEvent_Value (ValueTypeTypeURN, ValueTypeURN, DataTypeTypeURN, DataTypeURN, IntValue, FloatValue, EPCISEventID, ExtensionType, ParentURN, Depth)
					values (@ValueTypeTypeURN, @ValueTypeURN, @DataTypeTypeURN, @DataTypeURN, @IntValue, @IntValue, @EPCISEPCISEventID, 0, N'', 0)
			end 

			--***************************************************************
			-- Quantity EPCIS 1.1
			--***************************************************************

			IF @EPCISEventTypePath = N'TransformationEvent'
			BEGIN
				SET @IsOutput = 1;
				SELECT @XmlList = @CurEvent.query(N'/*[local-name()= sql:variable("@EPCISEventTypePath")]/outputQuantityList/./.');
				
				insert into #EPCISEvent_QuantityElement (EPCISEventID, IsInput, IsOutput, EPCClassURN, Quantity, UOM)
				select
					@EPCISEPCISEventID,
					0          as IsInput,
					@IsOutput  as IsOutput,
					REPLACE(content.nodes.query(N'.').value('(/quantityElement/epcClass/text())[1]', 'nvarchar(512)'), N' ', N'') as EPCClassURN,
					ISNULL(REPLACE(content.nodes.query(N'.').value('(/quantityElement/quantity/text())[1]', 'float(53)'), N' ', N''), 0) as Quantity,
					ISNULL(REPLACE(content.nodes.query(N'.').value('(/quantityElement/uom/text())[1]', 'nchar(3)'), N' ', N''), N'') as UOM
				from
					@XmlList.nodes(N'/*/*/.') as content(nodes)		

				select
					@XmlList = @CurEvent.query(N'/*[local-name()= sql:variable("@EPCISEventTypePath")]/inputQuantityList/./.');


				insert into #EPCISEvent_QuantityElement (EPCISEventID, IsInput, IsOutput, EPCClassURN, Quantity, UOM)
				select
					@EPCISEPCISEventID,
					1  as IsInput,
					0  as IsOutput,
					REPLACE(content.nodes.query(N'.').value('(/quantityElement/epcClass/text())[1]', 'nvarchar(512)'), N' ', N'') as EPCClassURN,
					REPLACE(content.nodes.query(N'.').value('(/quantityElement/quantity/text())[1]', 'float(53)'), N' ', N'') as Quantity,
					ISNULL(REPLACE(content.nodes.query(N'.').value('(/quantityElement/uom/text())[1]', 'nchar(3)'), N' ', N''), N'') as UOM
				from
					@XmlList.nodes(N'/*/*/.') as content(nodes)		

			END
			ELSE
			BEGIN

				IF @EPCISEventTypePath = N'AggregationEvent'
				BEGIN
					SELECT @XmlList = @CurEvent.query(N'/*[local-name()= sql:variable("@EPCISEventTypePath")]/extension/childQuantityList/./.');

					insert into #EPCISEvent_QuantityElement (EPCISEventID, IsInput, IsOutput, EPCClassURN, Quantity, UOM)
					select
						@EPCISEPCISEventID,
						0          as IsInput,
						0          as IsOutput,
						REPLACE(content.nodes.query(N'.').value('(/quantityElement/epcClass/text())[1]', 'nvarchar(512)'), N' ', N'') as EPCClassURN,
						ISNULL(REPLACE(content.nodes.query(N'.').value('(/quantityElement/quantity/text())[1]', 'float(53)'), N' ', N''), 0) as Quantity,
						ISNULL(REPLACE(content.nodes.query(N'.').value('(/quantityElement/uom/text())[1]', 'nchar(3)'), N' ', N''), N'') as UOM
					from
						@XmlList.nodes(N'/*/*/.') as content(nodes)		

				END
				BEGIN
					SELECT @XmlList = @CurEvent.query(N'/*[local-name()= sql:variable("@EPCISEventTypePath")]/extension/quantityList/./.');

					insert into #EPCISEvent_QuantityElement (EPCISEventID, IsInput, IsOutput, EPCClassURN, Quantity, UOM)
					select
						@EPCISEPCISEventID,
						0          as IsInput,
						0          as IsOutput,
						REPLACE(content.nodes.query(N'.').value('(/quantityElement/epcClass/text())[1]', 'nvarchar(512)'), N' ', N'') as EPCClassURN,
						ISNULL(REPLACE(content.nodes.query(N'.').value('(/quantityElement/quantity/text())[1]', 'float(53)'), N' ', N''), 0) as Quantity,
						ISNULL(REPLACE(content.nodes.query(N'.').value('(/quantityElement/uom/text())[1]', 'nchar(3)'), N' ', N''), N'') as UOM
					from
						@XmlList.nodes(N'/*/*/.') as content(nodes)		

				END;
			END;

			--***************************************************************
			-- SourceDestination
			--***************************************************************

			IF @EPCISEventTypePath = N'TransformationEvent'
			BEGIN
				SELECT @XmlList = @CurEvent.query(N'/*[local-name()= sql:variable("@EPCISEventTypePath")]/sourceList/./.');
			END
			ELSE
			BEGIN
				SELECT @XmlList = @CurEvent.query(N'/*[local-name()= sql:variable("@EPCISEventTypePath")]/extension/sourceList/./.');
			END;

			insert into #EPCISEvent_SourceDestination (EPCISEventID, IsSource, SourceDestinationURN, SourceDestinationTypeURN)
			select
				@EPCISEPCISEventID,
				1  as IsSource,
				REPLACE(content.nodes.query(N'.').value('(/source/text())[1]', 'nvarchar(512)'), N' ', N'') as SourceDestinationURN,
				REPLACE(content.nodes.query(N'.').value('(/source/@type)[1]', 'nvarchar(512)'), N' ', N'') as SourceDestinationTypeURN
			from
				@XmlList.nodes(N'/*/*/.') as content(nodes)		

	
			IF @EPCISEventTypePath = N'TransformationEvent'
			BEGIN
				SELECT @XmlList = @CurEvent.query(N'/*[local-name()= sql:variable("@EPCISEventTypePath")]/destinationList/./.');
			END
			ELSE
			BEGIN
				SELECT @XmlList = @CurEvent.query(N'/*[local-name()= sql:variable("@EPCISEventTypePath")]/extension/destinationList/./.');
			END;

			insert into #EPCISEvent_SourceDestination (EPCISEventID, IsSource, SourceDestinationURN, SourceDestinationTypeURN)
			select
				@EPCISEPCISEventID,
				0  as IsSource,
				REPLACE(content.nodes.query(N'.').value('(/destination/text())[1]', 'nvarchar(512)'), N' ', N'') as SourceDestinationURN,
				REPLACE(content.nodes.query(N'.').value('(/destination/@type)[1]', 'nvarchar(512)'), N' ', N'') as SourceDestinationTypeURN
			from
				@XmlList.nodes(N'/*/*/.') as content(nodes)	
				

			--***************************************************************
			-- baseExtension Fields(eventID, errorDeclarationTime, correctiveEventId, reason) 1.2
			--***************************************************************

			--***************************************************************
			-- errorDecalration extension fields
			--***************************************************************
			SELECT @XmlList = @CurEvent.query(N'/*[local-name()= sql:variable("@EPCISEventTypePath")]/baseExtension/errorDeclaration/./.');
			;with extensions as(
				select 
					N'urn:quibiq:epcis:vtype:errordeclaration'																							as [ValueTypeTypeURN]
					,N'urn:quibiq:epcis:vtype:datatype'																						as [DataTypeTypeURN]
					-- Generisch erstellt namespace#root
					,content.nodes.value('fn:concat(namespace-uri(.),"#",local-name(.))','nvarchar(max)')	as [ValueTypeURN]

					-- CONTENT
					,content.nodes.value('./text()[1]','nvarchar(max)')																		as [StringValue]
					,TRY_CONVERT(bigint,content.nodes.value('./text()[1]','nvarchar(max)'))													as [IntValue]
					,TRY_CONVERT(datetimeoffset,content.nodes.value('./text()[1]','nvarchar(max)'))												as [TimeValue]
					,TRY_CONVERT(float,content.nodes.value('./text()[1]','nvarchar(max)'))													as [FloatValue]
					-- HIERARCHY
					,CAST(N'' as nvarchar(max))																								as [ParentURN]
					,0																														as [Depth]
					,content.nodes.query('./node()')																							as [Content]
				from
					@XmlList.nodes(N'/*/*[namespace-uri() != '''' and namespace-uri() != ''urn:epcglobal:epcis:xsd:1'']') as content(nodes)		
			UNION ALL
				select
					N'urn:quibiq:epcis:vtype:errordeclaration'																							as [ValueTypeTypeURN]			  
					,N'urn:quibiq:epcis:vtype:datatype'																						as [DataTypeTypeURN]
					-- Generisch erstellt urn:quibiq:epcis:cbv:valuetype:namespace#root
					,con.nodes.value('fn:concat(namespace-uri(.),"#",local-name(.))','nvarchar(max)')		as [ValueTypeURN]

					-- CONTENT
					,con.nodes.value('./text()[1]','nvarchar(max)')																			as [StringValue]
					,TRY_CONVERT(bigint,con.nodes.value('./text()[1]','nvarchar(max)'))														as [IntValue]
					,TRY_CONVERT(datetimeoffset,con.nodes.value('./text()[1]','nvarchar(max)'))													as [TimeValue]
					,TRY_CONVERT(float,con.nodes.value('./text()[1]','nvarchar(max)'))														as [FloatValue]
					-- HIERARCHY
					,[ValueTypeURN]																											as [ParentURN]
					,[Depth]+1																												as [Depth]
					,con.nodes.query('./node()')																								as [Content]
				from extensions
					cross apply Content.nodes(N'/*') as con(nodes)
			)
				insert into #EPCISEvent_Value 
					(  EPCISEventID
						, ValueTypeTypeURN
						, ValueTypeURN
						, DataTypeTypeURN
						, DataTypeURN
						, IntValue
						, FloatValue		
						, TimeValue			
						, StringValue 
						, ParentURN
						, Depth
						, ExtensionType)		
				select 
						@EPCISEPCISEventID as EPCISEventID
						, ValueTypeTypeURN
						, ValueTypeURN
						, DataTypeTypeURN
						, [Import].[svf_get_DataTypeURN](IntValue, FloatValue, TimeValue, StringValue) as DataTypeURN
						, IntValue
						, FloatValue		
						, TimeValue			
						, StringValue 	
						, ParentURN
						, Depth 	
						, 1 as ExtensionType
				from extensions;

				--***************************************************************
				-- eventID
				--***************************************************************
				DECLARE @EventId NVARCHAR(128);
				SELECT @EventId = @CurEvent.value('(/*[local-name()= sql:variable("@EPCISEventTypePath")]/baseExtension/eventID/node())[1]', 'nvarchar(50)')
				IF @EventId IS NOT NULL
				BEGIN
					select 
					@ValueTypeTypeURN = N'urn:quibiq:epcis:vtype:baseextension',
					@ValueTypeURN = N'urn:quibiq:epcis:cbv:valuetype:eventid',
					@DataTypeTypeURN = N'urn:quibiq:epcis:vtype:datatype',
					@DataTypeURN = N'urn:quibiq:epcis:cbv:datatype:string';

					insert into #EPCISEvent_Value (ValueTypeTypeURN, ValueTypeURN, DataTypeTypeURN, DataTypeURN, StringValue, EPCISEventID, ExtensionType, ParentURN, Depth)
						values (@ValueTypeTypeURN, @ValueTypeURN, @DataTypeTypeURN, @DataTypeURN, @EventId, @EPCISEPCISEventID, 0, N'', 0)
					--INSERT eventID
				END
            
				--***************************************************************
				-- errorDeclaration
				--***************************************************************
				if @CurEvent.exist(N'/*[local-name()= sql:variable("@EPCISEventTypePath")]/baseExtension/errorDeclaration/.') = 1
				BEGIN
					DECLARE @DeclarationTime DATETIME2(2),
							@Reason NVARCHAR(128);
					SELECT @DeclarationTime = @CurEvent.value('(/*[local-name()= sql:variable("@EPCISEventTypePath")]/baseExtension/errorDeclaration/declarationTime/node())[1]', 'nvarchar(50)')
					--INSERT declarationtime
					select 
					@ValueTypeTypeURN = N'urn:quibiq:epcis:vtype:baseextension',
					@ValueTypeURN = N'urn:quibiq:epcis:cbv:valuetype:declarationtime',
					@DataTypeTypeURN = N'urn:quibiq:epcis:vtype:datatype',
					@DataTypeURN = N'urn:quibiq:epcis:cbv:datatype:time';

					insert into #EPCISEvent_Value (ValueTypeTypeURN, ValueTypeURN, DataTypeTypeURN, DataTypeURN, TimeValue, EPCISEventID, ExtensionType, ParentURN, Depth)
						values (@ValueTypeTypeURN, @ValueTypeURN, @DataTypeTypeURN, @DataTypeURN, @DeclarationTime, @EPCISEPCISEventID, 0, N'', 0);

					SELECT @Reason = @CurEvent.value('(/*[local-name()= sql:variable("@EPCISEventTypePath")]/baseExtension/errorDeclaration/reason/node())[1]', 'nvarchar(50)')
					IF @Reason IS NOT NULL
					BEGIN
						select 
						@ValueTypeTypeURN = N'urn:quibiq:epcis:vtype:baseextension',
						@ValueTypeURN = N'urn:quibiq:epcis:cbv:valuetype:reason',
						@DataTypeTypeURN = N'urn:quibiq:epcis:vtype:datatype',
						@DataTypeURN = N'urn:quibiq:epcis:cbv:datatype:string';

						insert into #EPCISEvent_Value (ValueTypeTypeURN, ValueTypeURN, DataTypeTypeURN, DataTypeURN, StringValue, EPCISEventID, ExtensionType, ParentURN, Depth)
							values (@ValueTypeTypeURN, @ValueTypeURN, @DataTypeTypeURN, @DataTypeURN, @Reason, @EPCISEPCISEventID, 0, N'', 0)
					--INSERT Reason
					END
					if @CurEvent.exist(N'/*[local-name()= sql:variable("@EPCISEventTypePath")]/baseExtension/errorDeclaration/correctiveEventIDs') = 1
					BEGIN
						DECLARE @CorretiveEventIds XML;
						select 
							@ValueTypeTypeURN = N'urn:quibiq:epcis:vtype:baseextension',
							@ValueTypeURN = N'urn:quibiq:epcis:cbv:valuetype:correctiveeventid',
							@DataTypeTypeURN = N'urn:quibiq:epcis:vtype:datatype',
							@DataTypeURN = N'urn:quibiq:epcis:cbv:datatype:string';
						--INSERT INTO
						select @CorretiveEventIds = @CurEvent.query(N'/*[local-name()= sql:variable("@EPCISEventTypePath")]/baseExtension/errorDeclaration/correctiveEventIDs/./.')
						insert into #EPCISEvent_Value (ValueTypeTypeURN, ValueTypeURN, DataTypeTypeURN, DataTypeURN, StringValue, EPCISEventID, ExtensionType, ParentURN, Depth)
						SELECT
							@ValueTypeTypeURN,
							@ValueTypeURN,
							@DataTypeTypeURN,
							@DataTypeURN,
							REPLACE(content.nodes.query(N'.').value('(/correctiveEventID/.)[1]', 'nvarchar(512)'), N' ', N'') as correctiveEventIds,
							@EPCISEPCISEventID,
							0,
							N'',
							0
						from
							@CorretiveEventIds.nodes(N'/*/*/.') as content(nodes)
                    END
                    
                END
                
			--***************************************************************
			-- ILMD Extension Fields
			--***************************************************************

			IF @EPCISEventTypePath = N'TransformationEvent'
			BEGIN
				SELECT @XmlList = @CurEvent.query(N'/*[local-name()= sql:variable("@EPCISEventTypePath")]/ilmd/./.');
			END
			ELSE
			BEGIN
				SELECT @XmlList = @CurEvent.query(N'/*[local-name()= sql:variable("@EPCISEventTypePath")]/extension/ilmd/./.');
			END;

			;with extensions as(
					select 
					   N'urn:quibiq:epcis:vtype:ilmd'																							as [ValueTypeTypeURN]
					  ,N'urn:quibiq:epcis:vtype:datatype'																						as [DataTypeTypeURN]
					  -- Generisch erstellt namespace#root
					  ,content.nodes.value('fn:concat(namespace-uri(.),"#",local-name(.))','nvarchar(max)')	as [ValueTypeURN]

					  -- CONTENT
					  ,content.nodes.value('./text()[1]','nvarchar(max)')																		as [StringValue]
					  ,TRY_CONVERT(bigint,content.nodes.value('./text()[1]','nvarchar(max)'))													as [IntValue]
					  ,TRY_CONVERT(datetimeoffset,content.nodes.value('./text()[1]','nvarchar(max)'))												as [TimeValue]
					  ,TRY_CONVERT(float,content.nodes.value('./text()[1]','nvarchar(max)'))													as [FloatValue]
					  -- HIERARCHY
					  ,CAST(N'' as nvarchar(max))																								as [ParentURN]
					  ,0																														as [Depth]
					  ,content.nodes.query('./node()')																							as [Content]
					from
						@XmlList.nodes(N'/ilmd/*[namespace-uri() != '''' and namespace-uri() != ''urn:epcglobal:epcis:xsd:1'']') as content(nodes)		
				UNION ALL
					select
					   N'urn:quibiq:epcis:vtype:ilmd'																							as [ValueTypeTypeURN]			  
					  ,N'urn:quibiq:epcis:vtype:datatype'																						as [DataTypeTypeURN]
					  -- Generisch erstellt urn:quibiq:epcis:cbv:valuetype:namespace#root
					  ,con.nodes.value('fn:concat(namespace-uri(.),"#",local-name(.))','nvarchar(max)')		as [ValueTypeURN]

					  -- CONTENT
					  ,con.nodes.value('./text()[1]','nvarchar(max)')																			as [StringValue]
					  ,TRY_CONVERT(bigint,con.nodes.value('./text()[1]','nvarchar(max)'))														as [IntValue]
					  ,TRY_CONVERT(datetimeoffset,con.nodes.value('./text()[1]','nvarchar(max)'))													as [TimeValue]
					  ,TRY_CONVERT(float,con.nodes.value('./text()[1]','nvarchar(max)'))														as [FloatValue]
					  -- HIERARCHY
					  ,[ValueTypeURN]																											as [ParentURN]
					  ,[Depth]+1																												as [Depth]
					  ,con.nodes.query('./node()')																								as [Content]
					from extensions
						cross apply Content.nodes(N'/*') as con(nodes)
				)
				insert into #EPCISEvent_Value 
					(  EPCISEventID
					 , ValueTypeTypeURN
					 , ValueTypeURN
					 , DataTypeTypeURN
					 , DataTypeURN
					 , IntValue
					 , FloatValue		
					 , TimeValue			
					 , StringValue 
					 , ParentURN
					 , Depth
					 , ExtensionType)		
				select 
					  @EPCISEPCISEventID as EPCISEventID
					 , ValueTypeTypeURN
					 , ValueTypeURN
					 , DataTypeTypeURN
					 , [Import].[svf_get_DataTypeURN](IntValue, FloatValue, TimeValue, StringValue) as DataTypeURN
					 , IntValue
					 , FloatValue		
					 , TimeValue			
					 , StringValue 	
					 , ParentURN
					 , Depth 	
					 , 1 as ExtensionType
				from extensions;

			--***************************************************************
			-- Customer Extension Fields
			--***************************************************************
	
			;with extensions2 as(
					select 
					   N'urn:quibiq:epcis:vtype:extensiontype'																					as [ValueTypeTypeURN]
					  ,N'urn:quibiq:epcis:vtype:datatype'																						as [DataTypeTypeURN]
					  -- Generisch erstellt namespace#root
					  ,content.nodes.value('fn:concat(namespace-uri(.),"#",local-name(.))','nvarchar(max)')	as [ValueTypeURN]

					  -- CONTENT
					  ,content.nodes.value('./text()[1]','nvarchar(max)')																		as [StringValue]
					  ,TRY_CONVERT(bigint,content.nodes.value('./text()[1]','nvarchar(max)'))													as [IntValue]
					  ,TRY_CONVERT(datetimeoffset,content.nodes.value('./text()[1]','nvarchar(max)'))												as [TimeValue]
					  ,TRY_CONVERT(float,content.nodes.value('./text()[1]','nvarchar(max)'))													as [FloatValue]
					  -- HIERARCHY
					  ,CAST(N'' as nvarchar(max))																								as [ParentURN]
					  ,0																														as [Depth]
					  ,content.nodes.query('./node()')																							as [Content]
					from
						@CurEvent.nodes(N'/*[local-name()= sql:variable("@EPCISEventTypePath")]/*[namespace-uri() != '''' and namespace-uri() != ''urn:epcglobal:epcis:xsd:1'']') as content(nodes)		
				UNION ALL
					select
					   N'urn:quibiq:epcis:vtype:extensiontype'																					as [ValueTypeTypeURN]
					  ,N'urn:quibiq:epcis:vtype:datatype'																						as [DataTypeTypeURN]
					  -- Generisch erstellt urn:quibiq:epcis:cbv:valuetype:namespace#root
					  ,con.nodes.value('fn:concat(namespace-uri(.),"#",local-name(.))','nvarchar(max)')		as [ValueTypeURN]

					  -- CONTENT
					  ,con.nodes.value('./text()[1]','nvarchar(max)')																			as [StringValue]
					  ,TRY_CONVERT(bigint,con.nodes.value('./text()[1]','nvarchar(max)'))														as [IntValue]
					  ,TRY_CONVERT(datetimeoffset,con.nodes.value('./text()[1]','nvarchar(max)'))													as [TimeValue]
					  ,TRY_CONVERT(float,con.nodes.value('./text()[1]','nvarchar(max)'))														as [FloatValue]
					  -- HIERARCHY
					  ,[ValueTypeURN]																											as [ParentURN]
					  ,[Depth]+1																												as [Depth]
					  ,con.nodes.query('./node()')																								as [Content]
					from extensions2
						cross apply Content.nodes(N'/*') as con(nodes)
				)
				insert into #EPCISEvent_Value 
					(  EPCISEventID
					 , ValueTypeTypeURN
					 , ValueTypeURN
					 , DataTypeTypeURN
					 , DataTypeURN
					 , IntValue
					 , FloatValue		
					 , TimeValue			
					 , StringValue 
					 , ParentURN
					 , Depth
					 , ExtensionType)		
				select 
					  @EPCISEPCISEventID as EPCISEventID
					 , ValueTypeTypeURN
					 , ValueTypeURN
					 , DataTypeTypeURN
					 , [Import].[svf_get_DataTypeURN](IntValue, FloatValue, TimeValue, StringValue) as DataTypeURN
					 , IntValue
					 , FloatValue		
					 , TimeValue			
					 , StringValue 	
					 , ParentURN
					 , Depth 	
					 , 1 as ExtensionType
				from extensions2;

			 
			    insert into #EPCISEvent_ExtenstionType (EPCISEventID, ExtensionTypeURN, ExtensionTypeTypeURN)
				select 
					 @EPCISEPCISEventID as EPCISEventID
					,ValueTypeURN  as ExtensionTypeURN
					,ValueTypeTypeURN as ExtensionTypeTypeURN
				from #EPCISEvent_Value where ExtensionType = 1
				group by ValueTypeURN, ValueTypeTypeURN

			--***************************************************************
			-- EPCClass
			--***************************************************************
	
			select 
				@VocabularyTypeURN = N'urn:epcglobal:epcis:vtype:EPCClass',
				@VocabularyURN = REPLACE(lower(@CurEvent.value('(/*[local-name()= sql:variable("@EPCISEventTypePath")]/epcClass/node())[1]', 'nvarchar(512)')), N' ', N'');

			if @VocabularyURN is not null
			begin
				insert into #EPCISEvent_Vocabulary (VocabularyTypeURN, VocabularyURN, EPCISEventID)
					values (@VocabularyTypeURN, @VocabularyURN, @EPCISEPCISEventID)
			end 

			--***************************************************************
			-- Bizstep
			--***************************************************************

			select 
				@VocabularyTypeURN = N'urn:epcglobal:epcis:vtype:BusinessStep',
				@VocabularyURN = REPLACE(@CurEvent.value('(/*[local-name()= sql:variable("@EPCISEventTypePath")]/bizStep/node())[1]', 'nvarchar(512)'), N' ', N'');

			if @VocabularyURN is not null
			begin
				insert into #EPCISEvent_Vocabulary (VocabularyTypeURN, VocabularyURN, EPCISEventID)
					values (@VocabularyTypeURN, @VocabularyURN, @EPCISEPCISEventID)
			end

			--***************************************************************
			-- Disposition
			--***************************************************************

			select 
				@VocabularyTypeURN = N'urn:epcglobal:epcis:vtype:Disposition',
				@VocabularyURN = REPLACE(@CurEvent.value('(/*[local-name()= sql:variable("@EPCISEventTypePath")]/disposition/node())[1]', 'nvarchar(512)'), N' ', N'');

			if @VocabularyURN is not null
			begin
				insert into #EPCISEvent_Vocabulary (VocabularyTypeURN, VocabularyURN, EPCISEventID)
					values (@VocabularyTypeURN, @VocabularyURN, @EPCISEPCISEventID)
			end

			--***************************************************************
			-- Readpoint
			--***************************************************************

			select 
				@VocabularyTypeURN = N'urn:epcglobal:epcis:vtype:Readpoint',
				@VocabularyURN = REPLACE(@CurEvent.value('(/*[local-name()= sql:variable("@EPCISEventTypePath")]/readPoint/id/node())[1]', 'nvarchar(512)'), N' ', N'');

			if @VocabularyURN is not null
			begin
				insert into #EPCISEvent_Vocabulary (VocabularyTypeURN, VocabularyURN, EPCISEventID)
					values (@VocabularyTypeURN, @VocabularyURN, @EPCISEPCISEventID)	
			end

			--***************************************************************
			-- bizLocation
			--***************************************************************

			select 
				@VocabularyTypeURN = N'urn:epcglobal:epcis:vtype:BusinessLocation',
				@VocabularyURN = REPLACE(@CurEvent.value('(/*[local-name()= sql:variable("@EPCISEventTypePath")]/bizLocation/id/node())[1]', 'nvarchar(512)'), N' ', N'');

			if @VocabularyURN is not null
			begin
				insert into #EPCISEvent_Vocabulary (VocabularyTypeURN, VocabularyURN, EPCISEventID)
					values (@VocabularyTypeURN, @VocabularyURN, @EPCISEPCISEventID)
			end

			fetch next from curEvent into @EPCISEvent;
		end

		close curEvent
		deallocate curEvent;


		--***************************************************************
		-- Prüfung auf vorhandene VocabularyTypes
		--***************************************************************

		merge into #EPCISEvent_Vocabulary as target
		using (select 
		        vt.[ID],
				vt.URN,
				vtc.Deleted
			   from Vocabulary.[VocabularyType] vt 
			   join Vocabulary.[VocabularyType_Client] vtc on vtc.[VocabularyTypeID] = vt.[ID]
			    and (vtc.ClientID = @ClientID or vtc.ClientID = @SystemClientID)
		) as source	
		on target.VocabularyTypeURN = source.URN and source.Deleted = 0
		when matched then
			update set VocabularyTypeID = source.[ID];

		-- Falls Vokabeltyp nicht vorhanden, dann werden die betroffenen Events mit Begründung markiert
		INSERT INTO #EPCISEvent_Error 
			(  EPCISEventID
			 , Reason)
		SELECT 
			  EPCISEventID
			,  N'Vokabeltyp für '''+ VocabularyURN +''' nicht in Stammdaten (oder logisch geloescht). Fehlender Typ: ''' + VocabularyTypeURN + ''''	
		FROM #EPCISEvent_Vocabulary where VocabularyTypeID is null;
		
		--***************************************************************
		-- Prüfung auf vorhandenes Vocabulary
		--***************************************************************

		-- Nur BizLocation und ReadPoints hinzufügen
		if @AddBizLocAndReadPoints = 1 and @AddNewVocabulary = 0
		begin
			merge into Vocabulary.[Vocabulary] WITH (HOLDLOCK) as target
			using (select distinct VocabularyURN, VocabularyTypeID from #EPCISEvent_Vocabulary 
				  where VocabularyTypeURN = N'urn:epcglobal:epcis:vtype:BusinessLocation' or VocabularyTypeURN = N'urn:epcglobal:epcis:vtype:ReadPoint'
				  ) as source
			on target.URN = source.VocabularyURN and target.[VocabularyTypeID] = source.VocabularyTypeID and target.ClientID = @ClientID		
			when matched then
				update set Deleted = 0
			when not matched by target then
				insert (URN, [VocabularyTypeID], ClientID)
					values (source.VocabularyURN, source.VocabularyTypeID, @ClientID);
	
		end

		-- Nur EPCClass hinzufügen
		DECLARE @EPCISClassTypeID BIGINT;
		select @EPCISClassTypeID = ID from Vocabulary.VocabularyType vt
						join Vocabulary.VocabularyType_Client vtc on vtc.VocabularyTypeID = vt.ID
		where URN = N'urn:epcglobal:epcis:vtype:EPCClass' and ClientID = @ClientID and Deleted = 0;

		if @AddEPCClass = 1 or @AddNewVocabulary = 1
		begin
			merge into Vocabulary.[Vocabulary] WITH (HOLDLOCK) as target
			using (select distinct EPCClassURN as VocabularyURN, @EPCISClassTypeID as [VocabularyTypeID] from #EPCISEvent_QuantityElement) as source
			on target.URN = source.VocabularyURN and target.[VocabularyTypeID] = source.VocabularyTypeID and target.ClientID = @ClientID		
			when matched then
				update set Deleted = 0
			when not matched by target then
				insert (URN, [VocabularyTypeID], ClientID)
					values (source.VocabularyURN, source.VocabularyTypeID, @ClientID);	
		end

		-- SourceDestination hinzufügen
		if @AddSourceDestination = 1 or @AddNewVocabulary = 1
		begin
			DECLARE @ID BIGINT;
			
			select @ID = ID from Vocabulary.VocabularyType vt
						join Vocabulary.VocabularyType_Client vtc on vtc.VocabularyTypeID = vt.ID
			where URN = N'urn:epcglobal:epcis:vtype:SourceDest' and ClientID = @ClientID and Deleted = 0;

			merge into Vocabulary.[Vocabulary] WITH (HOLDLOCK) as target
			using (select distinct SourceDestinationURN from #EPCISEvent_SourceDestination 
				  ) as source
			on target.URN = source.SourceDestinationURN and target.[VocabularyTypeID] = @ID and target.ClientID = @ClientID		
			when matched then
				update set Deleted = 0
			when not matched by target then
				insert (URN, [VocabularyTypeID], ClientID)
					values (source.SourceDestinationURN, @ID, @ClientID);	
		end

		-- Alle Vokabeln hinzfügen
		if @AddNewVocabulary = 1 
		begin
			merge into Vocabulary.[Vocabulary] WITH (HOLDLOCK) as target
			using (select distinct VocabularyURN, VocabularyTypeID from #EPCISEvent_Vocabulary) as source
			on target.URN = source.VocabularyURN and target.[VocabularyTypeID] = source.VocabularyTypeID and target.ClientID = @ClientID		
			when matched then
				update set Deleted = 0
			when not matched by target then
				insert (URN, [VocabularyTypeID], ClientID)
					values (source.VocabularyURN, source.VocabularyTypeID, @ClientID);
		end

		-- Systemvokablen (Systemmandant) ergänzen
		update 
			#EPCISEvent_Vocabulary
		set ID = v.[ID]
		from #EPCISEvent_Vocabulary ev
		join Vocabulary.[Vocabulary] v on v.URN = ev.VocabularyURN and v.[VocabularyTypeID] = ev.VocabularyTypeID and v.ClientID = @SystemClientID and v.Deleted = 0;

		-- Mandantenvokabeln ergänzen
		update 
			#EPCISEvent_Vocabulary
		set ID = v.[ID]
		from #EPCISEvent_Vocabulary ev
		join Vocabulary.[Vocabulary] v on v.URN = ev.VocabularyURN and v.[VocabularyTypeID] = ev.VocabularyTypeID and v.ClientID = @ClientID and v.Deleted = 0;

		-- Describe Error
		INSERT INTO #EPCISEvent_Error 
			(  EPCISEventID
			 , Reason)
		SELECT 
			  EPCISEventID
			,  N'Vokabel '''+ VocabularyURN +''' nicht in Stammdaten gepflegt (oder logisch geloescht).'													
		FROM #EPCISEvent_Vocabulary where ID is null;
	
		--***************************************************************
		-- EventBusinessTransaction: IDs zu den gesammelten URN bestimmen
		--***************************************************************

		if @AddNewVocabulary = 1 
		begin
			merge into Vocabulary.[Vocabulary] WITH (HOLDLOCK) as target
			using (select distinct BusinessTransactionTypeURN, VocabularyTypeID from #EPCISEvent_BusinessTransactionID) as source
			on target.URN = source.BusinessTransactionTypeURN and target.[VocabularyTypeID] = source.VocabularyTypeID and target.ClientID = @ClientID	
			when matched then
				update set Deleted = 0
			when not matched by target then
				insert (URN, [VocabularyTypeID], ClientID)
					values (source.BusinessTransactionTypeURN, source.VocabularyTypeID, @ClientID);

			merge into #EPCISEvent_BusinessTransactionID as target
			using Vocabulary.[Vocabulary] as source
			on target.VocabularyTypeID = source.[VocabularyTypeID] and target.BusinessTransactionTypeURN = source.URN and source.ClientID = @ClientID	
			when matched then
				update set BusinessTransactionTypeID = source.[ID];
		end

		merge into #EPCISEvent_BusinessTransactionID as target
		using (select 
		        vt.[ID],
				vt.URN,
				vtc.Deleted
			   from Vocabulary.[VocabularyType] vt 
			   join Vocabulary.[VocabularyType_Client] vtc on vtc.[VocabularyTypeID] = vt.[ID] and vtc.ClientID = @ClientID
		) as source	
		on target.VocabularyTypeURN = source.URN and source.Deleted = 0
		when matched then 
			update set VocabularyTypeID = source.[ID];

		merge into #EPCISEvent_BusinessTransactionID as target
		using Vocabulary.[Vocabulary] as source
		on target.VocabularyTypeID = source.[VocabularyTypeID] and target.BusinessTransactionTypeURN = source.URN and source.ClientID = @ClientID	and source.Deleted = 0
		when matched then
			update set BusinessTransactionTypeID = source.[ID];
		
		-- Describe Error
		INSERT INTO #EPCISEvent_Error 
			(  EPCISEventID
			 , Reason)
		SELECT 
			  EPCISEventID
			, N'''' + BusinessTransactionTypeURN + ''' unbekannter BusinessTransactionsTyp (oder logisch geloescht).'								
		FROM #EPCISEvent_BusinessTransactionID where BusinessTransactionTypeID is null;



		--***************************************************************
		-- QuantityElement
		--***************************************************************
		
		merge into #EPCISEvent_QuantityElement as target
		using Vocabulary.[Vocabulary] as source
		on @EPCISClassTypeID = source.[VocabularyTypeID] and target.EPCClassURN = source.URN and source.ClientID = @ClientID	and source.Deleted = 0
		when matched then
			update set EPCClassID = source.[ID];
				

		-- Describe Error
		INSERT INTO #EPCISEvent_Error 
			(  EPCISEventID
			 , Reason)
		SELECT 
			  EPCISEventID
			, N'''' + EPCClassURN + ''' unbekannte EPCClass (oder logisch geloescht).'								
		FROM #EPCISEvent_QuantityElement where EPCClassID is null;

		--***************************************************************
		-- SourceDestination
		--***************************************************************
		select @ID = ID from Vocabulary.VocabularyType vt
						join Vocabulary.VocabularyType_Client vtc on vtc.VocabularyTypeID = vt.ID
		where URN = N'urn:epcglobal:epcis:vtype:SourceDest' and ClientID = @ClientID and Deleted = 0;
	    
		merge into #EPCISEvent_SourceDestination as target
		using Vocabulary.[Vocabulary] as source
		on @ID = source.[VocabularyTypeID] and target.SourceDestinationURN = source.URN and source.ClientID = @ClientID	and source.Deleted = 0
		when matched then
			update set SourceDestinationID = source.[ID];
		
		select @ID = ID from Vocabulary.VocabularyType vt
						join Vocabulary.VocabularyType_Client vtc on vtc.VocabularyTypeID = vt.ID
		where URN = N'urn:epcglobal:epcis:vtype:SourceDestType' and ClientID = @ClientID and Deleted = 0;

		merge into #EPCISEvent_SourceDestination as target
		using Vocabulary.[Vocabulary] as source
		on @ID = source.[VocabularyTypeID] and target.SourceDestinationTypeURN = source.URN and source.ClientID = @ClientID and source.Deleted = 0
		when matched then
			update set SourceDestinationTypeID = source.[ID];

		-- Describe Error
		INSERT INTO #EPCISEvent_Error 
			(  EPCISEventID
			 , Reason)
		SELECT 
			  EPCISEventID
			, N'''' + SourceDestinationURN + ''' unbekannte SourceDest (oder logisch geloescht).'								
		FROM #EPCISEvent_SourceDestination where SourceDestinationID is null
		group by EPCISEventID, SourceDestinationURN;

		-- Describe Error
		INSERT INTO #EPCISEvent_Error 
			(  EPCISEventID
			 , Reason)
		SELECT 
			  EPCISEventID
			, N'''' + SourceDestinationTypeURN + ''' unbekannter SourceDest Typ (oder logisch geloescht).'								
		FROM #EPCISEvent_SourceDestination where SourceDestinationTypeID is null
		group by EPCISEventID, SourceDestinationTypeURN;

		--***************************************************************
		-- Inhaltliche Prüfungen
		--***************************************************************

		-- Prüfung EPC Struktur entweder URI (schema:path) oder EPC Pure Identity urn:epc:id:... 
		INSERT INTO #EPCISEvent_Error 
			(  EPCISEventID
			 , Reason)
		SELECT 
			  EPCISEventID
			, N'EPC URI ''' + EPCURN + ''' is not valid'
		FROM #EPCISEvent_EPC
		WHERE [Helper].svf_check_EPC_Code(EPCURN) = 0;

		-- Prüfung Aggregation ADD und DELETE benoetigen ParentID
		INSERT INTO #EPCISEvent_Error 
			(  EPCISEventID
			 , Reason)
		SELECT 
			  ed.EPCISEventID
			, N'Aggregation-Event mit Action:''' + UPPER(SUBSTRING(ev.VocabularyURN, 29, LEN(ev.VocabularyURN)-28)) + ''' parentID fehlt'
		FROM #EventData ed
		JOIN #EPCISEvent_Vocabulary ev   on ed.EPCISEventID = ev.EPCISEventID
		JOIN #EPCISEvent_Vocabulary ev2  on ed.EPCISEventID = ev2.EPCISEventID
		WHERE 
			ev.VocabularyTypeURN = N'urn:quibiq:epcis:vtype:action' and (ev.VocabularyURN = N'urn:quibiq:epcis:cbv:action:add' or ev.VocabularyURN = N'urn:quibiq:epcis:cbv:action:delete')
		and ev2.VocabularyTypeURN = N'urn:quibiq:epcis:vtype:event' and (ev2.VocabularyURN = N'urn:quibiq:epcis:cbv:event:aggregation')
		and not exists (select TOP 1 1 FROM #EPCISEvent_EPC where EPCISEventID = ed.EPCISEventID and IsParentID = 1)
		group by ed.EPCISEventID, ev.VocabularyURN;

		-- Prüfung ObjectEvent epcList oder qunatityList oder beides
		INSERT INTO #EPCISEvent_Error 
			(  EPCISEventID
			 , Reason)
		SELECT 
			  ed.EPCISEventID
			, N'Object-Event ohne epcList oder quantityList'
		FROM #EventData ed
		JOIN #EPCISEvent_Vocabulary ev			  on ed.EPCISEventID = ev.EPCISEventID
		LEFT JOIN #EPCISEvent_EPC   ec			  on ed.EPCISEventID = ec.EPCISEventID
		LEFT JOIN #EPCISEvent_QuantityElement qe   on ed.EPCISEventID = qe.EPCISEventID
		WHERE 
			ec.EPCURN is null and qe.EPCClassURN is null
		and ev.VocabularyTypeURN = N'urn:quibiq:epcis:vtype:event' and (ev.VocabularyURN = N'urn:quibiq:epcis:cbv:event:object')
		group by ed.EPCISEventID;

		-- Prüfung ObjectEvent != ADD kein ILMD
		INSERT INTO #EPCISEvent_Error 
			(  EPCISEventID
			 , Reason)
		SELECT 
			  ed.EPCISEventID
			, N'Object-Event mit Action:''' + UPPER(SUBSTRING(ev.VocabularyURN, 29, LEN(ev.VocabularyURN)-28)) + ''' darf kein ILMD besitzen'
		FROM #EventData ed
		JOIN #EPCISEvent_Vocabulary ev   on ed.EPCISEventID = ev.EPCISEventID
		JOIN #EPCISEvent_Vocabulary ev3  on ed.EPCISEventID = ev3.EPCISEventID
		JOIN #EPCISEvent_Value      ev2  on ed.EPCISEventID = ev2.EPCISEventID
		WHERE 
			ev.VocabularyTypeURN = N'urn:quibiq:epcis:vtype:action' and (ev.VocabularyURN = N'urn:quibiq:epcis:cbv:action:observe' or ev.VocabularyURN = N'urn:quibiq:epcis:cbv:action:delete')
		and ev2.[ValueTypeTypeURN] = N'urn:quibiq:epcis:vtype:ilmd'
		and ev3.VocabularyTypeURN = N'urn:quibiq:epcis:vtype:event' and (ev3.VocabularyURN = N'urn:quibiq:epcis:cbv:event:object')
		group by ed.EPCISEventID, ev.VocabularyURN;

		-- Prüfung AggregationEvent != DELETE childEpcList oder qunatityList oder beides
		INSERT INTO #EPCISEvent_Error 
			(  EPCISEventID
			 , Reason)
		SELECT 
			  ed.EPCISEventID
			, N'Aggregation-Event mit Action:''' + UPPER(SUBSTRING(ev.VocabularyURN, 29, LEN(ev.VocabularyURN)-28)) + ''' ohne childEpcList oder childQuantityList'
		FROM #EventData ed
		JOIN #EPCISEvent_Vocabulary ev   on ed.EPCISEventID = ev.EPCISEventID
		JOIN #EPCISEvent_Vocabulary ev3  on ed.EPCISEventID = ev3.EPCISEventID
		LEFT JOIN #EPCISEvent_EPC   ec			  on ed.EPCISEventID = ec.EPCISEventID
		LEFT JOIN #EPCISEvent_QuantityElement qe   on ed.EPCISEventID = qe.EPCISEventID
		WHERE 
			ev.VocabularyTypeURN = N'urn:quibiq:epcis:vtype:action' and (ev.VocabularyURN = N'urn:quibiq:epcis:cbv:action:observe' or ev.VocabularyURN = N'urn:quibiq:epcis:cbv:action:add')
		and ec.EPCURN is null 
		and qe.EPCClassURN is null
		and ev3.VocabularyTypeURN = N'urn:quibiq:epcis:vtype:event' and (ev3.VocabularyURN = N'urn:quibiq:epcis:cbv:event:aggregation')
		group by ed.EPCISEventID, ev.VocabularyURN;

		-- Prüfung TransactionEvent != DELETE childEpcList oder qunatityList oder beides
		INSERT INTO #EPCISEvent_Error 
			(  EPCISEventID
			 , Reason)
		SELECT 
			  ed.EPCISEventID
			, N'Transaction-Event mit Action:''' + UPPER(SUBSTRING(ev.VocabularyURN, 29, LEN(ev.VocabularyURN)-28)) + ''' ohne childEpcList oder childQuantityList'
		FROM #EventData ed
		JOIN #EPCISEvent_Vocabulary ev   on ed.EPCISEventID = ev.EPCISEventID
		JOIN #EPCISEvent_Vocabulary ev3  on ed.EPCISEventID = ev3.EPCISEventID
		LEFT JOIN #EPCISEvent_EPC   ec			  on ed.EPCISEventID = ec.EPCISEventID
		LEFT JOIN #EPCISEvent_QuantityElement qe   on ed.EPCISEventID = qe.EPCISEventID
		WHERE 
			ev.VocabularyTypeURN = N'urn:quibiq:epcis:vtype:action' and (ev.VocabularyURN = N'urn:quibiq:epcis:cbv:action:observe' or ev.VocabularyURN = N'urn:quibiq:epcis:cbv:action:add')
		and ec.EPCURN is null 
		and qe.EPCClassURN is null
		and ev3.VocabularyTypeURN = N'urn:quibiq:epcis:vtype:event' and (ev3.VocabularyURN = N'urn:quibiq:epcis:cbv:event:transaction')
		group by ed.EPCISEventID, ev.VocabularyURN;

		-- Prüfung TransformationEvent ohne transformationID
		INSERT INTO #EPCISEvent_Error 
			(  EPCISEventID
			 , Reason)
		SELECT 
			  ed.EPCISEventID
			, N'Transformation-Event ohne transformationID muss mindestens einen Input (epc/quantity) und einen Output (epc/quantity) besitzen.'
		FROM #EventData ed
		JOIN #EPCISEvent_Vocabulary ev			  on ed.EPCISEventID = ev.EPCISEventID
		LEFT JOIN #EPCISEvent_TransformationID et  on ed.EPCISEventID = et.EPCISEventID
		WHERE 
			et.TransformationIDURN is null
		and ev.VocabularyTypeURN = N'urn:quibiq:epcis:vtype:event' and ev.VocabularyURN = N'urn:quibiq:epcis:cbv:event:transformation'

		and 
		(
				(not exists (select top 1 1 from #EPCISEvent_EPC where EPCISEventID = ed.EPCISEventID and IsInput = 1)
			and not exists (select top 1 1 from #EPCISEvent_QuantityElement where EPCISEventID = ed.EPCISEventID and IsInput = 1))
	 
			or

			(not exists (select top 1 1 from #EPCISEvent_EPC where EPCISEventID = ed.EPCISEventID and IsOutput = 1)
			and not exists (select top 1 1 from #EPCISEvent_QuantityElement where EPCISEventID = ed.EPCISEventID and IsInput = 0))
		)

		group by ed.EPCISEventID;

		-- Prüfung TransformationEvent mit transformationID
		INSERT INTO #EPCISEvent_Error 
			(  EPCISEventID
			 , Reason)
		SELECT 
			  ed.EPCISEventID
			, N'Transformation-Event mit transformationID muss entweder einen Input (epc/quantity) oder einen Output (epc/quantity) besitzen.'
		FROM #EventData ed
		JOIN #EPCISEvent_Vocabulary ev			  on ed.EPCISEventID = ev.EPCISEventID
		JOIN #EPCISEvent_TransformationID et		  on ed.EPCISEventID = et.EPCISEventID
		WHERE 
		ev.VocabularyTypeURN = N'urn:quibiq:epcis:vtype:event' and (ev.VocabularyURN = N'urn:quibiq:epcis:cbv:event:transformation')

		and  (not exists (select top 1 1 from #EPCISEvent_EPC where EPCISEventID = ed.EPCISEventID and IsInput = 1)
		 and not exists (select top 1 1 from #EPCISEvent_QuantityElement where EPCISEventID = ed.EPCISEventID and IsInput = 1))
	    
		and  (not exists (select top 1 1 from #EPCISEvent_EPC where EPCISEventID = ed.EPCISEventID and IsOutput = 1)
		  and not exists (select top 1 1 from #EPCISEvent_QuantityElement where EPCISEventID = ed.EPCISEventID and IsInput = 0) )

		group by ed.EPCISEventID;

		--***************************************************************
		-- Debug OUT aus Zwischenstruktur 
		--***************************************************************
		IF @Debug = 1
		begin
			select 
				EPCISEventID,
				[ClientID],
				[EventTime],
				[RecordTime],
				[EventTimeZoneOffset],
				[EPCISRepresentation]
		    from 
				#EventData;

			select 
				BusinessTransactionIDURN,
				BusinessTransactionTypeURN,
				VocabularyTypeURN,
				BusinessTransactionIDID,
				BusinessTransactionTypeID,
				VocabularyTypeID,
				EPCISEventID
			from
				#EPCISEvent_BusinessTransactionID;

			select 
				QuantityElementID,
				EPCClassID,
				EPCClassURN,
				Quantity,
				IsInput,
				IsOutput,
				UOM,
				EPCISEventID
			from
				#EPCISEvent_QuantityElement;

			select 
				TransformationIDID,
				TransformationIDURN,
				EPCISEventID
			from
				#EPCISEvent_TransformationID;

			select 
				SourceDestinationID,
				SourceDestinationTypeID,
				SourceDestinationTypeURN,
				SourceDestinationURN,
				IsSource,
				EPCISEventID
			from
				#EPCISEvent_SourceDestination;

			select  
				EPCURN,
				EPCID,
				EPCISEventID,
				IsParentID,
				IsInput,
				IsOutput
			from
				#EPCISEvent_EPC;

			select 
				VocabularyTypeURN,
				VocabularyURN,
				VocabularyTypeID,
				ID,
				EPCISEventID
			from
				#EPCISEvent_Vocabulary;

			select 
				ValueTypeURN,
				ValueTypeTypeURN,
				DataTypeURN,
				DataTypeTypeURN,
				ValueTypeID,
				ValueTypeTypeID,
				DataTypeID,
				DataTypeTypeID,
				EPCISEventID,
				IntValue,
				FloatValue,
				TimeValue,
				StringValue,
				ParentURN,
				Depth,
				ExtensionType
			from 
				#EPCISEvent_Value;

			select  
				EPCISEventID,
				ExtensionTypeURN,
				ExtensionTypeTypeURN
			from 
				#EPCISEvent_ExtenstionType;

			select  
				EPCISEventID,
				TechnicalEPCISEventID 
			from 
				#EPCISEventIDs;

			select
				EPCISEventID,
				Reason
			from
				#EPCISEvent_Error;
		end;

		--***************************************************************
		-- Entfernen Fehlerhafter Events aus Zwischenstruktur 
		--***************************************************************
		IF exists (select top 1 1 from #EPCISEvent_Error)
		begin
			
			if @ProcessOnlyWholeDocument = 1 
			begin
				-- Fehlertext erstellen
				declare @curErrorText nvarchar(256);
				declare @errMessage   nvarchar(4000);
				set @errMessage = N'Following Errors occured while processing EventList: ';

				declare curError INSENSITIVE cursor for
					select
						Reason
					from #EPCISEvent_Error;
						
				open curError
				fetch next from curError into @curErrorText

				while @@FETCH_STATUS = 0
				begin
					set @errMessage = SUBSTRING(@errMessage, 1, 3744) + @curErrorText;
					fetch next from curError into @curErrorText
				end;

				-- Fehler werfen
				throw 53000, @errMessage, 1;
			end;

			-- Falls Einzelevents verarbeitet werden können
			
			delete d from 
				#EPCISEvent_BusinessTransactionID d
			join #EPCISEvent_Error e on e.EPCISEventID = d.EPCISEventID;

			delete d from 
				#EPCISEvent_EPC d
			join #EPCISEvent_Error e on e.EPCISEventID = d.EPCISEventID;

			delete d from 
				#EPCISEvent_Vocabulary d
			join #EPCISEvent_Error e on e.EPCISEventID = d.EPCISEventID;

			delete d from 
				#EPCISEvent_Value d
			join #EPCISEvent_Error e on e.EPCISEventID = d.EPCISEventID;
				
			delete d from 
				#EPCISEvent_ExtenstionType d
			join #EPCISEvent_Error e on e.EPCISEventID = d.EPCISEventID;
		end;

		--***************************************************************
		-- Events in Tabelle speichern und Konvertierung der EPCISEventID
		--***************************************************************
		 
		merge into Event.[EPCISEvent] as target
		using #EventData as source
		on 1 = 0
		when not matched by target then
			insert (ClientID, EventTime, RecordTime, EventTimeZoneOffset, [XmlRepresentation])
		    values (source.ClientID, source.EventTime, source.RecordTime, source.EventTimeZoneOffset, source.EPCISRepresentation)
		output source.EPCISEventID , inserted.[ID] into #EPCISEventIDs;

		update  
			t
		set t.EPCISEventID = s.TechnicalEPCISEventID
		from #EPCISEvent_BusinessTransactionID t
		join #EPCISEventIDs                    s on s.EPCISEventID = t.EPCISEventID;
		
		update  
			t
		set t.EPCISEventID = s.TechnicalEPCISEventID
		from #EPCISEvent_EPC t
		join #EPCISEventIDs                    s on s.EPCISEventID = t.EPCISEventID;

		update  
			t
		set t.EPCISEventID = s.TechnicalEPCISEventID
		from #EPCISEvent_Vocabulary t
		join #EPCISEventIDs                    s on s.EPCISEventID = t.EPCISEventID;

		update  
			t
		set t.EPCISEventID = s.TechnicalEPCISEventID
		from #EPCISEvent_Value t
		join #EPCISEventIDs                    s on s.EPCISEventID = t.EPCISEventID;

		update  
			t
		set t.EPCISEventID = s.TechnicalEPCISEventID
		from #EPCISEvent_ExtenstionType t
		join #EPCISEventIDs                    s on s.EPCISEventID = t.EPCISEventID;

		update  
			t
		set t.EPCISEventID = s.TechnicalEPCISEventID
		from #EPCISEvent_TransformationID t
		join #EPCISEventIDs                    s on s.EPCISEventID = t.EPCISEventID;

		update  
			t
		set t.EPCISEventID = s.TechnicalEPCISEventID
		from #EPCISEvent_SourceDestination t
		join #EPCISEventIDs                    s on s.EPCISEventID = t.EPCISEventID;

		update  
			t
		set t.EPCISEventID = s.TechnicalEPCISEventID
		from #EPCISEvent_QuantityElement t
		join #EPCISEventIDs                    s on s.EPCISEventID = t.EPCISEventID;


		-- Einzeleventfehler speichern - falls vorhanden
		IF exists (select top 1 1 from #EPCISEvent_Error)
		begin
			
			update  
				t
			set t.EPCISEventID = s.TechnicalEPCISEventID
			from #EPCISEvent_Error t
			join #EPCISEventIDs                    s on s.EPCISEventID = t.EPCISEventID;

			INSERT INTO [Import].[Error] (
				[TimeStampGeneration]
				,[AdditionalInformation]
				,[ErrorNumber]
				,[ErrorSeverity]
				,[ErrorProcedure]
				,[ErrorMessage]
				,[ErrorLine]
				,[ErrorState]
				,[ObjectID] )
			SELECT
				getdate()								   as TimeStampGeneration
				,N'ObjectID: Event.ID'				   as AdditionalInformation
				,55555								   as ErrorNumber
				,16										   as ErrorSeverity
				,N'usp_Import_Event'			           as ErrorProcedure
				,SUBSTRING(Reason, 1, 2048)	               as ErrorMessage
				,0						                   as ErrorLine
				,1						                   as ErrorState 
				,EPCISEventID							   as ObjectID
			FROM #EPCISEvent_Error;

		end;
					
		--***************************************************************
		-- Geprüfte Event Daten speichern
		--***************************************************************
		-- Da die interen EPCISEventIDs gegen die technischen ausgetauscht wurden ist nichts weiter zu beachten

		--***************************************************************
		-- EventVokabeln: IDs speichern
		--***************************************************************

		merge into Event.[EPCISEvent_Vocabulary] as target
			using #EPCISEvent_Vocabulary as source
		on target.[EPCISEventID] = source.EPCISEventID and target.[ID] = source.ID
		when not matched by target then
			insert ([EPCISEventID], [VocabularyID])
				values (source.EPCISEventID, source.ID);

		--***************************************************************
		-- EPC: EPCIDs zu den gesammelten EPCs bestimmen
		--***************************************************************

		merge into Event.EPC WITH (HOLDLOCK) as target									
		using (select distinct EPCURN from #EPCISEvent_EPC) as source
		on target.URN = source.EPCURN
		when not matched by target then
			insert(URN)
				values (source.EPCURN);

		merge into #EPCISEvent_EPC as target
		using Event.EPC as source
		on target.EPCURN = source.URN
		when matched then
			update set EPCID = source.[ID];


		--***************************************************************
		-- EventEPC: IDs speichern
		--***************************************************************		

		merge into Event.[EPCISEvent_EPC] as target
		using (select 
				  EPCISEventID,
				  EPCID,
				  IsParentID,
				  IsInput,
				  IsOutput
				from #EPCISEvent_EPC 
				group by EPCISEventID, EPCID, IsParentID, IsInput, IsOutput)  as source
		on target.[EPCISEventID] = source.EPCISEventID and target.EPCID = source.EPCID
		when not matched by target then
			insert ([EPCISEventID], EPCID, [IsParentID], [IsInput], [IsOutput])
				values (source.EPCISEventID , source.EPCID, source.IsParentID, source.IsInput, source.IsOutput);

		--***************************************************************
		-- TransformationID: IDs speichern
		--***************************************************************

		merge into Event.TransformationID WITH (HOLDLOCK) as target					
		using (	select 
					TransformationIDURN
				from #EPCISEvent_TransformationID
				group by TransformationIDURN
			) as source
		on target.URN = source.TransformationIDURN
		when not matched by target then
			insert (URN)
				values (source.TransformationIDURN);

		merge into #EPCISEvent_TransformationID as target
		using Event.TransformationID as source
		on target.TransformationIDURN = source.URN
		when matched then
			update set TransformationIDID = source.[ID];
	
		--***************************************************************
		-- EventTransformationID: IDs speichern
		--***************************************************************

		merge into Event.[EPCISEvent_TransformationID] as target
		using(	select 
					EPCISEventID, TransformationIDID
				from #EPCISEvent_TransformationID
				group by EPCISEventID, TransformationIDID 
				)  as source
		on target.[EPCISEventID] = source.EPCISEventID and target.TransformationIDID = source.TransformationIDID
		when not matched by target then
			insert ([EPCISEventID], TransformationIDID)
				values (source.EPCISEventID, source.TransformationIDID);

		--***************************************************************
		-- QuantityElement: IDs speichern
		--***************************************************************

		merge into Event.QuantityElement WITH (HOLDLOCK) as target					
		using (	select 
					EPCClassID, Quantity, UOM 
				from #EPCISEvent_QuantityElement
				group by EPCClassID, Quantity, UOM
			) as source
		on target.EPCClassID = source.EPCClassID and target.Quantity = source.Quantity and target.UOM = source.UOM
		when not matched by target then
			insert (EPCClassID, Quantity, UOM)
				values (source.EPCClassID, source.Quantity, source.UOM);

		merge into #EPCISEvent_QuantityElement as target
		using Event.QuantityElement as source
		on target.EPCClassID = source.EPCClassID and target.Quantity = source.Quantity and target.UOM = source.UOM
		when matched then
			update set QuantityElementID = source.[ID];
	
		--***************************************************************
		-- EventQuantityElement: IDs speichern
		--***************************************************************

		merge into Event.[EPCISEvent_QuantityElement] as target
		using(	select 
					EPCISEventID, QuantityElementID, IsInput, IsOutput
				from #EPCISEvent_QuantityElement
				group by EPCISEventID, QuantityElementID, IsInput, IsOutput 
				)  as source
		on target.[EPCISEventID] = source.EPCISEventID and target.QuantityElementID = source.QuantityElementID
		when not matched by target then
			insert ([EPCISEventID], QuantityElementID, IsInput, IsOutput)
				values (source.EPCISEventID, source.QuantityElementID, source.IsInput, source.IsOutput);


		--***************************************************************
		-- EventSourceDestination: IDs speichern
		--***************************************************************

		merge into Event.[EPCISEvent_SourceDestination] as target
		using(	select 
					EPCISEventID, SourceDestinationID, SourceDestinationTypeID, IsSource 
				from #EPCISEvent_SourceDestination
				group by EPCISEventID, SourceDestinationID, SourceDestinationTypeID, IsSource
				)  as source
		on target.[EPCISEventID] = source.EPCISEventID and target.SourceDestinationID = source.SourceDestinationID and target.SourceDestinationTypeID = source.SourceDestinationTypeID and target.IsSource = source.IsSource
		when not matched by target then
			insert ([EPCISEventID], SourceDestinationID, SourceDestinationTypeID, IsSource)
				values (source.EPCISEventID, source.SourceDestinationID, source.SourceDestinationTypeID, source.IsSource);


		--***************************************************************
		-- BusinessTransaction: IDs speichern
		--***************************************************************

		merge into Event.BusinessTransactionID WITH (HOLDLOCK) as target			
		using (	select 
					BusinessTransactionTypeID, BusinessTransactionIDURN 
				from #EPCISEvent_BusinessTransactionID
				group by BusinessTransactionTypeID, BusinessTransactionIDURN 
			) as source
		on target.BusinessTransactionTypeID = source.BusinessTransactionTypeID and target.URN = source.BusinessTransactionIDURN
		when not matched by target then
			insert (URN, BusinessTransactionTypeID)
				values (source.BusinessTransactionIDURN, source.BusinessTransactionTypeID);

		merge into #EPCISEvent_BusinessTransactionID as target
		using Event.BusinessTransactionID as source
		on target.BusinessTransactionTypeID = source.BusinessTransactionTypeID and target.BusinessTransactionIDURN = source.URN
		when matched then
			update set BusinessTransactionIDID = source.ID;
	
		--***************************************************************
		-- EventBusinessTransaction: IDs speichern
		--***************************************************************

		merge into Event.EPCISEvent_BusinessTransactionID as target
		using(	select 
					EPCISEventID, BusinessTransactionIDID 
				from #EPCISEvent_BusinessTransactionID
				group by EPCISEventID, BusinessTransactionIDID 
				)  as source
		on target.EPCISEventID = source.EPCISEventID and target.BusinessTransactionIDID = source.BusinessTransactionIDID
		when not matched by target then
			insert (EPCISEventID, BusinessTransactionIDID)
				values (source.EPCISEventID, source.BusinessTransactionIDID);


		--***************************************************************
		-- EPCISHeader: IDs speichern
		--***************************************************************

		if @StandardBusinessDocumentHeader is not null and @StandardBusinessDocumentHeader.exist(N'/*[local-name() = "StandardBusinessDocumentHeader"]') = 1
		begin

			DECLARE @EPCISDocumentHeader table (DocumentHeaderID bigint);
			DECLARE @HeaderVersion CHAR(10);

			SET @HeaderVersion = @StandardBusinessDocumentHeader.value(N'(//*[local-name() = "HeaderVersion"]/text())[1]', 'char(10)');

			insert into DocumentHeader.EPCISDocumentHeader (EPCISDocumentHeader, HeaderVersion) 
				output Inserted.ID into @EPCISDocumentHeader
			values (@StandardBusinessDocumentHeader, @HeaderVersion)

			insert into Event.EPCISEvent_DocumentHeader (DocumentHeaderID, EPCISEventID) 
			select
				 (select top 1 DocumentHeaderID from @EPCISDocumentHeader)
				,e.TechnicalEPCISEventID
			from #EPCISEventIDs e
			group by e.TechnicalEPCISEventID;

		end;

		--***************************************************************
		-- EPCISEvent_Extensions: Neue Extensions dynamisch anlegen
		--***************************************************************

		merge into Vocabulary.[Vocabulary] WITH (HOLDLOCK) as target
		using ( select 
					 e.ExtensionTypeURN
					,vt.ID as [VocabularyTypeID]
					,@SystemClientID as ClientID
				from #EPCISEvent_ExtenstionType e 
				join Vocabulary.[VocabularyType]  vt on vt.URN = e.ExtensionTypeTypeURN
				group by e.ExtensionTypeURN, vt.ID
		) as source
		on target.URN                = source.ExtensionTypeURN and
		   target.[VocabularyTypeID] = source.[VocabularyTypeID] and
		   target.ClientID           = source.ClientID
			when matched then
				update set Deleted = 0
		when not matched by target then
			insert (ClientID, [VocabularyTypeID], URN) 
			values (source.ClientID, source.[VocabularyTypeID], source.ExtensionTypeURN);

		--***************************************************************
		-- EPCISEvent_Value: IDs zu den gesammelten URN bestimmen
		--***************************************************************

		merge into #EPCISEvent_Value as target
		using Vocabulary.[VocabularyType] as source
		on target.ValueTypeTypeURN = source.URN 
		when matched then
			update set ValueTypeTypeID = source.[ID];

		merge into #EPCISEvent_Value as target
		using Vocabulary.[VocabularyType] as source
		on target.DataTypeTypeURN = source.URN
		when matched then
			update set DataTypeTypeID = source.[ID];

		merge into #EPCISEvent_Value as target
		using Vocabulary.[Vocabulary] as source
		on target.ValueTypeURN = source.URN and target.ValueTypeTypeID = source.[VocabularyTypeID]
		when matched then
			update set ValueTypeID = source.[ID];

		merge into #EPCISEvent_Value as target
		using Vocabulary.[Vocabulary] as source
		on target.DataTypeURN = source.URN and target.DataTypeTypeID = source.[VocabularyTypeID]
		when matched then
			update set DataTypeID = source.[ID];

		--***************************************************************
		-- EPCISEvent_Value/EPCISEvent_Extensions speichern
		--***************************************************************

		-- EPCISEvent_Value Einträge generieren (ex können mehrere je Event existieren,
		-- Merge Funktion erleichtert jedoch die Parent/Child auflösung
		merge into Event.[EPCISEvent_Value] as target
		using 
			(select
				 ValueTypeID
				,ValueTypeURN
				,DataTypeID
				,DataTypeURN
				,IntValue
				,FloatValue
				,TimeValue
				,StringValue
				,ParentURN
				,EPCISEventID
				,Depth
			FROM #EPCISEvent_Value 
			)
			as source
		on 
			1 = 0
		when not matched by target then
			insert ([EPCISEventID], ValueTypeID, DataTypeID)
				values (source.EPCISEventID, source.ValueTypeID, source.DataTypeID)
		output 
			inserted.[ID]           as EPCISEvent_ValueID,
			source.ValueTypeURN     as ValueTypeURN,
			source.DataTypeURN      as DataTypeURN,
			source.IntValue         as IntValue,
			source.FloatValue       as FloatValue,
			source.TimeValue        as TimeValue,
			source.StringValue      as StringValue,
			source.ParentURN        as ParentURN,
			null                    as Parent_EPCISEvent_ValueID,
			source.Depth            as Depth	   
			into #EPCISEvent_Value_Values;
		;

	    -- Da die Extension Inhalte nicht definiert werden ist es für die Abfrageoberfläche einfacher das Datum in jedem
		-- gültigen Format abzuspeichern, so kann eine effiziente / einfache und schnelle Abfrage erfolgen auf 
		-- Kosten von Datenredundanzen

		-- Numeric Values (Float und Int)
		merge into Event.[EPCISEvent_Value_Numeric] as target
		using ( select 
					   EPCISEvent_ValueID
					  ,FloatValue as Value
				from
					#EPCISEvent_Value_Values
				where FloatValue is not null )
		as source
		on 
			target.[EPCISEvent_ValueID] = source.EPCISEvent_ValueID
		and target.Value              = source.Value 
		when not matched by target then
			insert ([EPCISEvent_ValueID], Value) 
			values (source.EPCISEvent_ValueID, source.Value);

		-- Time
		merge into Event.[EPCISEvent_Value_Datetime] as target
		using ( select 
					   EPCISEvent_ValueID
					  ,TimeValue as Value
				from
					#EPCISEvent_Value_Values
				where TimeValue is not null )
		as source
		on 
			target.[EPCISEvent_ValueID] = source.EPCISEvent_ValueID
		and target.Value              = source.Value 
		when not matched by target then
			insert ([EPCISEvent_ValueID], Value) 
			values (source.EPCISEvent_ValueID, source.Value);

		-- String		
		merge into Event.Value_String WITH (HOLDLOCK) as target			
		using ( select 
					   StringValue as Value
				from
					#EPCISEvent_Value_Values
				where StringValue is not null
				group by StringValue )
		as source
		on 
		  target.Value              = source.Value 
		when not matched by target then
			insert (Value) 
			values (source.Value);


		merge into Event.[EPCISEvent_Value_String] as target
		using (
				select 
					vv.EPCISEvent_ValueID,
					vs.[ID] as Value_StringID
				from #EPCISEvent_Value_Values vv
				join Event.Value_String       vs on vs.Value = vv.StringValue
		
		      ) as source
		on 
			target.[EPCISEvent_ValueID] = source.EPCISEvent_ValueID
		and target.Value_StringID     = source.Value_StringID 
		when not matched by target then
			insert ([EPCISEvent_ValueID], Value_StringID) 
			values (source.EPCISEvent_ValueID, source.Value_StringID);

		-- XML / Parents 
		-- Parents Ermitteln

		UPDATE #EPCISEvent_Value_Values 
		  set Parent_EPCISEvent_ValueID = parent.EPCISEvent_ValueID
		  FROM #EPCISEvent_Value_Values children
		  JOIN (SELECT
					 EPCISEvent_ValueID
					,ValueTypeURN
					,Depth
				FROM #EPCISEvent_Value_Values) as parent on  parent.ValueTypeURN = children.ParentURN
		                                                 and parent.Depth        = (children.Depth-1)
		  WHERE children.Depth > 0;

		-- Hierarchy speichern
		merge into Event.[EPCISEvent_Value_Hierarchy] as target
		using ( select 
					   [EPCISEvent_ValueID]
					  ,[Parent_EPCISEvent_ValueID]
				from
					#EPCISEvent_Value_Values
				where Depth > 0 )
		as source
		on 
			target.[EPCISEvent_ValueID]		   = source.[EPCISEvent_ValueID] 
		and target.[Parent_EPCISEvent_ValueID] = source.[Parent_EPCISEvent_ValueID]
		when not matched by target then
			insert ([EPCISEvent_ValueID], [Parent_EPCISEvent_ValueID]) 
			values (source.[EPCISEvent_ValueID], source.[Parent_EPCISEvent_ValueID]);

END
GO
PRINT N'Creating [Import].[usp_Import_EPCISEvent_Value]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS1_1
-- Firma:    QUIBIQ
-- (c) 2015  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 26.02.2015 | 1.0.0.0 | Florian Wagner      | Insert EPCISEvent_Value Vocabulary Element
-----------------------------------------------------------------------------------------
CREATE PROCEDURE [Import].[usp_Import_EPCISEvent_Value]
	@EPCISEventID    bigint,
	@ValueTypeID     bigint,
	@DataTypeID		 bigint
AS
BEGIN

		insert into Event.EPCISEvent_Value (
			[EPCISEventID],	
			[ValueTypeID],	
			[DataTypeID]
			)
		OUTPUT inserted.ID
		select
			@EPCISEventID as [EPCISEventID],
			@ValueTypeID as [ValueTypeID],
			@DataTypeID as [DataTypeID]

END;
GO
PRINT N'Creating [Import].[usp_XML_Validation_Error]...';


GO
CREATE PROCEDURE  [Import].[usp_XML_Validation_Error](
	@Document xml,
	@Client nvarchar(255) = N'urn:quibiq:epcis:cbv:client:gmos',
	@AdditionalInformation nvarchar(2048),
	@ErrorNumber int,
	@ErrorProcedure nvarchar(126),
	@ErrorMessage nvarchar(2048),
	@ErrorLine int)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	begin try

		begin transaction

			declare @ErrorQueue table (
				ID bigint
			);

			declare @ErrorQueueID bigint;

			-- Fehlerprotokoll
			INSERT INTO [Import].[EPCISEvent_Queue] 
				(EPCISEvent
				,Client
				,Processed
				,Error)
			OUTPUT inserted.ID INTO @ErrorQueue
			VALUES
				(@Document
				,@Client
				,0
				,1)
			
			SELECT TOP 1 @ErrorQueueID = ID FROM @ErrorQueue;

			INSERT INTO [Import].[Error]
			   ([TimeStampGeneration]
			   ,[AdditionalInformation]
			   ,[ErrorNumber]
			   ,[ErrorSeverity]
			   ,[ErrorProcedure]
			   ,[ErrorMessage]
			   ,[ErrorLine]
			   ,[ErrorState]
			   ,[ObjectID])
			VALUES
			   (getdate()
			   ,@AdditionalInformation
			   ,@ErrorNumber
			   ,0
			   ,@ErrorProcedure 
			   ,@ErrorMessage
			   ,@ErrorLine
			   ,0
			   ,@ErrorQueueID)

		commit transaction

	end try
	begin catch
		rollback transaction

			-- Rethrow Error with extended Error Message
			DECLARE @ErrorMsg		nvarchar(4000) = ERROR_MESSAGE();
			DECLARE @ErrorState		int			   = isnull(ERROR_STATE(), 1);

			SET @ErrorMsg = N'Error while storing to Event QUEUE' + SUBSTRING(@ErrorMsg, 1, 3962);

			THROW 51000, @ErrorMsg, @ErrorState;

		end catch;

END
GO
PRINT N'Creating [Callback].[usp_get_Subscription]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2013  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 15.07.2013 | 1.0.0.0 | Florian Wagner      | Erstellt.
-- 26.06.2017 | 1.1.0.0 | Sascha Laabs        | Namespace Änderung durchgeführt. (http://epcis.migros.net/gmos/ -> http://migros.net/gmos/)
-----------------------------------------------------------------------------------------
CREATE PROCEDURE [Callback].[usp_get_Subscription]
	@Client nvarchar(255) = null	-- if empty it works for all Clients
AS
BEGIN

	SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
	SET NOCOUNT ON;
	-- exec [Callback].[usp_get_Subscription]
	-- Monday is 1 - Saturday is 7
	SET DATEFIRST 1;

	BEGIN TRANSACTION;

	-- Declarations
	DECLARE
		@This					datetime2(0) = CAST(getutcdate() as datetime2(0)),
		@Result					xml = CONVERT(xml,N'<ecw:EPCISCallbackWrapper xmlns:ecw="urn:quibiq:epcis:callbackwrapper"/>'),
		@CurQuery				xml,
		@CurDestinationEndpoint nvarchar(512),
		@CurReportIfEmpty       bit,
		@CurRecordTime			datetime2(0),
		@InstanceIdentifier		int,
		@CurUserName            nvarchar(512),
		@CurSubscription		nvarchar(512),
		@CurClient              nvarchar(512);

	BEGIN TRY;

		IF exists(SELECT TOP 1 1
			FROM [Callback].[Schedule] s
			JOIN [Callback].[Subscription]          sub on sub.ID = s.SubscriptionID
			WHERE sub.Active = 1
			  and s.[NextRun] <= @This
		)
		BEGIN
			
			-- Selectiere alle Subscriptions die für den nächsten Lauf zu berücksichtigen sind
			;WITH XMLNAMESPACES (N'urn:quibiq:epcis:callbackwrapper' as epw,
								 N'urn:epcglobal:epcis-query:xsd:1' as equ,
								 N'http://www.unece.org/cefact/namespaces/StandardBusinessDocumentHeader' as sbdh)
			SELECT @Result = (
			SELECT 
				 sub.Subscription
				,[Helper].[svf_get_StandardBusinessDocumentHeader] ( v.URN, sub.Username, N'EPCISQueryDocument' ) as EPCISHeader
				,sub.Query.query('<equ:Poll>
									{/equ:Poll/queryName/.}
								   <params>
									<param>
										<name>GE_recordTime</name>
										<value>{max((sql:column("LastRecordTime"), sql:column("InitialRecordTime")))}Z</value>
									</param>
									<param>
										<name>LT_recordTime</name>
										<value>{sql:variable("@This")}Z</value>
									</param>	
									{
									if (sql:column("receiverGLN") != "all")
										then (/equ:Poll/params/*[name/text() != "GT_recordTime" and name/text() != "LE_recordTime" and name/text() != "GE_recordTime" and name/text() != "LT_recordTime" and name/text() != "SECURITY_http://migros.net/gmos/" ])
										
										else (/equ:Poll/params/*[name/text() != "GT_recordTime" and name/text() != "LE_recordTime" and name/text() != "GE_recordTime" and name/text() != "LT_recordTime" ])
									}
									{
									if (sql:column("receiverGLN") != "all")
										then (<param>
												<name>SECURITY_http://migros.net/gmos/</name>
												<value>{sql:column("receiverGLN")}</value>
											  </param>)
										else ()
									}
								   </params>
								  </equ:Poll>') as [Query]
				,va.Value.query('/Value/*') as [SOAPQueryControlEndpoints]
				,sub.DestinationEndpoint as [HTTPReceiverEndpoint]
				,sub.ReportIfEmpty as [ForwardEmptyResult]
			FROM [Callback].[Schedule] s
			JOIN [Callback].[Subscription]               sub on sub.ID          = s.SubscriptionID
			-- Client
			JOIN [Vocabulary].[Vocabulary]				 v   on v.ID            = sub.ClientID 
			-- Query Control Endpoint Information
			LEFT JOIN [Vocabulary].[VocabularyAttribute] va  on va.VocabularyID = sub.ClientID 
			LEFT JOIN [Vocabulary].[AttributeType]       at  on at.ID           = va.AttributeTypeID
			-- Query Filters
			CROSS APPLY [Helper].[tvf_get_User_Queryfilter] (v.URN , sub.Username) qf
			WHERE sub.Active = 1
			  and s.[NextRun] <= @This
			  and at.URN  = N'urn:quibiq:epcis:atype:querycontrolendpoint'
			  and (@Client is null or v.URN = @Client)
			FOR XML PATH ('EPCISCallbackRequest'), ROOT ('epw:EPCISCallbackWrapper'), ELEMENTS XSINIL
			);

			-- Update Timestamps
			UPDATE [Callback].[Subscription]
				SET [LastRecordTime] = @This
			FROM [Callback].[Schedule] s
			JOIN [Callback].[Subscription]          sub on sub.ID  = s.SubscriptionID
			WHERE sub.Active = 1
			  and s.[NextRun] <= @This;

			-- Update Laufnummern
			DECLARE curUsername INSENSITIVE CURSOR FOR
				SELECT 
					sub.Subscription,
					sub.Username,
					syc.URN as Client
				FROM [Callback].[Schedule] s
				JOIN [Callback].[Subscription]          sub on sub.ID               = s.SubscriptionID
				JOIN Vocabulary.Vocabulary              syc on sub.ClientID          = syc.ID
				JOIN Vocabulary.VocabularyType          svt on syc.VocabularyTypeID  = svt.ID
				WHERE svt.URN      = N'urn:quibiq:epcis:vtype:client'
				  and sub.Active   = 1
				  and s.[NextRun] <= @This;

			OPEN curUsername;

			FETCH NEXT FROM curUsername INTO @CurSubscription, @CurUserName, @CurClient;

			WHILE @@FETCH_STATUS = 0
			BEGIN

				-- jede Subsription muss ihre eigene Laufnummer haben, es könnten gleichzeitig mehrere Subsriptions von
				-- einem User ausgeführt werden

				-- nächster Identifier
				EXEC [Helper].[usp_Update_InstanceIdentifier] 
					@Client				= @CurClient,
					@Username			= @CurUserName,
					@InstanceIdentifier = @InstanceIdentifier OUT;
				
				-- Subsription anpassen
				SET @Result.modify(N'declare namespace epw="urn:quibiq:epcis:callbackwrapper";
								   declare namespace equ="urn:epcglobal:epcis-query:xsd:1";
								   declare namespace sbdh="http://www.unece.org/cefact/namespaces/StandardBusinessDocumentHeader";
			
								   replace value of (/epw:EPCISCallbackWrapper/EPCISCallbackRequest/Subscription[text() = sql:variable("@CurSubscription")]/
								   ../EPCISHeader/sbdh:StandardBusinessDocumentHeader/sbdh:DocumentIdentification/sbdh:InstanceIdentifier/text())[1]
								   with sql:variable("@InstanceIdentifier")');

				FETCH NEXT FROM curUsername INTO @CurSubscription, @CurUserName, @CurClient;
			END;

			CLOSE curUsername;
			DEALLOCATE curUsername;

			UPDATE [Callback].[Schedule] 
				SET [NextRun] = [Callback].[svf_Calc_Next_Run] ([ID], @This)
			WHERE   [NextRun] <= @This;

		END

		SELECT @Result;

		COMMIT TRANSACTION;

	END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION;

		-- Return something
		SELECT @Result = CONVERT(xml,N'<ecw:EPCISCallbackWrapper xmlns:ecw="urn:quibiq:epcis:callbackwrapper"/>');
		SELECT @Result;
	END CATCH;

END;
GO
PRINT N'Creating [Helper].[usp_Reprocess_MasterData_From_Queue]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2013  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 06.08.2013 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
-- 03.09.2014 | 1.0.1.0 | Florian Wagner      | Mandanten von aussen berücksichtigen
--            |         | FLW001              | Originalbeleg durchschleussen
-----------------------------------------------------------------------------------------
CREATE PROCEDURE [Helper].[usp_Reprocess_MasterData_From_Queue]
	@QueueID   bigint = null,
	@ClientURN nvarchar(512) = null,	--FLW001+
	@All       bit    = 0
AS
BEGIN
	SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
	SET NOCOUNT ON;

	DECLARE @EPCISMasterData	 xml;
	DECLARE @EPCISMasterDataOrig xml;	--FLW001+
	DECLARE @Client				 nvarchar(512);
	DECLARE @ErrorQID			 bigint;

	IF @All = 0 and @QueueID is null
		THROW 51000, N'QueueID has to be set', 1;

	IF @All = 1 and @QueueID is not null
		THROW 51000, N'QueueID must not be set or @All has to be 0', 1;

	declare curMasterDataQueue INSENSITIVE cursor for
		select EPCISMasterData, EPCISMasterDataOriginal, Client, ID from Import.EPCISMasterData_Queue where Error = 1 and (ID = @QueueID or @QueueID is null) and (Client = @ClientURN or @ClientURN is null);	--FLW001~

	open curMasterDataQueue;

	fetch next from curMasterDataQueue into @EPCISMasterData, @EPCISMasterDataOrig, @Client, @ErrorQID;	--FLW001~

	while @@FETCH_STATUS = 0
	begin

		begin try

			begin transaction

			exec [Import].[usp_Import_MasterData]
				@EPCISMasterData = @EPCISMasterData,
				@Client          = @Client;

			delete from Import.Error where ErrorProcedure = N'usp_Import_MasterData' and ObjectID = @ErrorQID;
			delete from Import.EPCISMasterData_Queue where ID = @ErrorQID;

			print N'Success for ' + CONVERT(nvarchar(50), @ErrorQID);

			commit transaction;

		end try
		begin catch

			rollback transaction;
			begin transaction;

			begin try
			
				declare @ErrorQueue table (
					ID bigint
				);

				declare @ErrorQueueID bigint;

				-- Fehlerprotokoll
				INSERT INTO [Import].[EPCISMasterData_Queue] (
					EPCISMasterData, Client, Processed, Error)
				OUTPUT inserted.ID INTO @ErrorQueue
				VALUES
					(
					@EPCISMasterData, @Client, 0, 1
					)
			
				SELECT TOP 1 @ErrorQueueID = ID FROM @ErrorQueue;

				-- Protokolliere Fehler
				exec [Import].[usp_write_error_log]
					 @AddInformation = N'ObjectID: EPCISMasterData_QUEUE'
					,@ObjectID = @ErrorQueueID;

				-->FLW001 INSERT START
				update Import.EPCISMasterData_Queue set EPCISMasterDataOriginal = @EPCISMasterDataOrig where ID = @ErrorQueueID;
				--<FLW001 INSERT END

				delete from Import.Error where ErrorProcedure = N'usp_Import_Event_to_Queue' and ObjectID = @ErrorQID;
				delete from Import.EPCISMasterData_Queue where ID = @ErrorQID;
				delete from @ErrorQueue;

				print N'Failure for ' + CONVERT(nvarchar(50), @ErrorQID) + N' - new ErrorQueueID ' + CONVERT(nvarchar(50), @ErrorQueueID) ;

				commit transaction;

			end try
			begin catch

				rollback transaction;

				-- Rethrow Error with extended Error Message
				DECLARE @ErrorMsg		nvarchar(4000) = ERROR_MESSAGE();
				DECLARE @ErrorState		int			   = isnull(ERROR_STATE(), 1);

				SET @ErrorMsg = N'Error while storing to Master Data QUEUE' + SUBSTRING(@ErrorMsg, 1, 3962);

				THROW 51000, @ErrorMsg, @ErrorState;

			end catch;


		end catch;

		fetch next from curMasterDataQueue into @EPCISMasterData, @EPCISMasterDataOrig, @Client, @ErrorQID;	--FLW001~
	end; -- CURSOR WHILE

	close curMasterDataQueue;
	deallocate curMasterDataQueue;

END
GO
PRINT N'Creating [Helper].[usp_Reprocess_Event_From_Queue]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2013  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 06.08.2013 | 1.0.0.0 | Florian Wagner      | Erstellt.
-----------------------------------------------------------------------------------------
-- 03.09.2014 | 1.0.1.0 | Florian Wagner      | Mandanten von aussen berücksichtigen
--            |         | FLW001              | Originalbeleg durchschleussen
-----------------------------------------------------------------------------------------
CREATE PROCEDURE [Helper].[usp_Reprocess_Event_From_Queue]
	@QueueID   bigint = null,
	@ClientURN nvarchar(512) = null,	--FLW001+
	@All       bit    = 0
AS
BEGIN
	
	SET NOCOUNT ON;

	DECLARE @EPCISEvent     xml;
	DECLARE @EPCISEventOrig xml;		--FLW001+
	DECLARE @Client		    nvarchar(512);
	DECLARE @ErrorQID       bigint;

	IF @All = 0 and @QueueID is null
		THROW 51000, N'QueueID has to be set', 1;

	IF @All = 1 and @QueueID is not null
		THROW 51000, N'QueueID must not be set or @All has to be 0', 1;

	declare curEventQueue INSENSITIVE cursor for
		select EPCISEvent, EPCISEventOriginal, Client, ID from Import.EPCISEvent_Queue where Error = 1 and (ID = @QueueID or @QueueID is null) and (Client = @ClientURN or @ClientURN is null);	--FLW001~

	open curEventQueue;

	fetch next from curEventQueue into @EPCISEvent, @EPCISEventOrig, @Client, @ErrorQID;		--FLW001~

	while @@FETCH_STATUS = 0
	begin

		begin try

			begin transaction

			exec [Import].[usp_Import_Event]
				@EPCISEvent = @EPCISEvent,
				@Client     = @Client;

			delete from Import.Error where ErrorProcedure = N'usp_Import_Event' and ObjectID = @ErrorQID;
			delete from Import.EPCISEvent_Queue where ID = @ErrorQID;

			print N'Success for ' + CONVERT(nvarchar(50), @ErrorQID);

			commit transaction;

		end try
		begin catch

			rollback transaction;
			begin transaction;

			begin try
			
				declare @ErrorQueue table (
					ID bigint
				);

				declare @ErrorQueueID bigint;

				-- Fehlerprotokoll
				INSERT INTO [Import].[EPCISEvent_Queue] (
					EPCISEvent, Client, Processed, Error)
				OUTPUT inserted.ID INTO @ErrorQueue
				VALUES
					(
					@EPCISEvent, @Client, 0, 1
					);
			
				SELECT TOP 1 @ErrorQueueID = ID FROM @ErrorQueue;

				-- Protokolliere Fehler
				exec [Import].[usp_write_error_log]
					 @AddInformation = N'ObjectID: EPCISEvent_QUEUE'
					,@ObjectID = @ErrorQueueID;

				-->FLW001 INSERT START
				update Import.EPCISEvent_Queue set EPCISEventOriginal = @EPCISEventOrig where ID = @ErrorQueueID;
				--<FLW001 INSERT END

				delete from Import.Error where ErrorProcedure = N'usp_Import_Event' and ObjectID = @ErrorQID;
				delete from Import.EPCISEvent_Queue where ID = @ErrorQID;
				delete from @ErrorQueue;

				print N'Failure for ' + CONVERT(nvarchar(50), @ErrorQID) + N' - new ErrorQueueID ' + CONVERT(nvarchar(50), @ErrorQueueID) ;

				commit transaction;

			end try
			begin catch

				rollback transaction;

				-- Rethrow Error with extended Error Message
				DECLARE @ErrorMsg		nvarchar(4000) = ERROR_MESSAGE();
				DECLARE @ErrorState		int			   = isnull(ERROR_STATE(), 1);

				SET @ErrorMsg = N'Error while storing to Event QUEUE' + SUBSTRING(@ErrorMsg, 1, 3962);

				THROW 51000, @ErrorMsg, @ErrorState;

			end catch;


		end catch;

		fetch next from curEventQueue into @EPCISEvent, @EPCISEventOrig, @Client, @ErrorQID;		--FLW001~
	end; -- CURSOR WHILE

	close curEventQueue;
	deallocate curEventQueue;

END
GO
PRINT N'Creating [Import].[usp_Import_MasterData_to_Queue]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2013  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 25.02.2013 | 1.0.0.0 | Sven Scholle	      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE PROCEDURE [Import].[usp_Import_MasterData_to_Queue]
	 @EPCISMasterData xml
	,@Client nvarchar(255) = 'urn:quibiq:epcis:cbv:client:gmos'
AS
BEGIN
	SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
	SET NOCOUNT ON;

	begin try

		begin transaction

		exec [Import].[usp_Import_MasterData]
			@EPCISMasterData = @EPCISMasterData,
			@Client          = @Client;

		;with XMLNAMESPACES ('http://Import/SQL' as "sql")
		select	
			1 as "sql:ReturnValue"
		for xml path(''), root('sql:usp_Import_MasterData_to_Queue')

	commit transaction;

	end try
	begin catch

		rollback transaction;
		begin transaction;

		begin try
			
			declare @ErrorQueue table (
				ID bigint
			);

			declare @ErrorQueueID bigint;

			-- Fehlerprotokoll
			INSERT INTO [Import].[EPCISMasterData_Queue] (
				EPCISMasterData, Client, Processed, Error)
			OUTPUT inserted.ID INTO @ErrorQueue
			VALUES
				(
				@EPCISMasterData, @Client, 0, 1
				)

			SELECT TOP 1 @ErrorQueueID = ID FROM @ErrorQueue;

			;with XMLNAMESPACES ('http://Import/SQL' as "sql")
			select	
				1 as "sql:ReturnValue"
			for xml path(''), root('sql:usp_Import_MasterData_to_Queue')

			-- Protokolliere Fehler
			exec [Import].[usp_write_error_log]
				 @AddInformation = N'ObjectID: EPCISMasterData_QUEUE'
				,@ObjectID = @ErrorQueueID;

			commit transaction;

		end try
		begin catch

			rollback transaction;

			-- Rethrow Error with extended Error Message
			DECLARE @ErrorMsg		nvarchar(4000) = ERROR_MESSAGE();
			DECLARE @ErrorState		int			   = isnull(ERROR_STATE(), 1);

			SET @ErrorMsg = N'Error while storing to MasterDataQUEUE' + SUBSTRING(@ErrorMsg, 1, 3962);

			THROW 51000, @ErrorMsg, @ErrorState;

		end catch;

	end catch;
END
GO
PRINT N'Creating [Import].[usp_Import_Event_to_Queue]...';


GO
-----------------------------------------------------------------------------------------
-- Projekt:  EPCIS
-- Firma:    QUIBIQ
-- (c) 2013  QUIBIQ Schweiz AG
-----------------------------------------------------------------------------------------
--
-- 
-- 
-- Datum      | Version | Autor               | Kommentar
--------------|---------|---------------------|------------------------------------------
-- 30.01.2013 | 1.0.0.0 | Sven Scholle	      | Erstellt.
-----------------------------------------------------------------------------------------
CREATE PROCEDURE [Import].[usp_Import_Event_to_Queue]
	@EPCISEvent xml,
	@Client nvarchar(255) = N'urn:quibiq:epcis:cbv:client:gmos'
AS
BEGIN
	DECLARE @RecordTime datetime2
	
	SET NOCOUNT ON;

	begin try

		begin transaction

		exec [Import].[usp_Import_Event]
			@EPCISEvent = @EPCISEvent,
			@Client     = @Client,
			@RecordTime = @RecordTime output

		;with XMLNAMESPACES ('http://Import/SQL' as "sql")
		select	
			1 as "sql:ReturnValue",
			@RecordTime as "sql:RecordTime"
		for xml path(''), root('sql:usp_Import_Event_to_Queue')

		commit transaction;

	end try
	begin catch

		rollback transaction;
		begin transaction;

		begin try
			
			declare @ErrorQueue table (
				ID bigint
			);

			declare @ErrorQueueID bigint;

			-- Fehlerprotokoll
			INSERT INTO [Import].[EPCISEvent_Queue] (
				EPCISEvent, Client, Processed, Error)
			OUTPUT inserted.ID INTO @ErrorQueue
			VALUES
				(
				@EPCISEvent, @Client, 0, 1
				);
			
			SELECT TOP 1 @ErrorQueueID = ID FROM @ErrorQueue;

			;with XMLNAMESPACES ('http://Import/SQL' as "sql")
			select	
				ERROR_NUMBER() as "sql:ReturnValue",
				ERROR_MESSAGE() as "sql:Error"
			for xml path(''), root('sql:usp_Import_Event_to_Queue')

			-- Protokolliere Fehler
			exec [Import].[usp_write_error_log]
				 @AddInformation = N'ObjectID: EPCISEvent_QUEUE'
				,@ObjectID = @ErrorQueueID;

			commit transaction;

		end try
		begin catch

			rollback transaction;

			-- Rethrow Error with extended Error Message
			DECLARE @ErrorMsg		nvarchar(4000) = ERROR_MESSAGE();
			DECLARE @ErrorState		int			   = isnull(ERROR_STATE(), 1);

			SET @ErrorMsg = N'Error while storing to Event QUEUE' + SUBSTRING(@ErrorMsg, 1, 3962);

			THROW 51000, @ErrorMsg, @ErrorState;

		end catch;


	end catch;

END
GO
PRINT N'Creating [Helper].[usp_New_Mandant]...';


GO
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
Create PROCEDURE [Helper].[usp_New_Mandant]
	-- Add the parameters for the stored procedure here
		@CLIENTUPPER NVARCHAR(100),
		@QUERYSERVERNAME NVARCHAR(100),
		@USER NVARCHAR(1000)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here

----------------------------------------------------------
-- Set Variables
----------------------------------------------------------
DECLARE	@CLIENTLOWER NVARCHAR(100)

SET @CLIENTLOWER = LOWER(@CLIENTUPPER)

----------------------------------------------------------
-- Vocabulary.VocabularyType only Insert
----------------------------------------------------------
CREATE TABLE #VocabularyType (
    [URN]         NVARCHAR (512) NOT NULL,
    [Description] NVARCHAR (50)  NOT NULL,
    [MaxOccurs]   INT            NOT NULL
     );

-- Insert Content into temp-Table
INSERT INTO #VocabularyType
           ([URN]
           ,[Description]
           ,[MaxOccurs])
     VALUES
           (N'urn:quibiq:epcis:vtype:client'
           ,N''
           ,1);

-- Mix Information (delete/insert won't work because of Foreign Key Constraints)
MERGE INTO [Vocabulary].[VocabularyType] AS TARGET
USING #VocabularyType AS SOURCE
ON (target.[URN] = source.[URN] COLLATE Latin1_General_CI_AS)
--WHEN MATCHED			    
--	THEN UPDATE SET [URN] = source.[URN], [Description] = source.[Description], [MaxOccurs] = source.[MaxOccurs]
WHEN NOT MATCHED BY TARGET 
    THEN INSERT ([URN]
                ,[Description]
                ,[MaxOccurs])
         VALUES (source.[URN], source.[Description], source.[MaxOccurs])
--WHEN NOT MATCHED BY SOURCE 
--	THEN DELETE
;

----------------------------------------------------------
-- Vocabulary.Vocabulary only Insert
----------------------------------------------------------
CREATE TABLE #Vocabulary (
    [ClientID]         BIGINT         NOT NULL,
    [VocabularyTypeID] BIGINT         NOT NULL,
    [URN]              NVARCHAR (512) NOT NULL
)

INSERT INTO #Vocabulary
           ([ClientID]
           ,[VocabularyTypeID]
           ,[URN])
     VALUES
           (1
           ,1
           ,N'urn:quibiq:epcis:cbv:client:epcisrepository')
           ,
           (1
           ,1
           ,N'urn:quibiq:epcis:cbv:client:' + @CLIENTLOWER);

-- Mix Information (delete/insert won't work because of Foreign Key Constraints)
MERGE INTO [Vocabulary].[Vocabulary] AS TARGET
USING #Vocabulary AS SOURCE
ON (target.[URN] = source.[URN] COLLATE Latin1_General_CI_AS and target.[ClientID] = source.[ClientID] and target.[VocabularyTypeID] = source.[VocabularyTypeID])
--WHEN MATCHED			    
--	THEN UPDATE SET [URN] = source.[URN], [ClientID] = source.[ClientID], [VocabularyTypeID] = source.[VocabularyTypeID]
WHEN NOT MATCHED BY TARGET 
    THEN INSERT ([ClientID]
                 ,[VocabularyTypeID]
                 ,[URN])
         VALUES (source.[ClientID], source.[VocabularyTypeID], source.[URN])
--WHEN NOT MATCHED BY SOURCE 
--	THEN DELETE
;
----------------------------------------------------------
-- Vocabulary.VocabularyType_Client only Insert
----------------------------------------------------------
IF (not exists (select 1 from Vocabulary.VocabularyType_Client))
BEGIN
INSERT INTO Vocabulary.VocabularyType_Client (VocabularyTypeID, ClientID) VALUES (1, 1);
END;

drop table #VocabularyType;
drop table #Vocabulary;

DECLARE @RC int
DECLARE @EPCISMasterData xml
DECLARE @Client nvarchar(255)

set @Client = N'urn:quibiq:epcis:cbv:client:epcisrepository';

set @EPCISMasterData = N'<?xml version="1.0" encoding="utf-16" standalone="yes"?>
<epcismd:EPCISMasterDataDocument xmlns:epcismd="urn:epcglobal:epcis-masterdata:xsd:1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" schemaVersion="1" creationDate="2015-03-17T09:22:00+02:00">
	<EPCISBody>
		<VocabularyList>
			<Vocabulary type="urn:quibiq:epcis:vtype:action">
				<VocabularyElementList>
					<VocabularyElement id="urn:quibiq:epcis:cbv:action:add"/>
					<VocabularyElement id="urn:quibiq:epcis:cbv:action:observe"/>
					<VocabularyElement id="urn:quibiq:epcis:cbv:action:delete"/>
				</VocabularyElementList>
			</Vocabulary>
			<Vocabulary type="urn:quibiq:epcis:vtype:event">
				<VocabularyElementList>
					<VocabularyElement id="urn:quibiq:epcis:cbv:event:object"/>
					<VocabularyElement id="urn:quibiq:epcis:cbv:event:aggregation"/>
					<VocabularyElement id="urn:quibiq:epcis:cbv:event:quantity"/>
					<VocabularyElement id="urn:quibiq:epcis:cbv:event:transaction"/>
					<VocabularyElement id="urn:quibiq:epcis:cbv:event:transformation"/>		
				</VocabularyElementList>
			</Vocabulary>
			<Vocabulary type="urn:quibiq:epcis:vtype:valuetype">
				<VocabularyElementList>
					<VocabularyElement id="urn:quibiq:epcis:cbv:valuetype:quantity"/>
				</VocabularyElementList>
			</Vocabulary>
			<Vocabulary type="urn:quibiq:epcis:vtype:datatype">
				<VocabularyElementList>
					<VocabularyElement id="urn:quibiq:epcis:cbv:datatype:int"/>
					<VocabularyElement id="urn:quibiq:epcis:cbv:datatype:float"/>
					<VocabularyElement id="urn:quibiq:epcis:cbv:datatype:time"/>
					<VocabularyElement id="urn:quibiq:epcis:cbv:datatype:xml"/>
					<VocabularyElement id="urn:quibiq:epcis:cbv:datatype:string"/>
					<VocabularyElement id="urn:quibiq:epcis:cbv:datatype:unknown"/>
				</VocabularyElementList>
			</Vocabulary>
			<Vocabulary type="urn:quibiq:epcis:vtype:extensiontype"/>
			<Vocabulary type="urn:quibiq:epcis:vtype:ilmd"/>
		</VocabularyList>
	</EPCISBody>
</epcismd:EPCISMasterDataDocument>'

EXECUTE @RC = [Import].[usp_Import_MasterData_to_Queue] 
   @EPCISMasterData
  ,@Client

set @Client = N'urn:quibiq:epcis:cbv:client:epcisrepository';

set @EPCISMasterData = N'<epcismd:EPCISMasterDataDocument xmlns:epcismd="urn:epcglobal:epcis-masterdata:xsd:1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" schemaVersion="1" creationDate="2005-07-11T11:30:47.0Z">
<EPCISBody>
	<VocabularyList>
		<Vocabulary type="urn:quibiq:epcis:vtype:client">
			<VocabularyElementList>
				<VocabularyElement id="urn:quibiq:epcis:cbv:client:' + @CLIENTLOWER + '">
					<attribute id="urn:quibiq:epcis:atype:receiveport">
						<receiveport xmlns ="urn:quibiq:epcis:atype:receiveport">GetEPCISDocumentRcvPort_' + @CLIENTUPPER + '</receiveport>
						<receiveport xmlns ="urn:quibiq:epcis:atype:receiveport">GetEPCISMasterDataServiceSoap_' + @CLIENTUPPER + '</receiveport>    
					</attribute>
					<attribute id="urn:quibiq:epcis:atype:querycontrolendpoint">
						<endpoint xmlns ="urn:quibiq:epcis:atype:querycontrolendpoint">' + @QUERYSERVERNAME + '/EPCISQueryHTTP/EPCISQueryHttpService.svc/Request?mandant:urn:quibiq:epcis:cbv:client:' + @CLIENTLOWER + '</endpoint>
					</attribute>
					<attribute id="urn:quibiq:epcis:atype:StandardBusinessDocumentHeader">
						<sbdh:StandardBusinessDocumentHeader xmlns:sbdh="http://www.unece.org/cefact/namespaces/StandardBusinessDocumentHeader">
							<sbdh:HeaderVersion>1.0</sbdh:HeaderVersion>
							<sbdh:Sender>
								<sbdh:Identifier Authority="EAN.UCC">urn:epc:id:gln:7617007099109</sbdh:Identifier>
							</sbdh:Sender>
							<sbdh:Receiver>
								<sbdh:Identifier Authority="EAN.UCC">urn:epc:id:gln:</sbdh:Identifier>
							</sbdh:Receiver>
							<sbdh:DocumentIdentification>
								<sbdh:Standard>EPCISStandard</sbdh:Standard>
								<sbdh:TypeVersion>1.1</sbdh:TypeVersion>
								<sbdh:InstanceIdentifier>Laufnummer</sbdh:InstanceIdentifier>
								<sbdh:Type>Event</sbdh:Type>
								<sbdh:MultipleType>false</sbdh:MultipleType>
								<sbdh:CreationDateAndTime>CurrentDate</sbdh:CreationDateAndTime>
							</sbdh:DocumentIdentification>
							<sbdh:Manifest>
								<sbdh:NumberOfItems>AnzahlSaetze</sbdh:NumberOfItems>
								<sbdh:ManifestItem>
									<sbdh:MimeTypeQualifierCode>text/xml</sbdh:MimeTypeQualifierCode>
									<sbdh:UniformResourceIdentifier>urn:epcglobal</sbdh:UniformResourceIdentifier>
								</sbdh:ManifestItem>
							</sbdh:Manifest>
						</sbdh:StandardBusinessDocumentHeader>
					</attribute>
					<attribute id="urn:quibiq:epcis:atype:instanceidentifier">0</attribute>
					<attribute id="urn:quibiq:epcis:atype:masteruser">' +
						@USER +
					'</attribute>
				</VocabularyElement>
			</VocabularyElementList>
		</Vocabulary>
	</VocabularyList>
</EPCISBody>
</epcismd:EPCISMasterDataDocument>'

EXECUTE @RC = [Import].[usp_Import_MasterData_to_Queue] 
   @EPCISMasterData
  ,@Client


set @Client = N'urn:quibiq:epcis:cbv:client:' + @CLIENTLOWER;

set @EPCISMasterData = N'<?xml version="1.0" encoding="utf-16" standalone="yes"?>
<epcismd:EPCISMasterDataDocument xmlns:epcismd="urn:epcglobal:epcis-masterdata:xsd:1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" schemaVersion="1" creationDate="2015-03-17T09:22:00+02:00">
	<EPCISBody>
		<VocabularyList>
			<Vocabulary type="urn:epcglobal:epcis:vtype:ReadPoint">
			</Vocabulary>
			<Vocabulary type="urn:epcglobal:epcis:vtype:BusinessLocation">
			</Vocabulary>
			<Vocabulary type="urn:epcglobal:epcis:vtype:SourceDest">
			</Vocabulary>
			<Vocabulary type="urn:epcglobal:epcis:vtype:BusinessStep">
				<VocabularyElementList>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:accepting"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:arriving"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:assembling"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:collecting"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:commissioning"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:consigning"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:creating_class_instance"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:cycle_counting"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:decommissioning"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:departing"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:destroying"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:disassembling"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:encoding"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:entering_exiting"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:holding"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:inspecting"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:installing"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:killing"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:loading"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:other"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:packing"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:picking"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:receiving"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:removing"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:repackaging"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:repairing"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:replacing"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:reserving"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:retail_selling"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:shipping"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:staging_outbound"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:stock_taking"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:stocking"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:storing"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:transforming"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:transporting"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:unloading"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:unpacking"/>
				</VocabularyElementList>
			</Vocabulary>
			<Vocabulary type="urn:epcglobal:epcis:vtype:Disposition">
				<VocabularyElementList>
					<VocabularyElement id="urn:epcglobal:cbv:disp:active"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:container_closed"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:destroyed"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:encoded"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:inactive"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:in_progress"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:in_transit"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:non_sellable_expired"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:non_sellable_damaged"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:non_sellable_disposed"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:non_sellable_no_pedigree_match"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:non_sellable_recalled"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:expired"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:damaged"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:disposed"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:no_pedigree_match"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:non_sellable_other"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:recalled"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:reserved"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:returned"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:sellable_accessible"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:sellable_not_accessible"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:retail_sold"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:stolen"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:unknown"/>	
					<VocabularyElement id="http://epcis.migros.net/migros/disposition/dutied"/>				
				</VocabularyElementList>
			</Vocabulary>
			<!--Vocabulary type="urn:epcglobal:epcis:vtype:BusinessTransaction">
				</Vocabulary!-->
			<Vocabulary type="urn:epcglobal:epcis:vtype:BusinessTransactionType">
				<VocabularyElementList>
					<VocabularyElement id="urn:epcglobal:cbv:btt:po"/>
					<VocabularyElement id="urn:epcglobal:cbv:btt:poc"/>
					<VocabularyElement id="urn:epcglobal:cbv:btt:bol"/>
					<VocabularyElement id="urn:epcglobal:cbv:btt:inv"/>
					<VocabularyElement id="urn:epcglobal:cbv:btt:rma"/>
					<VocabularyElement id="urn:epcglobal:cbv:btt:pedigree"/>
					<VocabularyElement id="urn:epcglobal:cbv:btt:desadv"/>
					<VocabularyElement id="urn:epcglobal:cbv:btt:recadv"/>
					<VocabularyElement id="urn:epcglobal:cbv:btt:prodorder"/>
					<VocabularyElement id="urn:epcglobal:fmcg:btt:po"/>
					<VocabularyElement id="urn:epcglobal:fmcg:btt:desadv"/>
				</VocabularyElementList>
			</Vocabulary>
			<Vocabulary type="urn:epcglobal:epcis:vtype:EPCClass">	
				<VocabularyElementList>
					<VocabularyElement id="urn:epc:class:lgtin:0761702.758320.L-Y15"/>
					<VocabularyElement id="urn:epc:class:lgtin:0761702.780772.L-Y15"/>			
					<VocabularyElement id="urn:epc:class:lgtin:0761702.780772.L-X12"/>		
					<VocabularyElement id="urn:epc:idpat:sgtin:0761020.038433.*"/>		
					<VocabularyElement id="urn:epc:class:lgtin:0761702.780772.Lot15"/>
					<VocabularyElement id="urn:epc:class:lgtin:0761020.027766.L-R01"/>		
					<VocabularyElement id="urn:epc:class:lgtin:0761020.038433.L-E52"/>		
					<VocabularyElement id="urn:epc:idpat:sgtin:0761020.027766.*"/>		
					<VocabularyElement id="urn:epc:idpat:sgtin:0761020.027995.*"/>	
				</VocabularyElementList>	
			</Vocabulary>
			<Vocabulary type="urn:epcglobal:epcis:vtype:SourceDestType">
				<VocabularyElementList>
					<VocabularyElement id="urn:epcglobal:cbv:sdt:owning_party"/>
					<VocabularyElement id="urn:epcglobal:cbv:sdt:possessing_party"/>
					<VocabularyElement id="urn:epcglobal:cbv:sdt:location"/>
					<VocabularyElement id="http://epcis.migros.net/migros/elements/destination/SU"/>
					<VocabularyElement id="http://epcis.migros.net/migros/elements/destination/DP"/>
					<VocabularyElement id="http://epcis.migros.net/migros/elements/destination/UC"/>
					<VocabularyElement id="http://migros.net/migros/ele/dest/SU"/>
					<VocabularyElement id="http://migros.net/migros/ele/dest/UC"/>
					<VocabularyElement id="http://migros.net/migros/ele/dest/DP"/>
				</VocabularyElementList>
			</Vocabulary>
		</VocabularyList>
	</EPCISBody>
</epcismd:EPCISMasterDataDocument>'

EXECUTE @RC = [Import].[usp_Import_MasterData_to_Queue] 
   @EPCISMasterData
  ,@Client
END
GO
PRINT N'Creating [dbo].[View_Events_per_Hour].[MS_DiagramPane1]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_DiagramPane1', @value = N'[0E232FF0-B466-11cf-A24F-00AA00A3EFFF, 1.00]
Begin DesignProperties = 
   Begin PaneConfigurations = 
      Begin PaneConfiguration = 0
         NumPanes = 4
         Configuration = "(H (1[40] 4[20] 2[20] 3) )"
      End
      Begin PaneConfiguration = 1
         NumPanes = 3
         Configuration = "(H (1 [50] 4 [25] 3))"
      End
      Begin PaneConfiguration = 2
         NumPanes = 3
         Configuration = "(H (1 [50] 2 [25] 3))"
      End
      Begin PaneConfiguration = 3
         NumPanes = 3
         Configuration = "(H (4 [30] 2 [40] 3))"
      End
      Begin PaneConfiguration = 4
         NumPanes = 2
         Configuration = "(H (1 [56] 3))"
      End
      Begin PaneConfiguration = 5
         NumPanes = 2
         Configuration = "(H (2 [66] 3))"
      End
      Begin PaneConfiguration = 6
         NumPanes = 2
         Configuration = "(H (4 [50] 3))"
      End
      Begin PaneConfiguration = 7
         NumPanes = 1
         Configuration = "(V (3))"
      End
      Begin PaneConfiguration = 8
         NumPanes = 3
         Configuration = "(H (1[56] 4[18] 2) )"
      End
      Begin PaneConfiguration = 9
         NumPanes = 2
         Configuration = "(H (1 [75] 4))"
      End
      Begin PaneConfiguration = 10
         NumPanes = 2
         Configuration = "(H (1[66] 2) )"
      End
      Begin PaneConfiguration = 11
         NumPanes = 2
         Configuration = "(H (4 [60] 2))"
      End
      Begin PaneConfiguration = 12
         NumPanes = 1
         Configuration = "(H (1) )"
      End
      Begin PaneConfiguration = 13
         NumPanes = 1
         Configuration = "(V (4))"
      End
      Begin PaneConfiguration = 14
         NumPanes = 1
         Configuration = "(V (2))"
      End
      ActivePaneConfig = 0
   End
   Begin DiagramPane = 
      Begin Origin = 
         Top = 0
         Left = 0
      End
      Begin Tables = 
         Begin Table = "EPCISEvent (Event)"
            Begin Extent = 
               Top = 6
               Left = 38
               Bottom = 114
               Right = 223
            End
            DisplayFlags = 280
            TopColumn = 0
         End
      End
   End
   Begin SQLPane = 
   End
   Begin DataPane = 
      Begin ParameterDefaults = ""
      End
      Begin ColumnWidths = 9
         Width = 284
         Width = 1500
         Width = 1500
         Width = 1500
         Width = 1500
         Width = 1500
         Width = 1500
         Width = 1500
         Width = 1500
      End
   End
   Begin CriteriaPane = 
      Begin ColumnWidths = 12
         Column = 1440
         Alias = 900
         Table = 1170
         Output = 720
         Append = 1400
         NewValue = 1170
         SortType = 1350
         SortOrder = 1410
         GroupBy = 1350
         Filter = 1350
         Or = 1350
         Or = 1350
         Or = 1350
      End
   End
End
', @level0type = N'SCHEMA', @level0name = N'dbo', @level1type = N'VIEW', @level1name = N'View_Events_per_Hour';


GO
PRINT N'Creating [dbo].[View_Events_per_Hour].[MS_DiagramPaneCount]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_DiagramPaneCount', @value = 1, @level0type = N'SCHEMA', @level0name = N'dbo', @level1type = N'VIEW', @level1name = N'View_Events_per_Hour';


GO
/*
Post-Deployment Script Template							
--------------------------------------------------------------------------------------
 This file contains SQL statements that will be appended to the build script.		
 Use SQLCMD syntax to include a file in the post-deployment script.			
 Example:      :r .\myfile.sql								
 Use SQLCMD syntax to reference a variable in the post-deployment script.		
 Example:      :setvar TableName MyTable							
               SELECT * FROM [$(TableName)]					
--------------------------------------------------------------------------------------
*/
----------------------------------------------------------
-- Vocabulary.VocabularyType only Insert
----------------------------------------------------------
CREATE TABLE #VocabularyType (
    [URN]         NVARCHAR (512) NOT NULL,
    [Description] NVARCHAR (50)  NOT NULL,
    [MaxOccurs]   INT            NOT NULL
     );

-- Insert Content into temp-Table
INSERT INTO #VocabularyType
([URN]
 ,[Description]
 ,[MaxOccurs])
VALUES
(N'urn:quibiq:epcis:vtype:client'
,N''
,1);

-- Mix Information (delete/insert won't work because of Foreign Key Constraints)
MERGE INTO [Vocabulary].[VocabularyType] AS TARGET
    USING #VocabularyType AS SOURCE
    ON (target.[URN] = source.[URN] COLLATE Latin1_General_CI_AS)
    --WHEN MATCHED			    
--	THEN UPDATE SET [URN] = source.[URN], [Description] = source.[Description], [MaxOccurs] = source.[MaxOccurs]
    WHEN NOT MATCHED BY TARGET
    THEN INSERT ([URN]
    ,[Description]
    ,[MaxOccurs])
    VALUES (source.[URN], source.[Description], source.[MaxOccurs])
--WHEN NOT MATCHED BY SOURCE 
--	THEN DELETE
;

----------------------------------------------------------
-- Vocabulary.Vocabulary only Insert
----------------------------------------------------------
CREATE TABLE #Vocabulary (
    [ClientID]         BIGINT         NOT NULL,
    [VocabularyTypeID] BIGINT         NOT NULL,
    [URN]              NVARCHAR (512) NOT NULL
    )

    INSERT INTO #Vocabulary
           ([ClientID]
           ,[VocabularyTypeID]
           ,[URN])
     VALUES
           (1
           ,1
           ,N'urn:quibiq:epcis:cbv:client:epcisrepository')
           ,
           (1
           ,1
           ,N'urn:quibiq:epcis:cbv:client:gmos');

-- Mix Information (delete/insert won't work because of Foreign Key Constraints)
MERGE INTO [Vocabulary].[Vocabulary] AS TARGET
    USING #Vocabulary AS SOURCE
    ON (target.[URN] = source.[URN] COLLATE Latin1_General_CI_AS and target.[ClientID] = source.[ClientID] and target.[VocabularyTypeID] = source.[VocabularyTypeID])
    --WHEN MATCHED			    
--	THEN UPDATE SET [URN] = source.[URN], [ClientID] = source.[ClientID], [VocabularyTypeID] = source.[VocabularyTypeID]
    WHEN NOT MATCHED BY TARGET
    THEN INSERT ([ClientID]
    ,[VocabularyTypeID]
    ,[URN])
    VALUES (source.[ClientID], source.[VocabularyTypeID], source.[URN])
--WHEN NOT MATCHED BY SOURCE 
--	THEN DELETE
;
----------------------------------------------------------
-- Vocabulary.VocabularyType_Client only Insert
----------------------------------------------------------
IF (not exists (select 1 from Vocabulary.VocabularyType_Client))
BEGIN
INSERT INTO Vocabulary.VocabularyType_Client (VocabularyTypeID, ClientID) VALUES (1, 1);
END;

drop table #VocabularyType;
drop table #Vocabulary;


DECLARE @RC int
DECLARE @EPCISMasterData xml
DECLARE @Client nvarchar(255)

set @Client = N'urn:quibiq:epcis:cbv:client:epcisrepository';

set @EPCISMasterData = N'<?xml version="1.0" encoding="utf-16" standalone="yes"?>
<epcismd:EPCISMasterDataDocument xmlns:epcismd="urn:epcglobal:epcis-masterdata:xsd:1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" schemaVersion="1" creationDate="2015-03-17T09:22:00+02:00">
	<EPCISBody>
		<VocabularyList>
			<Vocabulary type="urn:quibiq:epcis:vtype:action">
				<VocabularyElementList>
					<VocabularyElement id="urn:quibiq:epcis:cbv:action:add"/>
					<VocabularyElement id="urn:quibiq:epcis:cbv:action:observe"/>
					<VocabularyElement id="urn:quibiq:epcis:cbv:action:delete"/>
				</VocabularyElementList>
			</Vocabulary>
			<Vocabulary type="urn:quibiq:epcis:vtype:event">
				<VocabularyElementList>
					<VocabularyElement id="urn:quibiq:epcis:cbv:event:object"/>
					<VocabularyElement id="urn:quibiq:epcis:cbv:event:aggregation"/>
					<VocabularyElement id="urn:quibiq:epcis:cbv:event:quantity"/>
					<VocabularyElement id="urn:quibiq:epcis:cbv:event:transaction"/>
					<VocabularyElement id="urn:quibiq:epcis:cbv:event:transformation"/>		
				</VocabularyElementList>
			</Vocabulary>
			<Vocabulary type="urn:quibiq:epcis:vtype:valuetype">
				<VocabularyElementList>
					<VocabularyElement id="urn:quibiq:epcis:cbv:valuetype:quantity"/>
				</VocabularyElementList>
			</Vocabulary>
			<Vocabulary type="urn:quibiq:epcis:vtype:baseextension">
				<VocabularyElementList>
					<VocabularyElement id="urn:quibiq:epcis:cbv:valuetype:eventid"/>
					<VocabularyElement id="urn:quibiq:epcis:cbv:valuetype:declarationtime"/>
					<VocabularyElement id="urn:quibiq:epcis:cbv:valuetype:reason"/>
					<VocabularyElement id="urn:quibiq:epcis:cbv:valuetype:correctiveeventid"/>
				</VocabularyElementList>
			</Vocabulary>
			<Vocabulary type="urn:quibiq:epcis:vtype:datatype">
				<VocabularyElementList>
					<VocabularyElement id="urn:quibiq:epcis:cbv:datatype:int"/>
					<VocabularyElement id="urn:quibiq:epcis:cbv:datatype:float"/>
					<VocabularyElement id="urn:quibiq:epcis:cbv:datatype:time"/>
					<VocabularyElement id="urn:quibiq:epcis:cbv:datatype:xml"/>
					<VocabularyElement id="urn:quibiq:epcis:cbv:datatype:string"/>
					<VocabularyElement id="urn:quibiq:epcis:cbv:datatype:unknown"/>
				</VocabularyElementList>
			</Vocabulary>
			<Vocabulary type="urn:quibiq:epcis:vtype:extensiontype"/>
			<Vocabulary type="urn:quibiq:epcis:vtype:ilmd"/>
			<Vocabulary type="urn:quibiq:epcis:vtype:baseextension"/>
			<Vocabulary type="urn:quibiq:epcis:vtype:errordeclaration"/>
		</VocabularyList>
	</EPCISBody>
</epcismd:EPCISMasterDataDocument>'

EXECUTE @RC = [Import].[usp_Import_MasterData_to_Queue] 
   @EPCISMasterData
  ,@Client

set @Client = N'urn:quibiq:epcis:cbv:client:epcisrepository';

set @EPCISMasterData = N'<epcismd:EPCISMasterDataDocument xmlns:epcismd="urn:epcglobal:epcis-masterdata:xsd:1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" schemaVersion="1" creationDate="2005-07-11T11:30:47.0Z">
<EPCISBody>
	<VocabularyList>
		<Vocabulary type="urn:quibiq:epcis:vtype:client">
			<VocabularyElementList>
				<VocabularyElement id="urn:quibiq:epcis:cbv:client:gmos">
					<attribute id="urn:quibiq:epcis:atype:receiveport">
						<receiveport xmlns ="urn:quibiq:epcis:atype:receiveport">GetEPCISDocumentRcvPort_GMOS</receiveport>
						<receiveport xmlns ="urn:quibiq:epcis:atype:receiveport">GetEPCISMasterDataServiceSoap_GMOS</receiveport>    
					</attribute>
					<attribute id="urn:quibiq:epcis:atype:querycontrolendpoint">
						<endpoint xmlns ="urn:quibiq:epcis:atype:querycontrolendpoint">http://Q1VM0022.gmos.ch/EPCISQueryHTTP1_1/EPCISQueryHttpService.svc/Request?mandant:urn:quibiq:epcis:cbv:client:gmos</endpoint>
					</attribute>
					<attribute id="urn:quibiq:epcis:atype:StandardBusinessDocumentHeader">
						<sbdh:StandardBusinessDocumentHeader xmlns:sbdh="http://www.unece.org/cefact/namespaces/StandardBusinessDocumentHeader">
							<sbdh:HeaderVersion>1.0</sbdh:HeaderVersion>
							<sbdh:Sender>
								<sbdh:Identifier Authority="EAN.UCC">urn:epc:id:gln:7617007099109</sbdh:Identifier>
							</sbdh:Sender>
							<sbdh:Receiver>
								<sbdh:Identifier Authority="EAN.UCC">urn:epc:id:gln:</sbdh:Identifier>
							</sbdh:Receiver>
							<sbdh:DocumentIdentification>
								<sbdh:Standard>EPCISStandard</sbdh:Standard>
								<sbdh:TypeVersion>1.1</sbdh:TypeVersion>
								<sbdh:InstanceIdentifier>Laufnummer</sbdh:InstanceIdentifier>
								<sbdh:Type>Event</sbdh:Type>
								<sbdh:MultipleType>false</sbdh:MultipleType>
								<sbdh:CreationDateAndTime>CurrentDate</sbdh:CreationDateAndTime>
							</sbdh:DocumentIdentification>
							<sbdh:Manifest>
								<sbdh:NumberOfItems>AnzahlSaetze</sbdh:NumberOfItems>
								<sbdh:ManifestItem>
									<sbdh:MimeTypeQualifierCode>text/xml</sbdh:MimeTypeQualifierCode>
									<sbdh:UniformResourceIdentifier>urn:epcglobal</sbdh:UniformResourceIdentifier>
								</sbdh:ManifestItem>
							</sbdh:Manifest>
						</sbdh:StandardBusinessDocumentHeader>
					</attribute>
					<attribute id="urn:quibiq:epcis:atype:instanceidentifier">0</attribute>
					<attribute id="urn:quibiq:epcis:atype:masteruser">
						<username xmlns ="urn:quibiq:epcis:atype:username">epcis_admin</username>
					</attribute>
				</VocabularyElement>
			</VocabularyElementList>
		</Vocabulary>
	</VocabularyList>
</EPCISBody>
</epcismd:EPCISMasterDataDocument>'

EXECUTE @RC = [Import].[usp_Import_MasterData_to_Queue] 
   @EPCISMasterData
  ,@Client


set @Client = N'urn:quibiq:epcis:cbv:client:gmos';

set @EPCISMasterData = N'<?xml version="1.0" encoding="utf-16" standalone="yes"?>
<epcismd:EPCISMasterDataDocument xmlns:epcismd="urn:epcglobal:epcis-masterdata:xsd:1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" schemaVersion="1" creationDate="2015-03-17T09:22:00+02:00">
	<EPCISBody>
		<VocabularyList>
			<Vocabulary type="urn:epcglobal:epcis:vtype:ReadPoint">
			</Vocabulary>
			<Vocabulary type="urn:epcglobal:epcis:vtype:BusinessLocation">
			</Vocabulary>
			<Vocabulary type="urn:epcglobal:epcis:vtype:SourceDest">
			</Vocabulary>
			<Vocabulary type="urn:epcglobal:epcis:vtype:BusinessStep">
				<VocabularyElementList>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:accepting"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:arriving"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:assembling"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:collecting"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:commissioning"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:consigning"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:creating_class_instance"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:cycle_counting"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:decommissioning"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:departing"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:destroying"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:disassembling"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:encoding"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:entering_exiting"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:holding"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:inspecting"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:installing"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:killing"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:loading"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:other"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:packing"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:picking"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:receiving"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:removing"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:repackaging"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:repairing"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:replacing"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:reserving"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:retail_selling"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:shipping"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:staging_outbound"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:stock_taking"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:stocking"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:storing"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:transforming"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:transporting"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:unloading"/>
					<VocabularyElement id="urn:epcglobal:cbv:bizstep:unpacking"/>
				</VocabularyElementList>
			</Vocabulary>
			<Vocabulary type="urn:epcglobal:epcis:vtype:Disposition">
				<VocabularyElementList>
					<VocabularyElement id="urn:epcglobal:cbv:disp:active"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:container_closed"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:destroyed"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:encoded"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:inactive"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:in_progress"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:in_transit"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:non_sellable_expired"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:non_sellable_damaged"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:non_sellable_disposed"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:non_sellable_no_pedigree_match"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:non_sellable_recalled"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:expired"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:damaged"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:disposed"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:no_pedigree_match"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:non_sellable_other"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:recalled"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:reserved"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:returned"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:sellable_accessible"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:sellable_not_accessible"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:retail_sold"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:stolen"/>
					<VocabularyElement id="urn:epcglobal:cbv:disp:unknown"/>	
					<VocabularyElement id="http://epcis.migros.net/migros/disposition/dutied"/>				
				</VocabularyElementList>
			</Vocabulary>
			<!--Vocabulary type="urn:epcglobal:epcis:vtype:BusinessTransaction">
				</Vocabulary!-->
			<Vocabulary type="urn:epcglobal:epcis:vtype:BusinessTransactionType">
				<VocabularyElementList>
					<VocabularyElement id="urn:epcglobal:cbv:btt:po"/>
					<VocabularyElement id="urn:epcglobal:cbv:btt:poc"/>
					<VocabularyElement id="urn:epcglobal:cbv:btt:bol"/>
					<VocabularyElement id="urn:epcglobal:cbv:btt:inv"/>
					<VocabularyElement id="urn:epcglobal:cbv:btt:rma"/>
					<VocabularyElement id="urn:epcglobal:cbv:btt:pedigree"/>
					<VocabularyElement id="urn:epcglobal:cbv:btt:desadv"/>
					<VocabularyElement id="urn:epcglobal:cbv:btt:recadv"/>
					<VocabularyElement id="urn:epcglobal:cbv:btt:prodorder"/>
					<VocabularyElement id="urn:epcglobal:fmcg:btt:po"/>
					<VocabularyElement id="urn:epcglobal:fmcg:btt:desadv"/>
				</VocabularyElementList>
			</Vocabulary>
			<Vocabulary type="urn:epcglobal:epcis:vtype:EPCClass">	
				<VocabularyElementList>
					<VocabularyElement id="urn:epc:class:lgtin:0761702.758320.L-Y15"/>
					<VocabularyElement id="urn:epc:class:lgtin:0761702.780772.L-Y15"/>			
					<VocabularyElement id="urn:epc:class:lgtin:0761702.780772.L-X12"/>		
					<VocabularyElement id="urn:epc:idpat:sgtin:0761020.038433.*"/>		
					<VocabularyElement id="urn:epc:class:lgtin:0761702.780772.Lot15"/>
					<VocabularyElement id="urn:epc:class:lgtin:0761020.027766.L-R01"/>		
					<VocabularyElement id="urn:epc:class:lgtin:0761020.038433.L-E52"/>		
					<VocabularyElement id="urn:epc:idpat:sgtin:0761020.027766.*"/>		
					<VocabularyElement id="urn:epc:idpat:sgtin:0761020.027995.*"/>	
				</VocabularyElementList>	
			</Vocabulary>
			<Vocabulary type="urn:epcglobal:epcis:vtype:SourceDestType">
				<VocabularyElementList>
					<VocabularyElement id="urn:epcglobal:cbv:sdt:owning_party"/>
					<VocabularyElement id="urn:epcglobal:cbv:sdt:possessing_party"/>
					<VocabularyElement id="urn:epcglobal:cbv:sdt:location"/>
					<VocabularyElement id="http://epcis.migros.net/migros/elements/destination/SU"/>
					<VocabularyElement id="http://epcis.migros.net/migros/elements/destination/DP"/>
					<VocabularyElement id="http://epcis.migros.net/migros/elements/destination/UC"/>
					<VocabularyElement id="http://migros.net/migros/ele/dest/SU"/>
					<VocabularyElement id="http://migros.net/migros/ele/dest/UC"/>
					<VocabularyElement id="http://migros.net/migros/ele/dest/DP"/>
				</VocabularyElementList>
			</Vocabulary>
		</VocabularyList>
	</EPCISBody>
</epcismd:EPCISMasterDataDocument>'

EXECUTE @RC = [Import].[usp_Import_MasterData_to_Queue] 
   @EPCISMasterData
  ,@Client
GO

GO
DECLARE @VarDecimalSupported AS BIT;

SELECT @VarDecimalSupported = 0;

IF ((ServerProperty(N'EngineEdition') = 3)
    AND (((@@microsoftversion / power(2, 24) = 9)
          AND (@@microsoftversion & 0xffff >= 3024))
         OR ((@@microsoftversion / power(2, 24) = 10)
             AND (@@microsoftversion & 0xffff >= 1600))))
    SELECT @VarDecimalSupported = 1;

IF (@VarDecimalSupported > 0)
    BEGIN
        EXECUTE sp_db_vardecimal_storage_format N'$(DatabaseName)', 'ON';
    END


GO
PRINT N'Update complete.';


GO
